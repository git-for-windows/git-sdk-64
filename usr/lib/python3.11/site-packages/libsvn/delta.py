# This file was automatically generated by SWIG (https://www.swig.org).
# Version 4.1.1
#
# Do not make changes to this file unless you know what you are doing - modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info

def _dll_paths():
    import os
    if hasattr(os, 'add_dll_directory'):  # Python 3.8+ on Windows
        cookies = []
        for path in os.environ.get('PATH', '').split(os.pathsep):
            if path and os.path.isabs(path):
                try:
                    cookie = os.add_dll_directory(path)
                except OSError:
                    continue
                else:
                    cookies.append(cookie)
        return cookies
    else:
        return ()

_dll_paths = _dll_paths()
try:
    from . import _delta
finally:
    _dll_path = None
    for _dll_path in _dll_paths:
        _dll_path.close()
    del _dll_paths, _dll_path


try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "this":
            set(self, name, value)
        elif name == "thisown":
            self.this.own(value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)



def _copy_metadata_deep(value, old_value):
  """Copy all attributes of old_value into value, recursively traversing
  lists and dicts if needed."""
  if value is None or old_value is None or value is old_value: return

  if isinstance(value, dict):
    for k in value:
      _copy_metadata_deep(value[k], old_value[k])
  elif isinstance(value, list):
    for v, old_v in zip(value, old_value):
      _copy_metadata_deep(v, old_v)
  else:
    try:
      value.__dict__.update(old_value.__dict__)
    except AttributeError:
      pass

def _assert_valid_deep(value):
  """Assert value's validity, recursively traversing lists and dicts."""
  if isinstance(value, dict):
    for k in value:
      _assert_valid_deep(value[k])
  elif isinstance(value, list):
    for v in value:
      _assert_valid_deep(v)
# Ensure that the passed in value isn't a type, which could have an
# assert_valid attribute, but it can not be called without an instance.
  elif type(value) != type:
    try:
      fn = value.assert_valid
    except AttributeError:
      pass
    else:
      fn()



  # SWIG classes generated with -classic do not define this variable,
  # so set it to 0 when it doesn't exist
try:
  _newclass
except NameError:
  _newclass = 0

if _newclass:
  def _get_instance_attr(self, name):
    try:
      return object.__getattribute__(self, name)
    except AttributeError:
      return _swig_getattr(self, object.__getattribute__(self, '__class__'),
                           name)
else:
  def _get_instance_attr(self, name):
    return _swig_getattr(self, self.__class__, name)

def _set_instance_attr(self, name, value):
  return _swig_setattr(self, self.__class__, name, value)


import libsvn.core

def svn_swig_py_make_editor(*args):
    r"""svn_swig_py_make_editor(PyObject * py_editor, apr_pool_t pool)"""
    return _delta.svn_swig_py_make_editor(*args)
SVN_DELTA_COMPRESSION_LEVEL_NONE = _delta.SVN_DELTA_COMPRESSION_LEVEL_NONE

SVN_DELTA_COMPRESSION_LEVEL_MAX = _delta.SVN_DELTA_COMPRESSION_LEVEL_MAX

SVN_DELTA_COMPRESSION_LEVEL_DEFAULT = _delta.SVN_DELTA_COMPRESSION_LEVEL_DEFAULT


def svn_delta_version():
    r"""svn_delta_version() -> svn_version_t"""
    return _delta.svn_delta_version()
svn_txdelta_source = _delta.svn_txdelta_source

svn_txdelta_target = _delta.svn_txdelta_target

svn_txdelta_new = _delta.svn_txdelta_new

class svn_txdelta_op_t(object):
    r"""Proxy of C svn_txdelta_op_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    action_code = property(_delta.svn_txdelta_op_t_action_code_get, _delta.svn_txdelta_op_t_action_code_set, doc=r"""action_code : enum svn_delta_action""")
    offset = property(_delta.svn_txdelta_op_t_offset_get, _delta.svn_txdelta_op_t_offset_set, doc=r"""offset : apr_size_t""")
    length = property(_delta.svn_txdelta_op_t_length_get, _delta.svn_txdelta_op_t_length_set, doc=r"""length : apr_size_t""")
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __init__(self):
        r"""__init__(svn_txdelta_op_t self) -> svn_txdelta_op_t"""
        _delta.svn_txdelta_op_t_swiginit(self, _delta.new_svn_txdelta_op_t())
    __swig_destroy__ = _delta.delete_svn_txdelta_op_t

# Register svn_txdelta_op_t in _delta:
_delta.svn_txdelta_op_t_swigregister(svn_txdelta_op_t)
class svn_txdelta_window_t(object):
    r"""Proxy of C svn_txdelta_window_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    sview_offset = property(_delta.svn_txdelta_window_t_sview_offset_get, _delta.svn_txdelta_window_t_sview_offset_set, doc=r"""sview_offset : svn_filesize_t""")
    sview_len = property(_delta.svn_txdelta_window_t_sview_len_get, _delta.svn_txdelta_window_t_sview_len_set, doc=r"""sview_len : apr_size_t""")
    tview_len = property(_delta.svn_txdelta_window_t_tview_len_get, _delta.svn_txdelta_window_t_tview_len_set, doc=r"""tview_len : apr_size_t""")
    num_ops = property(_delta.svn_txdelta_window_t_num_ops_get, _delta.svn_txdelta_window_t_num_ops_set, doc=r"""num_ops : int""")
    src_ops = property(_delta.svn_txdelta_window_t_src_ops_get, _delta.svn_txdelta_window_t_src_ops_set, doc=r"""src_ops : int""")
    new_data = property(_delta.svn_txdelta_window_t_new_data_get, doc=r"""new_data : p.q(const).svn_string_t""")

    def _ops_get(self):
        r"""_ops_get(svn_txdelta_window_t self)"""
        return _delta.svn_txdelta_window_t__ops_get(self)

    ops = property(_ops_get)

    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __init__(self):
        r"""__init__(svn_txdelta_window_t self) -> svn_txdelta_window_t"""
        _delta.svn_txdelta_window_t_swiginit(self, _delta.new_svn_txdelta_window_t())
    __swig_destroy__ = _delta.delete_svn_txdelta_window_t

# Register svn_txdelta_window_t in _delta:
_delta.svn_txdelta_window_t_swigregister(svn_txdelta_window_t)

def svn_txdelta_window_dup(*args):
    r"""svn_txdelta_window_dup(svn_txdelta_window_t window, apr_pool_t pool) -> svn_txdelta_window_t"""
    return _delta.svn_txdelta_window_dup(*args)

def svn_txdelta_compose_windows(*args):
    r"""svn_txdelta_compose_windows(svn_txdelta_window_t window_A, svn_txdelta_window_t window_B, apr_pool_t pool) -> svn_txdelta_window_t"""
    return _delta.svn_txdelta_compose_windows(*args)

def svn_txdelta_apply_instructions(window, sbuf, tbuf):
    r"""svn_txdelta_apply_instructions(svn_txdelta_window_t window, char const * sbuf, char * tbuf)"""
    return _delta.svn_txdelta_apply_instructions(window, sbuf, tbuf)

def svn_txdelta_run(*args):
    r"""svn_txdelta_run(svn_stream_t source, svn_stream_t target, svn_txdelta_window_handler_t handler, void * handler_baton, svn_checksum_kind_t checksum_kind, svn_cancel_func_t cancel_func, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _delta.svn_txdelta_run(*args)

def svn_txdelta_stream_create(*args):
    r"""svn_txdelta_stream_create(void * baton, svn_txdelta_next_window_fn_t next_window, svn_txdelta_md5_digest_fn_t md5_digest, apr_pool_t pool) -> svn_txdelta_stream_t"""
    return _delta.svn_txdelta_stream_create(*args)

def svn_txdelta_next_window(*args):
    r"""svn_txdelta_next_window(svn_txdelta_stream_t stream, apr_pool_t pool) -> svn_error_t"""
    return _delta.svn_txdelta_next_window(*args)

def svn_txdelta_md5_digest(stream):
    r"""svn_txdelta_md5_digest(svn_txdelta_stream_t stream) -> unsigned char const *"""
    return _delta.svn_txdelta_md5_digest(stream)

def svn_txdelta2(*args):
    r"""svn_txdelta2(svn_stream_t source, svn_stream_t target, svn_boolean_t calculate_checksum, apr_pool_t pool)"""
    return _delta.svn_txdelta2(*args)

def svn_txdelta(*args):
    r"""svn_txdelta(svn_stream_t source, svn_stream_t target, apr_pool_t pool)"""
    return _delta.svn_txdelta(*args)

def svn_txdelta_target_push(*args):
    r"""svn_txdelta_target_push(svn_txdelta_window_handler_t handler, void * handler_baton, svn_stream_t source, apr_pool_t pool) -> svn_stream_t"""
    return _delta.svn_txdelta_target_push(*args)

def svn_txdelta_send_string(*args):
    r"""svn_txdelta_send_string(svn_string_t const * string, svn_txdelta_window_handler_t handler, void * handler_baton, apr_pool_t pool) -> svn_error_t"""
    return _delta.svn_txdelta_send_string(*args)

def svn_txdelta_send_stream(*args):
    r"""svn_txdelta_send_stream(svn_stream_t stream, svn_txdelta_window_handler_t handler, void * handler_baton, apr_pool_t pool) -> svn_error_t"""
    return _delta.svn_txdelta_send_stream(*args)

def svn_txdelta_send_txstream(*args):
    r"""svn_txdelta_send_txstream(svn_txdelta_stream_t txstream, svn_txdelta_window_handler_t handler, void * handler_baton, apr_pool_t pool) -> svn_error_t"""
    return _delta.svn_txdelta_send_txstream(*args)

def svn_txdelta_send_contents(*args):
    r"""svn_txdelta_send_contents(unsigned char const * contents, apr_size_t len, svn_txdelta_window_handler_t handler, void * handler_baton, apr_pool_t pool) -> svn_error_t"""
    return _delta.svn_txdelta_send_contents(*args)

def svn_txdelta_apply(*args):
    r"""svn_txdelta_apply(svn_stream_t source, svn_stream_t target, char const * error_info, apr_pool_t pool)"""
    return _delta.svn_txdelta_apply(*args)

def svn_txdelta_to_svndiff3(*args):
    r"""svn_txdelta_to_svndiff3(svn_stream_t output, int svndiff_version, int compression_level, apr_pool_t pool)"""
    return _delta.svn_txdelta_to_svndiff3(*args)

def svn_txdelta_to_svndiff2(*args):
    r"""svn_txdelta_to_svndiff2(svn_stream_t output, int svndiff_version, apr_pool_t pool)"""
    return _delta.svn_txdelta_to_svndiff2(*args)

def svn_txdelta_to_svndiff(*args):
    r"""svn_txdelta_to_svndiff(svn_stream_t output, apr_pool_t pool)"""
    return _delta.svn_txdelta_to_svndiff(*args)

def svn_txdelta_to_svndiff_stream(*args):
    r"""svn_txdelta_to_svndiff_stream(svn_txdelta_stream_t txstream, int svndiff_version, int compression_level, apr_pool_t pool) -> svn_stream_t"""
    return _delta.svn_txdelta_to_svndiff_stream(*args)

def svn_txdelta_parse_svndiff(*args):
    r"""svn_txdelta_parse_svndiff(svn_txdelta_window_handler_t handler, void * handler_baton, svn_boolean_t error_on_early_close, apr_pool_t pool) -> svn_stream_t"""
    return _delta.svn_txdelta_parse_svndiff(*args)

def svn_txdelta_read_svndiff_window(*args):
    r"""svn_txdelta_read_svndiff_window(svn_stream_t stream, int svndiff_version, apr_pool_t pool) -> svn_error_t"""
    return _delta.svn_txdelta_read_svndiff_window(*args)

def svn_txdelta_skip_svndiff_window(*args):
    r"""svn_txdelta_skip_svndiff_window(apr_file_t file, int svndiff_version, apr_pool_t pool) -> svn_error_t"""
    return _delta.svn_txdelta_skip_svndiff_window(*args)
class svn_delta_editor_t(object):
    r"""Proxy of C svn_delta_editor_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    set_target_revision = property(_delta.svn_delta_editor_t_set_target_revision_get, _delta.svn_delta_editor_t_set_target_revision_set, doc=r"""set_target_revision : p.f(p.void,svn_revnum_t,p.apr_pool_t).p.svn_error_t""")
    open_root = property(_delta.svn_delta_editor_t_open_root_get, _delta.svn_delta_editor_t_open_root_set, doc=r"""open_root : p.f(p.void,svn_revnum_t,p.apr_pool_t,p.p.void).p.svn_error_t""")
    delete_entry = property(_delta.svn_delta_editor_t_delete_entry_get, _delta.svn_delta_editor_t_delete_entry_set, doc=r"""delete_entry : p.f(p.q(const).char,svn_revnum_t,p.void,p.apr_pool_t).p.svn_error_t""")
    add_directory = property(_delta.svn_delta_editor_t_add_directory_get, _delta.svn_delta_editor_t_add_directory_set, doc=r"""add_directory : p.f(p.q(const).char,p.void,p.q(const).char,svn_revnum_t,p.apr_pool_t,p.p.void).p.svn_error_t""")
    open_directory = property(_delta.svn_delta_editor_t_open_directory_get, _delta.svn_delta_editor_t_open_directory_set, doc=r"""open_directory : p.f(p.q(const).char,p.void,svn_revnum_t,p.apr_pool_t,p.p.void).p.svn_error_t""")
    change_dir_prop = property(_delta.svn_delta_editor_t_change_dir_prop_get, _delta.svn_delta_editor_t_change_dir_prop_set, doc=r"""change_dir_prop : p.f(p.void,p.q(const).char,p.q(const).svn_string_t,p.apr_pool_t).p.svn_error_t""")
    close_directory = property(_delta.svn_delta_editor_t_close_directory_get, _delta.svn_delta_editor_t_close_directory_set, doc=r"""close_directory : p.f(p.void,p.apr_pool_t).p.svn_error_t""")
    absent_directory = property(_delta.svn_delta_editor_t_absent_directory_get, _delta.svn_delta_editor_t_absent_directory_set, doc=r"""absent_directory : p.f(p.q(const).char,p.void,p.apr_pool_t).p.svn_error_t""")
    add_file = property(_delta.svn_delta_editor_t_add_file_get, _delta.svn_delta_editor_t_add_file_set, doc=r"""add_file : p.f(p.q(const).char,p.void,p.q(const).char,svn_revnum_t,p.apr_pool_t,p.p.void).p.svn_error_t""")
    open_file = property(_delta.svn_delta_editor_t_open_file_get, _delta.svn_delta_editor_t_open_file_set, doc=r"""open_file : p.f(p.q(const).char,p.void,svn_revnum_t,p.apr_pool_t,p.p.void).p.svn_error_t""")
    apply_textdelta = property(_delta.svn_delta_editor_t_apply_textdelta_get, _delta.svn_delta_editor_t_apply_textdelta_set, doc=r"""apply_textdelta : p.f(p.void,p.q(const).char,p.apr_pool_t,p.svn_txdelta_window_handler_t,p.p.void).p.svn_error_t""")
    change_file_prop = property(_delta.svn_delta_editor_t_change_file_prop_get, _delta.svn_delta_editor_t_change_file_prop_set, doc=r"""change_file_prop : p.f(p.void,p.q(const).char,p.q(const).svn_string_t,p.apr_pool_t).p.svn_error_t""")
    close_file = property(_delta.svn_delta_editor_t_close_file_get, _delta.svn_delta_editor_t_close_file_set, doc=r"""close_file : p.f(p.void,p.q(const).char,p.apr_pool_t).p.svn_error_t""")
    absent_file = property(_delta.svn_delta_editor_t_absent_file_get, _delta.svn_delta_editor_t_absent_file_set, doc=r"""absent_file : p.f(p.q(const).char,p.void,p.apr_pool_t).p.svn_error_t""")
    close_edit = property(_delta.svn_delta_editor_t_close_edit_get, _delta.svn_delta_editor_t_close_edit_set, doc=r"""close_edit : p.f(p.void,p.apr_pool_t).p.svn_error_t""")
    abort_edit = property(_delta.svn_delta_editor_t_abort_edit_get, _delta.svn_delta_editor_t_abort_edit_set, doc=r"""abort_edit : p.f(p.void,p.apr_pool_t).p.svn_error_t""")
    apply_textdelta_stream = property(_delta.svn_delta_editor_t_apply_textdelta_stream_get, _delta.svn_delta_editor_t_apply_textdelta_stream_set, doc=r"""apply_textdelta_stream : p.f(p.q(const).struct svn_delta_editor_t,p.void,p.q(const).char,svn_txdelta_stream_open_func_t,p.void,p.apr_pool_t).p.svn_error_t""")
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def set_target_revision(self, *args):
      return svn_delta_editor_invoke_set_target_revision(self, *args)


    def open_root(self, *args):
      return svn_delta_editor_invoke_open_root(self, *args)


    def delete_entry(self, *args):
      return svn_delta_editor_invoke_delete_entry(self, *args)


    def add_directory(self, *args):
      return svn_delta_editor_invoke_add_directory(self, *args)


    def open_directory(self, *args):
      return svn_delta_editor_invoke_open_directory(self, *args)


    def change_dir_prop(self, *args):
      return svn_delta_editor_invoke_change_dir_prop(self, *args)


    def close_directory(self, *args):
      return svn_delta_editor_invoke_close_directory(self, *args)


    def absent_directory(self, *args):
      return svn_delta_editor_invoke_absent_directory(self, *args)


    def add_file(self, *args):
      return svn_delta_editor_invoke_add_file(self, *args)


    def open_file(self, *args):
      return svn_delta_editor_invoke_open_file(self, *args)


    def apply_textdelta(self, *args):
      return svn_delta_editor_invoke_apply_textdelta(self, *args)


    def change_file_prop(self, *args):
      return svn_delta_editor_invoke_change_file_prop(self, *args)


    def close_file(self, *args):
      return svn_delta_editor_invoke_close_file(self, *args)


    def absent_file(self, *args):
      return svn_delta_editor_invoke_absent_file(self, *args)


    def close_edit(self, *args):
      return svn_delta_editor_invoke_close_edit(self, *args)


    def abort_edit(self, *args):
      return svn_delta_editor_invoke_abort_edit(self, *args)


    def apply_textdelta_stream(self, *args):
      return svn_delta_editor_invoke_apply_textdelta_stream(self, *args)


    def __init__(self):
        r"""__init__(svn_delta_editor_t self) -> svn_delta_editor_t"""
        _delta.svn_delta_editor_t_swiginit(self, _delta.new_svn_delta_editor_t())
    __swig_destroy__ = _delta.delete_svn_delta_editor_t

# Register svn_delta_editor_t in _delta:
_delta.svn_delta_editor_t_swigregister(svn_delta_editor_t)

def svn_delta_default_editor(*args):
    r"""svn_delta_default_editor(apr_pool_t pool) -> svn_delta_editor_t"""
    return _delta.svn_delta_default_editor(*args)

def svn_delta_noop_window_handler(window, baton):
    r"""svn_delta_noop_window_handler(svn_txdelta_window_t window, void * baton) -> svn_error_t"""
    return _delta.svn_delta_noop_window_handler(window, baton)

def svn_delta_get_cancellation_editor(*args):
    r"""svn_delta_get_cancellation_editor(svn_cancel_func_t cancel_func, svn_delta_editor_t wrapped_editor, void * wrapped_baton, apr_pool_t pool) -> svn_error_t"""
    return _delta.svn_delta_get_cancellation_editor(*args)

def svn_delta_depth_filter_editor(*args):
    r"""svn_delta_depth_filter_editor(svn_delta_editor_t wrapped_editor, void * wrapped_edit_baton, svn_depth_t requested_depth, svn_boolean_t has_target, apr_pool_t pool) -> svn_error_t"""
    return _delta.svn_delta_depth_filter_editor(*args)

def svn_delta_path_driver3(*args):
    r"""svn_delta_path_driver3(svn_delta_editor_t editor, void * edit_baton, apr_array_header_t relpaths, svn_boolean_t sort_paths, svn_delta_path_driver_cb_func2_t callback_func, void * callback_baton, apr_pool_t pool) -> svn_error_t"""
    return _delta.svn_delta_path_driver3(*args)

def svn_delta_path_driver2(*args):
    r"""svn_delta_path_driver2(svn_delta_editor_t editor, void * edit_baton, apr_array_header_t paths, svn_boolean_t sort_paths, svn_delta_path_driver_cb_func_t callback_func, apr_pool_t scratch_pool) -> svn_error_t"""
    return _delta.svn_delta_path_driver2(*args)

def svn_delta_path_driver(*args):
    r"""svn_delta_path_driver(svn_delta_editor_t editor, void * edit_baton, svn_revnum_t revision, apr_array_header_t paths, svn_delta_path_driver_cb_func_t callback_func, apr_pool_t scratch_pool) -> svn_error_t"""
    return _delta.svn_delta_path_driver(*args)

def svn_delta_path_driver_start(*args):
    r"""svn_delta_path_driver_start(svn_delta_editor_t editor, void * edit_baton, svn_delta_path_driver_cb_func2_t callback_func, void * callback_baton, apr_pool_t result_pool) -> svn_error_t"""
    return _delta.svn_delta_path_driver_start(*args)

def svn_delta_path_driver_step(*args):
    r"""svn_delta_path_driver_step(svn_delta_path_driver_state_t state, char const * relpath, apr_pool_t scratch_pool) -> svn_error_t"""
    return _delta.svn_delta_path_driver_step(*args)

def svn_delta_path_driver_finish(*args):
    r"""svn_delta_path_driver_finish(svn_delta_path_driver_state_t state, apr_pool_t scratch_pool) -> svn_error_t"""
    return _delta.svn_delta_path_driver_finish(*args)

def svn_compat_wrap_file_rev_handler(*args):
    r"""svn_compat_wrap_file_rev_handler(svn_file_rev_handler_old_t handler, void * handler_baton, apr_pool_t pool)"""
    return _delta.svn_compat_wrap_file_rev_handler(*args)
class svn_txdelta_stream_t(object):
    r"""Proxy of C svn_txdelta_stream_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


# Register svn_txdelta_stream_t in _delta:
_delta.svn_txdelta_stream_t_swigregister(svn_txdelta_stream_t)
class svn_delta_path_driver_state_t(object):
    r"""Proxy of C svn_delta_path_driver_state_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


# Register svn_delta_path_driver_state_t in _delta:
_delta.svn_delta_path_driver_state_t_swigregister(svn_delta_path_driver_state_t)

def svn_delta_editor_invoke_set_target_revision(*args):
    r"""svn_delta_editor_invoke_set_target_revision(svn_delta_editor_t _obj, void * edit_baton, svn_revnum_t target_revision, apr_pool_t scratch_pool) -> svn_error_t"""
    return _delta.svn_delta_editor_invoke_set_target_revision(*args)

def svn_delta_editor_invoke_open_root(*args):
    r"""svn_delta_editor_invoke_open_root(svn_delta_editor_t _obj, void * edit_baton, svn_revnum_t base_revision, apr_pool_t result_pool) -> svn_error_t"""
    return _delta.svn_delta_editor_invoke_open_root(*args)

def svn_delta_editor_invoke_delete_entry(*args):
    r"""svn_delta_editor_invoke_delete_entry(svn_delta_editor_t _obj, char const * path, svn_revnum_t revision, void * parent_baton, apr_pool_t scratch_pool) -> svn_error_t"""
    return _delta.svn_delta_editor_invoke_delete_entry(*args)

def svn_delta_editor_invoke_add_directory(*args):
    r"""svn_delta_editor_invoke_add_directory(svn_delta_editor_t _obj, char const * path, void * parent_baton, char const * copyfrom_path, svn_revnum_t copyfrom_revision, apr_pool_t result_pool) -> svn_error_t"""
    return _delta.svn_delta_editor_invoke_add_directory(*args)

def svn_delta_editor_invoke_open_directory(*args):
    r"""svn_delta_editor_invoke_open_directory(svn_delta_editor_t _obj, char const * path, void * parent_baton, svn_revnum_t base_revision, apr_pool_t result_pool) -> svn_error_t"""
    return _delta.svn_delta_editor_invoke_open_directory(*args)

def svn_delta_editor_invoke_change_dir_prop(*args):
    r"""svn_delta_editor_invoke_change_dir_prop(svn_delta_editor_t _obj, void * dir_baton, char const * name, svn_string_t const * value, apr_pool_t scratch_pool) -> svn_error_t"""
    return _delta.svn_delta_editor_invoke_change_dir_prop(*args)

def svn_delta_editor_invoke_close_directory(*args):
    r"""svn_delta_editor_invoke_close_directory(svn_delta_editor_t _obj, void * dir_baton, apr_pool_t scratch_pool) -> svn_error_t"""
    return _delta.svn_delta_editor_invoke_close_directory(*args)

def svn_delta_editor_invoke_absent_directory(*args):
    r"""svn_delta_editor_invoke_absent_directory(svn_delta_editor_t _obj, char const * path, void * parent_baton, apr_pool_t scratch_pool) -> svn_error_t"""
    return _delta.svn_delta_editor_invoke_absent_directory(*args)

def svn_delta_editor_invoke_add_file(*args):
    r"""svn_delta_editor_invoke_add_file(svn_delta_editor_t _obj, char const * path, void * parent_baton, char const * copyfrom_path, svn_revnum_t copyfrom_revision, apr_pool_t result_pool) -> svn_error_t"""
    return _delta.svn_delta_editor_invoke_add_file(*args)

def svn_delta_editor_invoke_open_file(*args):
    r"""svn_delta_editor_invoke_open_file(svn_delta_editor_t _obj, char const * path, void * parent_baton, svn_revnum_t base_revision, apr_pool_t result_pool) -> svn_error_t"""
    return _delta.svn_delta_editor_invoke_open_file(*args)

def svn_delta_editor_invoke_apply_textdelta(*args):
    r"""svn_delta_editor_invoke_apply_textdelta(svn_delta_editor_t _obj, void * file_baton, char const * base_checksum, apr_pool_t result_pool) -> svn_error_t"""
    return _delta.svn_delta_editor_invoke_apply_textdelta(*args)

def svn_delta_editor_invoke_change_file_prop(*args):
    r"""svn_delta_editor_invoke_change_file_prop(svn_delta_editor_t _obj, void * file_baton, char const * name, svn_string_t const * value, apr_pool_t scratch_pool) -> svn_error_t"""
    return _delta.svn_delta_editor_invoke_change_file_prop(*args)

def svn_delta_editor_invoke_close_file(*args):
    r"""svn_delta_editor_invoke_close_file(svn_delta_editor_t _obj, void * file_baton, char const * text_checksum, apr_pool_t scratch_pool) -> svn_error_t"""
    return _delta.svn_delta_editor_invoke_close_file(*args)

def svn_delta_editor_invoke_absent_file(*args):
    r"""svn_delta_editor_invoke_absent_file(svn_delta_editor_t _obj, char const * path, void * parent_baton, apr_pool_t scratch_pool) -> svn_error_t"""
    return _delta.svn_delta_editor_invoke_absent_file(*args)

def svn_delta_editor_invoke_close_edit(*args):
    r"""svn_delta_editor_invoke_close_edit(svn_delta_editor_t _obj, void * edit_baton, apr_pool_t scratch_pool) -> svn_error_t"""
    return _delta.svn_delta_editor_invoke_close_edit(*args)

def svn_delta_editor_invoke_abort_edit(*args):
    r"""svn_delta_editor_invoke_abort_edit(svn_delta_editor_t _obj, void * edit_baton, apr_pool_t scratch_pool) -> svn_error_t"""
    return _delta.svn_delta_editor_invoke_abort_edit(*args)

def svn_delta_editor_invoke_apply_textdelta_stream(*args):
    r"""svn_delta_editor_invoke_apply_textdelta_stream(svn_delta_editor_t _obj, svn_delta_editor_t editor, void * file_baton, char const * base_checksum, svn_txdelta_stream_open_func_t open_func, void * open_baton, apr_pool_t scratch_pool) -> svn_error_t"""
    return _delta.svn_delta_editor_invoke_apply_textdelta_stream(*args)

def svn_txdelta_invoke_window_handler(_obj, window, baton):
    r"""svn_txdelta_invoke_window_handler(svn_txdelta_window_handler_t _obj, svn_txdelta_window_t window, void * baton) -> svn_error_t"""
    return _delta.svn_txdelta_invoke_window_handler(_obj, window, baton)

def svn_txdelta_invoke_next_window_fn(*args):
    r"""svn_txdelta_invoke_next_window_fn(svn_txdelta_next_window_fn_t _obj, void * baton, apr_pool_t pool) -> svn_error_t"""
    return _delta.svn_txdelta_invoke_next_window_fn(*args)

def svn_txdelta_invoke_md5_digest_fn(_obj, baton):
    r"""svn_txdelta_invoke_md5_digest_fn(svn_txdelta_md5_digest_fn_t _obj, void * baton) -> unsigned char const *"""
    return _delta.svn_txdelta_invoke_md5_digest_fn(_obj, baton)

def svn_txdelta_invoke_stream_open_func(*args):
    r"""svn_txdelta_invoke_stream_open_func(svn_txdelta_stream_open_func_t _obj, void * baton, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _delta.svn_txdelta_invoke_stream_open_func(*args)

def svn_delta_invoke_path_driver_cb_func2(*args):
    r"""svn_delta_invoke_path_driver_cb_func2(svn_delta_path_driver_cb_func2_t _obj, svn_delta_editor_t editor, void * edit_baton, void * parent_baton, void * callback_baton, char const * relpath, apr_pool_t pool) -> svn_error_t"""
    return _delta.svn_delta_invoke_path_driver_cb_func2(*args)

def svn_delta_invoke_path_driver_cb_func(*args):
    r"""svn_delta_invoke_path_driver_cb_func(svn_delta_path_driver_cb_func_t _obj, void * parent_baton, void * callback_baton, char const * path, apr_pool_t pool) -> svn_error_t"""
    return _delta.svn_delta_invoke_path_driver_cb_func(*args)

def svn_file_invoke_rev_handler(*args):
    r"""svn_file_invoke_rev_handler(svn_file_rev_handler_t _obj, void * baton, char const * path, svn_revnum_t rev, apr_hash_t rev_props, svn_boolean_t result_of_merge, apr_array_header_t prop_diffs, apr_pool_t pool) -> svn_error_t"""
    return _delta.svn_file_invoke_rev_handler(*args)

def svn_file_invoke_rev_handler_old(*args):
    r"""svn_file_invoke_rev_handler_old(svn_file_rev_handler_old_t _obj, void * baton, char const * path, svn_revnum_t rev, apr_hash_t rev_props, apr_array_header_t prop_diffs, apr_pool_t pool) -> svn_error_t"""
    return _delta.svn_file_invoke_rev_handler_old(*args)
class svn_txdelta_window_handler_t(object):
    r"""Proxy of C svn_txdelta_window_handler_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_txdelta_invoke_window_handler(self, *args)


# Register svn_txdelta_window_handler_t in _delta:
_delta.svn_txdelta_window_handler_t_swigregister(svn_txdelta_window_handler_t)
class svn_txdelta_next_window_fn_t(object):
    r"""Proxy of C svn_txdelta_next_window_fn_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_txdelta_invoke_next_window_fn(self, *args)


# Register svn_txdelta_next_window_fn_t in _delta:
_delta.svn_txdelta_next_window_fn_t_swigregister(svn_txdelta_next_window_fn_t)
class svn_txdelta_md5_digest_fn_t(object):
    r"""Proxy of C svn_txdelta_md5_digest_fn_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_txdelta_invoke_md5_digest_fn(self, *args)


# Register svn_txdelta_md5_digest_fn_t in _delta:
_delta.svn_txdelta_md5_digest_fn_t_swigregister(svn_txdelta_md5_digest_fn_t)
class svn_txdelta_stream_open_func_t(object):
    r"""Proxy of C svn_txdelta_stream_open_func_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_txdelta_invoke_stream_open_func(self, *args)


# Register svn_txdelta_stream_open_func_t in _delta:
_delta.svn_txdelta_stream_open_func_t_swigregister(svn_txdelta_stream_open_func_t)
class svn_delta_path_driver_cb_func2_t(object):
    r"""Proxy of C svn_delta_path_driver_cb_func2_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_delta_invoke_path_driver_cb_func2(self, *args)


# Register svn_delta_path_driver_cb_func2_t in _delta:
_delta.svn_delta_path_driver_cb_func2_t_swigregister(svn_delta_path_driver_cb_func2_t)
class svn_delta_path_driver_cb_func_t(object):
    r"""Proxy of C svn_delta_path_driver_cb_func_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_delta_invoke_path_driver_cb_func(self, *args)


# Register svn_delta_path_driver_cb_func_t in _delta:
_delta.svn_delta_path_driver_cb_func_t_swigregister(svn_delta_path_driver_cb_func_t)
class svn_file_rev_handler_t(object):
    r"""Proxy of C svn_file_rev_handler_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_file_invoke_rev_handler(self, *args)


# Register svn_file_rev_handler_t in _delta:
_delta.svn_file_rev_handler_t_swigregister(svn_file_rev_handler_t)
class svn_file_rev_handler_old_t(object):
    r"""Proxy of C svn_file_rev_handler_old_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_file_invoke_rev_handler_old(self, *args)


# Register svn_file_rev_handler_old_t in _delta:
_delta.svn_file_rev_handler_old_t_swigregister(svn_file_rev_handler_old_t)

svn_txdelta_window_t_ops_get = svn_txdelta_window_t._ops_get



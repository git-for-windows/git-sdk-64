# This file was automatically generated by SWIG (https://www.swig.org).
# Version 4.1.1
#
# Do not make changes to this file unless you know what you are doing - modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info

def _dll_paths():
    import os
    if hasattr(os, 'add_dll_directory'):  # Python 3.8+ on Windows
        cookies = []
        for path in os.environ.get('PATH', '').split(os.pathsep):
            if path and os.path.isabs(path):
                try:
                    cookie = os.add_dll_directory(path)
                except OSError:
                    continue
                else:
                    cookies.append(cookie)
        return cookies
    else:
        return ()

_dll_paths = _dll_paths()
try:
    from . import _diff
finally:
    _dll_path = None
    for _dll_path in _dll_paths:
        _dll_path.close()
    del _dll_paths, _dll_path


try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "this":
            set(self, name, value)
        elif name == "thisown":
            self.this.own(value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)



def _copy_metadata_deep(value, old_value):
  """Copy all attributes of old_value into value, recursively traversing
  lists and dicts if needed."""
  if value is None or old_value is None or value is old_value: return

  if isinstance(value, dict):
    for k in value:
      _copy_metadata_deep(value[k], old_value[k])
  elif isinstance(value, list):
    for v, old_v in zip(value, old_value):
      _copy_metadata_deep(v, old_v)
  else:
    try:
      value.__dict__.update(old_value.__dict__)
    except AttributeError:
      pass

def _assert_valid_deep(value):
  """Assert value's validity, recursively traversing lists and dicts."""
  if isinstance(value, dict):
    for k in value:
      _assert_valid_deep(value[k])
  elif isinstance(value, list):
    for v in value:
      _assert_valid_deep(v)
# Ensure that the passed in value isn't a type, which could have an
# assert_valid attribute, but it can not be called without an instance.
  elif type(value) != type:
    try:
      fn = value.assert_valid
    except AttributeError:
      pass
    else:
      fn()



  # SWIG classes generated with -classic do not define this variable,
  # so set it to 0 when it doesn't exist
try:
  _newclass
except NameError:
  _newclass = 0

if _newclass:
  def _get_instance_attr(self, name):
    try:
      return object.__getattribute__(self, name)
    except AttributeError:
      return _swig_getattr(self, object.__getattribute__(self, '__class__'),
                           name)
else:
  def _get_instance_attr(self, name):
    return _swig_getattr(self, self.__class__, name)

def _set_instance_attr(self, name, value):
  return _swig_setattr(self, self.__class__, name, value)


import libsvn.core

def svn_diff_version():
    r"""svn_diff_version() -> svn_version_t"""
    return _diff.svn_diff_version()
svn_diff_datasource_original = _diff.svn_diff_datasource_original

svn_diff_datasource_modified = _diff.svn_diff_datasource_modified

svn_diff_datasource_latest = _diff.svn_diff_datasource_latest

svn_diff_datasource_ancestor = _diff.svn_diff_datasource_ancestor

class svn_diff_fns2_t(object):
    r"""Proxy of C svn_diff_fns2_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    datasources_open = property(_diff.svn_diff_fns2_t_datasources_open_get, _diff.svn_diff_fns2_t_datasources_open_set, doc=r"""datasources_open : p.f(p.void,p.apr_off_t,p.apr_off_t,p.q(const).svn_diff_datasource_e,apr_size_t).p.svn_error_t""")
    datasource_close = property(_diff.svn_diff_fns2_t_datasource_close_get, _diff.svn_diff_fns2_t_datasource_close_set, doc=r"""datasource_close : p.f(p.void,svn_diff_datasource_e).p.svn_error_t""")
    datasource_get_next_token = property(_diff.svn_diff_fns2_t_datasource_get_next_token_get, _diff.svn_diff_fns2_t_datasource_get_next_token_set, doc=r"""datasource_get_next_token : p.f(p.apr_uint32_t,p.p.void,p.void,svn_diff_datasource_e).p.svn_error_t""")
    token_compare = property(_diff.svn_diff_fns2_t_token_compare_get, _diff.svn_diff_fns2_t_token_compare_set, doc=r"""token_compare : p.f(p.void,p.void,p.void,p.int).p.svn_error_t""")
    token_discard = property(_diff.svn_diff_fns2_t_token_discard_get, _diff.svn_diff_fns2_t_token_discard_set, doc=r"""token_discard : p.f(p.void,p.void).void""")
    token_discard_all = property(_diff.svn_diff_fns2_t_token_discard_all_get, _diff.svn_diff_fns2_t_token_discard_all_set, doc=r"""token_discard_all : p.f(p.void).void""")
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def datasources_open(self, *args):
      return svn_diff_fns2_invoke_datasources_open(self, *args)


    def datasource_close(self, *args):
      return svn_diff_fns2_invoke_datasource_close(self, *args)


    def datasource_get_next_token(self, *args):
      return svn_diff_fns2_invoke_datasource_get_next_token(self, *args)


    def token_compare(self, *args):
      return svn_diff_fns2_invoke_token_compare(self, *args)


    def token_discard(self, *args):
      return svn_diff_fns2_invoke_token_discard(self, *args)


    def token_discard_all(self, *args):
      return svn_diff_fns2_invoke_token_discard_all(self, *args)


    def __init__(self):
        r"""__init__(svn_diff_fns2_t self) -> svn_diff_fns2_t"""
        _diff.svn_diff_fns2_t_swiginit(self, _diff.new_svn_diff_fns2_t())
    __swig_destroy__ = _diff.delete_svn_diff_fns2_t

# Register svn_diff_fns2_t in _diff:
_diff.svn_diff_fns2_t_swigregister(svn_diff_fns2_t)
class svn_diff_fns_t(object):
    r"""Proxy of C svn_diff_fns_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    datasource_open = property(_diff.svn_diff_fns_t_datasource_open_get, _diff.svn_diff_fns_t_datasource_open_set, doc=r"""datasource_open : p.f(p.void,svn_diff_datasource_e).p.svn_error_t""")
    datasource_close = property(_diff.svn_diff_fns_t_datasource_close_get, _diff.svn_diff_fns_t_datasource_close_set, doc=r"""datasource_close : p.f(p.void,svn_diff_datasource_e).p.svn_error_t""")
    datasource_get_next_token = property(_diff.svn_diff_fns_t_datasource_get_next_token_get, _diff.svn_diff_fns_t_datasource_get_next_token_set, doc=r"""datasource_get_next_token : p.f(p.apr_uint32_t,p.p.void,p.void,svn_diff_datasource_e).p.svn_error_t""")
    token_compare = property(_diff.svn_diff_fns_t_token_compare_get, _diff.svn_diff_fns_t_token_compare_set, doc=r"""token_compare : p.f(p.void,p.void,p.void,p.int).p.svn_error_t""")
    token_discard = property(_diff.svn_diff_fns_t_token_discard_get, _diff.svn_diff_fns_t_token_discard_set, doc=r"""token_discard : p.f(p.void,p.void).void""")
    token_discard_all = property(_diff.svn_diff_fns_t_token_discard_all_get, _diff.svn_diff_fns_t_token_discard_all_set, doc=r"""token_discard_all : p.f(p.void).void""")
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def datasource_open(self, *args):
      return svn_diff_fns_invoke_datasource_open(self, *args)


    def datasource_close(self, *args):
      return svn_diff_fns_invoke_datasource_close(self, *args)


    def datasource_get_next_token(self, *args):
      return svn_diff_fns_invoke_datasource_get_next_token(self, *args)


    def token_compare(self, *args):
      return svn_diff_fns_invoke_token_compare(self, *args)


    def token_discard(self, *args):
      return svn_diff_fns_invoke_token_discard(self, *args)


    def token_discard_all(self, *args):
      return svn_diff_fns_invoke_token_discard_all(self, *args)


    def __init__(self):
        r"""__init__(svn_diff_fns_t self) -> svn_diff_fns_t"""
        _diff.svn_diff_fns_t_swiginit(self, _diff.new_svn_diff_fns_t())
    __swig_destroy__ = _diff.delete_svn_diff_fns_t

# Register svn_diff_fns_t in _diff:
_diff.svn_diff_fns_t_swigregister(svn_diff_fns_t)

def svn_diff_diff_2(*args):
    r"""svn_diff_diff_2(void * diff_baton, svn_diff_fns2_t diff_fns, apr_pool_t pool) -> svn_error_t"""
    return _diff.svn_diff_diff_2(*args)

def svn_diff_diff(*args):
    r"""svn_diff_diff(void * diff_baton, svn_diff_fns_t diff_fns, apr_pool_t pool) -> svn_error_t"""
    return _diff.svn_diff_diff(*args)

def svn_diff_diff3_2(*args):
    r"""svn_diff_diff3_2(void * diff_baton, svn_diff_fns2_t diff_fns, apr_pool_t pool) -> svn_error_t"""
    return _diff.svn_diff_diff3_2(*args)

def svn_diff_diff3(*args):
    r"""svn_diff_diff3(void * diff_baton, svn_diff_fns_t diff_fns, apr_pool_t pool) -> svn_error_t"""
    return _diff.svn_diff_diff3(*args)

def svn_diff_diff4_2(*args):
    r"""svn_diff_diff4_2(void * diff_baton, svn_diff_fns2_t diff_fns, apr_pool_t pool) -> svn_error_t"""
    return _diff.svn_diff_diff4_2(*args)

def svn_diff_diff4(*args):
    r"""svn_diff_diff4(void * diff_baton, svn_diff_fns_t diff_fns, apr_pool_t pool) -> svn_error_t"""
    return _diff.svn_diff_diff4(*args)

def svn_diff_contains_conflicts(diff):
    r"""svn_diff_contains_conflicts(svn_diff_t diff) -> svn_boolean_t"""
    return _diff.svn_diff_contains_conflicts(diff)

def svn_diff_contains_diffs(diff):
    r"""svn_diff_contains_diffs(svn_diff_t diff) -> svn_boolean_t"""
    return _diff.svn_diff_contains_diffs(diff)
class svn_diff_output_fns_t(object):
    r"""Proxy of C svn_diff_output_fns_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    output_common = property(_diff.svn_diff_output_fns_t_output_common_get, _diff.svn_diff_output_fns_t_output_common_set, doc=r"""output_common : p.f(p.void,apr_off_t,apr_off_t,apr_off_t,apr_off_t,apr_off_t,apr_off_t).p.svn_error_t""")
    output_diff_modified = property(_diff.svn_diff_output_fns_t_output_diff_modified_get, _diff.svn_diff_output_fns_t_output_diff_modified_set, doc=r"""output_diff_modified : p.f(p.void,apr_off_t,apr_off_t,apr_off_t,apr_off_t,apr_off_t,apr_off_t).p.svn_error_t""")
    output_diff_latest = property(_diff.svn_diff_output_fns_t_output_diff_latest_get, _diff.svn_diff_output_fns_t_output_diff_latest_set, doc=r"""output_diff_latest : p.f(p.void,apr_off_t,apr_off_t,apr_off_t,apr_off_t,apr_off_t,apr_off_t).p.svn_error_t""")
    output_diff_common = property(_diff.svn_diff_output_fns_t_output_diff_common_get, _diff.svn_diff_output_fns_t_output_diff_common_set, doc=r"""output_diff_common : p.f(p.void,apr_off_t,apr_off_t,apr_off_t,apr_off_t,apr_off_t,apr_off_t).p.svn_error_t""")
    output_conflict = property(_diff.svn_diff_output_fns_t_output_conflict_get, _diff.svn_diff_output_fns_t_output_conflict_set, doc=r"""output_conflict : p.f(p.void,apr_off_t,apr_off_t,apr_off_t,apr_off_t,apr_off_t,apr_off_t,p.svn_diff_t).p.svn_error_t""")
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def output_common(self, *args):
      return svn_diff_output_fns_invoke_output_common(self, *args)


    def output_diff_modified(self, *args):
      return svn_diff_output_fns_invoke_output_diff_modified(self, *args)


    def output_diff_latest(self, *args):
      return svn_diff_output_fns_invoke_output_diff_latest(self, *args)


    def output_diff_common(self, *args):
      return svn_diff_output_fns_invoke_output_diff_common(self, *args)


    def output_conflict(self, *args):
      return svn_diff_output_fns_invoke_output_conflict(self, *args)


    def __init__(self):
        r"""__init__(svn_diff_output_fns_t self) -> svn_diff_output_fns_t"""
        _diff.svn_diff_output_fns_t_swiginit(self, _diff.new_svn_diff_output_fns_t())
    __swig_destroy__ = _diff.delete_svn_diff_output_fns_t

# Register svn_diff_output_fns_t in _diff:
_diff.svn_diff_output_fns_t_swigregister(svn_diff_output_fns_t)
svn_diff_conflict_display_modified_latest = _diff.svn_diff_conflict_display_modified_latest

svn_diff_conflict_display_resolved_modified_latest = _diff.svn_diff_conflict_display_resolved_modified_latest

svn_diff_conflict_display_modified_original_latest = _diff.svn_diff_conflict_display_modified_original_latest

svn_diff_conflict_display_modified = _diff.svn_diff_conflict_display_modified

svn_diff_conflict_display_latest = _diff.svn_diff_conflict_display_latest

svn_diff_conflict_display_only_conflicts = _diff.svn_diff_conflict_display_only_conflicts


def svn_diff_output2(diff, output_baton, output_fns, cancel_func):
    r"""svn_diff_output2(svn_diff_t diff, void * output_baton, svn_diff_output_fns_t output_fns, svn_cancel_func_t cancel_func) -> svn_error_t"""
    return _diff.svn_diff_output2(diff, output_baton, output_fns, cancel_func)

def svn_diff_output(diff, output_baton, output_fns):
    r"""svn_diff_output(svn_diff_t diff, void * output_baton, svn_diff_output_fns_t output_fns) -> svn_error_t"""
    return _diff.svn_diff_output(diff, output_baton, output_fns)
svn_diff_file_ignore_space_none = _diff.svn_diff_file_ignore_space_none

svn_diff_file_ignore_space_change = _diff.svn_diff_file_ignore_space_change

svn_diff_file_ignore_space_all = _diff.svn_diff_file_ignore_space_all

class svn_diff_file_options_t(object):
    r"""Proxy of C svn_diff_file_options_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    ignore_space = property(_diff.svn_diff_file_options_t_ignore_space_get, _diff.svn_diff_file_options_t_ignore_space_set, doc=r"""ignore_space : svn_diff_file_ignore_space_t""")
    ignore_eol_style = property(_diff.svn_diff_file_options_t_ignore_eol_style_get, _diff.svn_diff_file_options_t_ignore_eol_style_set, doc=r"""ignore_eol_style : svn_boolean_t""")
    show_c_function = property(_diff.svn_diff_file_options_t_show_c_function_get, _diff.svn_diff_file_options_t_show_c_function_set, doc=r"""show_c_function : svn_boolean_t""")
    context_size = property(_diff.svn_diff_file_options_t_context_size_get, _diff.svn_diff_file_options_t_context_size_set, doc=r"""context_size : int""")
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __init__(self):
        r"""__init__(svn_diff_file_options_t self) -> svn_diff_file_options_t"""
        _diff.svn_diff_file_options_t_swiginit(self, _diff.new_svn_diff_file_options_t())
    __swig_destroy__ = _diff.delete_svn_diff_file_options_t

# Register svn_diff_file_options_t in _diff:
_diff.svn_diff_file_options_t_swigregister(svn_diff_file_options_t)

def svn_diff_file_options_create(*args):
    r"""svn_diff_file_options_create(apr_pool_t pool) -> svn_diff_file_options_t"""
    return _diff.svn_diff_file_options_create(*args)

def svn_diff_file_options_parse(*args):
    r"""svn_diff_file_options_parse(svn_diff_file_options_t options, apr_array_header_t args, apr_pool_t pool) -> svn_error_t"""
    return _diff.svn_diff_file_options_parse(*args)

def svn_diff_file_diff_2(*args):
    r"""svn_diff_file_diff_2(char const * original, char const * modified, svn_diff_file_options_t options, apr_pool_t pool) -> svn_error_t"""
    return _diff.svn_diff_file_diff_2(*args)

def svn_diff_file_diff(*args):
    r"""svn_diff_file_diff(char const * original, char const * modified, apr_pool_t pool) -> svn_error_t"""
    return _diff.svn_diff_file_diff(*args)

def svn_diff_file_diff3_2(*args):
    r"""svn_diff_file_diff3_2(char const * original, char const * modified, char const * latest, svn_diff_file_options_t options, apr_pool_t pool) -> svn_error_t"""
    return _diff.svn_diff_file_diff3_2(*args)

def svn_diff_file_diff3(*args):
    r"""svn_diff_file_diff3(char const * original, char const * modified, char const * latest, apr_pool_t pool) -> svn_error_t"""
    return _diff.svn_diff_file_diff3(*args)

def svn_diff_file_diff4_2(*args):
    r"""svn_diff_file_diff4_2(char const * original, char const * modified, char const * latest, char const * ancestor, svn_diff_file_options_t options, apr_pool_t pool) -> svn_error_t"""
    return _diff.svn_diff_file_diff4_2(*args)

def svn_diff_file_diff4(*args):
    r"""svn_diff_file_diff4(char const * original, char const * modified, char const * latest, char const * ancestor, apr_pool_t pool) -> svn_error_t"""
    return _diff.svn_diff_file_diff4(*args)

def svn_diff_file_output_unified4(*args):
    r"""svn_diff_file_output_unified4(svn_stream_t output_stream, svn_diff_t diff, char const * original_path, char const * modified_path, char const * original_header, char const * modified_header, char const * header_encoding, char const * relative_to_dir, svn_boolean_t show_c_function, int context_size, svn_cancel_func_t cancel_func, apr_pool_t scratch_pool) -> svn_error_t"""
    return _diff.svn_diff_file_output_unified4(*args)

def svn_diff_file_output_unified3(*args):
    r"""svn_diff_file_output_unified3(svn_stream_t output_stream, svn_diff_t diff, char const * original_path, char const * modified_path, char const * original_header, char const * modified_header, char const * header_encoding, char const * relative_to_dir, svn_boolean_t show_c_function, apr_pool_t pool) -> svn_error_t"""
    return _diff.svn_diff_file_output_unified3(*args)

def svn_diff_file_output_unified2(*args):
    r"""svn_diff_file_output_unified2(svn_stream_t output_stream, svn_diff_t diff, char const * original_path, char const * modified_path, char const * original_header, char const * modified_header, char const * header_encoding, apr_pool_t pool) -> svn_error_t"""
    return _diff.svn_diff_file_output_unified2(*args)

def svn_diff_file_output_unified(*args):
    r"""svn_diff_file_output_unified(svn_stream_t output_stream, svn_diff_t diff, char const * original_path, char const * modified_path, char const * original_header, char const * modified_header, apr_pool_t pool) -> svn_error_t"""
    return _diff.svn_diff_file_output_unified(*args)

def svn_diff_file_output_merge3(*args):
    r"""svn_diff_file_output_merge3(svn_stream_t output_stream, svn_diff_t diff, char const * original_path, char const * modified_path, char const * latest_path, char const * conflict_original, char const * conflict_modified, char const * conflict_latest, char const * conflict_separator, svn_diff_conflict_display_style_t conflict_style, svn_cancel_func_t cancel_func, apr_pool_t scratch_pool) -> svn_error_t"""
    return _diff.svn_diff_file_output_merge3(*args)

def svn_diff_file_output_merge2(*args):
    r"""svn_diff_file_output_merge2(svn_stream_t output_stream, svn_diff_t diff, char const * original_path, char const * modified_path, char const * latest_path, char const * conflict_original, char const * conflict_modified, char const * conflict_latest, char const * conflict_separator, svn_diff_conflict_display_style_t conflict_style, apr_pool_t pool) -> svn_error_t"""
    return _diff.svn_diff_file_output_merge2(*args)

def svn_diff_file_output_merge(*args):
    r"""svn_diff_file_output_merge(svn_stream_t output_stream, svn_diff_t diff, char const * original_path, char const * modified_path, char const * latest_path, char const * conflict_original, char const * conflict_modified, char const * conflict_latest, char const * conflict_separator, svn_boolean_t display_original_in_conflict, svn_boolean_t display_resolved_conflicts, apr_pool_t pool) -> svn_error_t"""
    return _diff.svn_diff_file_output_merge(*args)

def svn_diff_output_binary(*args):
    r"""svn_diff_output_binary(svn_stream_t output_stream, svn_stream_t original, svn_stream_t latest, svn_cancel_func_t cancel_func, apr_pool_t scratch_pool) -> svn_error_t"""
    return _diff.svn_diff_output_binary(*args)

def svn_diff_mem_string_diff(*args):
    r"""svn_diff_mem_string_diff(svn_string_t const * original, svn_string_t const * modified, svn_diff_file_options_t options, apr_pool_t pool) -> svn_error_t"""
    return _diff.svn_diff_mem_string_diff(*args)

def svn_diff_mem_string_diff3(*args):
    r"""svn_diff_mem_string_diff3(svn_string_t const * original, svn_string_t const * modified, svn_string_t const * latest, svn_diff_file_options_t options, apr_pool_t pool) -> svn_error_t"""
    return _diff.svn_diff_mem_string_diff3(*args)

def svn_diff_mem_string_diff4(*args):
    r"""svn_diff_mem_string_diff4(svn_string_t const * original, svn_string_t const * modified, svn_string_t const * latest, svn_string_t const * ancestor, svn_diff_file_options_t options, apr_pool_t pool) -> svn_error_t"""
    return _diff.svn_diff_mem_string_diff4(*args)

def svn_diff_mem_string_output_unified3(*args):
    r"""svn_diff_mem_string_output_unified3(svn_stream_t output_stream, svn_diff_t diff, svn_boolean_t with_diff_header, char const * hunk_delimiter, char const * original_header, char const * modified_header, char const * header_encoding, svn_string_t const * original, svn_string_t const * modified, int context_size, svn_cancel_func_t cancel_func, apr_pool_t scratch_pool) -> svn_error_t"""
    return _diff.svn_diff_mem_string_output_unified3(*args)

def svn_diff_mem_string_output_unified2(*args):
    r"""svn_diff_mem_string_output_unified2(svn_stream_t output_stream, svn_diff_t diff, svn_boolean_t with_diff_header, char const * hunk_delimiter, char const * original_header, char const * modified_header, char const * header_encoding, svn_string_t const * original, svn_string_t const * modified, apr_pool_t pool) -> svn_error_t"""
    return _diff.svn_diff_mem_string_output_unified2(*args)

def svn_diff_mem_string_output_unified(*args):
    r"""svn_diff_mem_string_output_unified(svn_stream_t output_stream, svn_diff_t diff, char const * original_header, char const * modified_header, char const * header_encoding, svn_string_t const * original, svn_string_t const * modified, apr_pool_t pool) -> svn_error_t"""
    return _diff.svn_diff_mem_string_output_unified(*args)

def svn_diff_mem_string_output_merge3(*args):
    r"""svn_diff_mem_string_output_merge3(svn_stream_t output_stream, svn_diff_t diff, svn_string_t const * original, svn_string_t const * modified, svn_string_t const * latest, char const * conflict_original, char const * conflict_modified, char const * conflict_latest, char const * conflict_separator, svn_diff_conflict_display_style_t style, svn_cancel_func_t cancel_func, apr_pool_t scratch_pool) -> svn_error_t"""
    return _diff.svn_diff_mem_string_output_merge3(*args)

def svn_diff_mem_string_output_merge2(*args):
    r"""svn_diff_mem_string_output_merge2(svn_stream_t output_stream, svn_diff_t diff, svn_string_t const * original, svn_string_t const * modified, svn_string_t const * latest, char const * conflict_original, char const * conflict_modified, char const * conflict_latest, char const * conflict_separator, svn_diff_conflict_display_style_t style, apr_pool_t pool) -> svn_error_t"""
    return _diff.svn_diff_mem_string_output_merge2(*args)

def svn_diff_mem_string_output_merge(*args):
    r"""svn_diff_mem_string_output_merge(svn_stream_t output_stream, svn_diff_t diff, svn_string_t const * original, svn_string_t const * modified, svn_string_t const * latest, char const * conflict_original, char const * conflict_modified, char const * conflict_latest, char const * conflict_separator, svn_boolean_t display_original_in_conflict, svn_boolean_t display_resolved_conflicts, apr_pool_t pool) -> svn_error_t"""
    return _diff.svn_diff_mem_string_output_merge(*args)
svn_diff_op_unchanged = _diff.svn_diff_op_unchanged

svn_diff_op_added = _diff.svn_diff_op_added

svn_diff_op_deleted = _diff.svn_diff_op_deleted

svn_diff_op_copied = _diff.svn_diff_op_copied

svn_diff_op_moved = _diff.svn_diff_op_moved

svn_diff_op_modified = _diff.svn_diff_op_modified


def svn_diff_hunk_readline_diff_text(*args):
    r"""svn_diff_hunk_readline_diff_text(svn_diff_hunk_t hunk, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _diff.svn_diff_hunk_readline_diff_text(*args)

def svn_diff_hunk_readline_original_text(*args):
    r"""svn_diff_hunk_readline_original_text(svn_diff_hunk_t hunk, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _diff.svn_diff_hunk_readline_original_text(*args)

def svn_diff_hunk_readline_modified_text(*args):
    r"""svn_diff_hunk_readline_modified_text(svn_diff_hunk_t hunk, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _diff.svn_diff_hunk_readline_modified_text(*args)

def svn_diff_hunk_reset_diff_text(hunk):
    r"""svn_diff_hunk_reset_diff_text(svn_diff_hunk_t hunk)"""
    return _diff.svn_diff_hunk_reset_diff_text(hunk)

def svn_diff_hunk_reset_original_text(hunk):
    r"""svn_diff_hunk_reset_original_text(svn_diff_hunk_t hunk)"""
    return _diff.svn_diff_hunk_reset_original_text(hunk)

def svn_diff_hunk_reset_modified_text(hunk):
    r"""svn_diff_hunk_reset_modified_text(svn_diff_hunk_t hunk)"""
    return _diff.svn_diff_hunk_reset_modified_text(hunk)

def svn_diff_hunk_get_original_start(hunk):
    r"""svn_diff_hunk_get_original_start(svn_diff_hunk_t hunk) -> svn_linenum_t"""
    return _diff.svn_diff_hunk_get_original_start(hunk)

def svn_diff_hunk_get_original_length(hunk):
    r"""svn_diff_hunk_get_original_length(svn_diff_hunk_t hunk) -> svn_linenum_t"""
    return _diff.svn_diff_hunk_get_original_length(hunk)

def svn_diff_hunk_get_modified_start(hunk):
    r"""svn_diff_hunk_get_modified_start(svn_diff_hunk_t hunk) -> svn_linenum_t"""
    return _diff.svn_diff_hunk_get_modified_start(hunk)

def svn_diff_hunk_get_modified_length(hunk):
    r"""svn_diff_hunk_get_modified_length(svn_diff_hunk_t hunk) -> svn_linenum_t"""
    return _diff.svn_diff_hunk_get_modified_length(hunk)

def svn_diff_hunk_get_leading_context(hunk):
    r"""svn_diff_hunk_get_leading_context(svn_diff_hunk_t hunk) -> svn_linenum_t"""
    return _diff.svn_diff_hunk_get_leading_context(hunk)

def svn_diff_hunk_get_trailing_context(hunk):
    r"""svn_diff_hunk_get_trailing_context(svn_diff_hunk_t hunk) -> svn_linenum_t"""
    return _diff.svn_diff_hunk_get_trailing_context(hunk)
class svn_prop_patch_t(object):
    r"""Proxy of C svn_prop_patch_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    name = property(_diff.svn_prop_patch_t_name_get, _diff.svn_prop_patch_t_name_set, doc=r"""name : p.q(const).char""")
    operation = property(_diff.svn_prop_patch_t_operation_get, _diff.svn_prop_patch_t_operation_set, doc=r"""operation : svn_diff_operation_kind_t""")
    hunks = property(_diff.svn_prop_patch_t_hunks_get, _diff.svn_prop_patch_t_hunks_set, doc=r"""hunks : p.apr_array_header_t""")
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __init__(self):
        r"""__init__(svn_prop_patch_t self) -> svn_prop_patch_t"""
        _diff.svn_prop_patch_t_swiginit(self, _diff.new_svn_prop_patch_t())
    __swig_destroy__ = _diff.delete_svn_prop_patch_t

# Register svn_prop_patch_t in _diff:
_diff.svn_prop_patch_t_swigregister(svn_prop_patch_t)

def svn_diff_get_binary_diff_original_stream(*args):
    r"""svn_diff_get_binary_diff_original_stream(svn_diff_binary_patch_t bpatch, apr_pool_t result_pool) -> svn_stream_t"""
    return _diff.svn_diff_get_binary_diff_original_stream(*args)

def svn_diff_get_binary_diff_result_stream(*args):
    r"""svn_diff_get_binary_diff_result_stream(svn_diff_binary_patch_t bpatch, apr_pool_t result_pool) -> svn_stream_t"""
    return _diff.svn_diff_get_binary_diff_result_stream(*args)
class svn_patch_t(object):
    r"""Proxy of C svn_patch_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    old_filename = property(_diff.svn_patch_t_old_filename_get, _diff.svn_patch_t_old_filename_set, doc=r"""old_filename : p.q(const).char""")
    new_filename = property(_diff.svn_patch_t_new_filename_get, _diff.svn_patch_t_new_filename_set, doc=r"""new_filename : p.q(const).char""")
    hunks = property(_diff.svn_patch_t_hunks_get, _diff.svn_patch_t_hunks_set, doc=r"""hunks : p.apr_array_header_t""")
    prop_patches = property(_diff.svn_patch_t_prop_patches_get, _diff.svn_patch_t_prop_patches_set, doc=r"""prop_patches : p.apr_hash_t""")
    operation = property(_diff.svn_patch_t_operation_get, _diff.svn_patch_t_operation_set, doc=r"""operation : svn_diff_operation_kind_t""")
    reverse = property(_diff.svn_patch_t_reverse_get, _diff.svn_patch_t_reverse_set, doc=r"""reverse : svn_boolean_t""")
    mergeinfo = property(_diff.svn_patch_t_mergeinfo_get, _diff.svn_patch_t_mergeinfo_set, doc=r"""mergeinfo : svn_mergeinfo_t""")
    reverse_mergeinfo = property(_diff.svn_patch_t_reverse_mergeinfo_get, _diff.svn_patch_t_reverse_mergeinfo_set, doc=r"""reverse_mergeinfo : svn_mergeinfo_t""")
    binary_patch = property(_diff.svn_patch_t_binary_patch_get, _diff.svn_patch_t_binary_patch_set, doc=r"""binary_patch : p.svn_diff_binary_patch_t""")
    old_executable_bit = property(_diff.svn_patch_t_old_executable_bit_get, _diff.svn_patch_t_old_executable_bit_set, doc=r"""old_executable_bit : svn_tristate_t""")
    new_executable_bit = property(_diff.svn_patch_t_new_executable_bit_get, _diff.svn_patch_t_new_executable_bit_set, doc=r"""new_executable_bit : svn_tristate_t""")
    old_symlink_bit = property(_diff.svn_patch_t_old_symlink_bit_get, _diff.svn_patch_t_old_symlink_bit_set, doc=r"""old_symlink_bit : svn_tristate_t""")
    new_symlink_bit = property(_diff.svn_patch_t_new_symlink_bit_get, _diff.svn_patch_t_new_symlink_bit_set, doc=r"""new_symlink_bit : svn_tristate_t""")
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __init__(self):
        r"""__init__(svn_patch_t self) -> svn_patch_t"""
        _diff.svn_patch_t_swiginit(self, _diff.new_svn_patch_t())
    __swig_destroy__ = _diff.delete_svn_patch_t

# Register svn_patch_t in _diff:
_diff.svn_patch_t_swigregister(svn_patch_t)

def svn_diff_open_patch_file(*args):
    r"""svn_diff_open_patch_file(char const * local_abspath, apr_pool_t result_pool) -> svn_error_t"""
    return _diff.svn_diff_open_patch_file(*args)

def svn_diff_parse_next_patch(*args):
    r"""svn_diff_parse_next_patch(svn_patch_file_t patch_file, svn_boolean_t reverse, svn_boolean_t ignore_whitespace, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _diff.svn_diff_parse_next_patch(*args)

def svn_diff_close_patch_file(*args):
    r"""svn_diff_close_patch_file(svn_patch_file_t patch_file, apr_pool_t scratch_pool) -> svn_error_t"""
    return _diff.svn_diff_close_patch_file(*args)
class svn_diff_t(object):
    r"""Proxy of C svn_diff_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


# Register svn_diff_t in _diff:
_diff.svn_diff_t_swigregister(svn_diff_t)
class svn_diff_hunk_t(object):
    r"""Proxy of C svn_diff_hunk_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


# Register svn_diff_hunk_t in _diff:
_diff.svn_diff_hunk_t_swigregister(svn_diff_hunk_t)
class svn_diff_binary_patch_t(object):
    r"""Proxy of C svn_diff_binary_patch_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


# Register svn_diff_binary_patch_t in _diff:
_diff.svn_diff_binary_patch_t_swigregister(svn_diff_binary_patch_t)
class svn_patch_file_t(object):
    r"""Proxy of C svn_patch_file_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


# Register svn_patch_file_t in _diff:
_diff.svn_patch_file_t_swigregister(svn_patch_file_t)

def svn_diff_fns2_invoke_datasources_open(_obj, diff_baton, prefix_lines, suffix_lines, datasources, datasources_len):
    r"""svn_diff_fns2_invoke_datasources_open(svn_diff_fns2_t _obj, void * diff_baton, apr_off_t * prefix_lines, apr_off_t * suffix_lines, svn_diff_datasource_e const * datasources, apr_size_t datasources_len) -> svn_error_t"""
    return _diff.svn_diff_fns2_invoke_datasources_open(_obj, diff_baton, prefix_lines, suffix_lines, datasources, datasources_len)

def svn_diff_fns2_invoke_datasource_close(_obj, diff_baton, datasource):
    r"""svn_diff_fns2_invoke_datasource_close(svn_diff_fns2_t _obj, void * diff_baton, svn_diff_datasource_e datasource) -> svn_error_t"""
    return _diff.svn_diff_fns2_invoke_datasource_close(_obj, diff_baton, datasource)

def svn_diff_fns2_invoke_datasource_get_next_token(_obj, diff_baton, datasource):
    r"""svn_diff_fns2_invoke_datasource_get_next_token(svn_diff_fns2_t _obj, void * diff_baton, svn_diff_datasource_e datasource) -> svn_error_t"""
    return _diff.svn_diff_fns2_invoke_datasource_get_next_token(_obj, diff_baton, datasource)

def svn_diff_fns2_invoke_token_compare(_obj, diff_baton, ltoken, rtoken):
    r"""svn_diff_fns2_invoke_token_compare(svn_diff_fns2_t _obj, void * diff_baton, void * ltoken, void * rtoken) -> svn_error_t"""
    return _diff.svn_diff_fns2_invoke_token_compare(_obj, diff_baton, ltoken, rtoken)

def svn_diff_fns2_invoke_token_discard(_obj, diff_baton, token):
    r"""svn_diff_fns2_invoke_token_discard(svn_diff_fns2_t _obj, void * diff_baton, void * token)"""
    return _diff.svn_diff_fns2_invoke_token_discard(_obj, diff_baton, token)

def svn_diff_fns2_invoke_token_discard_all(_obj, diff_baton):
    r"""svn_diff_fns2_invoke_token_discard_all(svn_diff_fns2_t _obj, void * diff_baton)"""
    return _diff.svn_diff_fns2_invoke_token_discard_all(_obj, diff_baton)

def svn_diff_fns_invoke_datasource_open(_obj, diff_baton, datasource):
    r"""svn_diff_fns_invoke_datasource_open(svn_diff_fns_t _obj, void * diff_baton, svn_diff_datasource_e datasource) -> svn_error_t"""
    return _diff.svn_diff_fns_invoke_datasource_open(_obj, diff_baton, datasource)

def svn_diff_fns_invoke_datasource_close(_obj, diff_baton, datasource):
    r"""svn_diff_fns_invoke_datasource_close(svn_diff_fns_t _obj, void * diff_baton, svn_diff_datasource_e datasource) -> svn_error_t"""
    return _diff.svn_diff_fns_invoke_datasource_close(_obj, diff_baton, datasource)

def svn_diff_fns_invoke_datasource_get_next_token(_obj, diff_baton, datasource):
    r"""svn_diff_fns_invoke_datasource_get_next_token(svn_diff_fns_t _obj, void * diff_baton, svn_diff_datasource_e datasource) -> svn_error_t"""
    return _diff.svn_diff_fns_invoke_datasource_get_next_token(_obj, diff_baton, datasource)

def svn_diff_fns_invoke_token_compare(_obj, diff_baton, ltoken, rtoken):
    r"""svn_diff_fns_invoke_token_compare(svn_diff_fns_t _obj, void * diff_baton, void * ltoken, void * rtoken) -> svn_error_t"""
    return _diff.svn_diff_fns_invoke_token_compare(_obj, diff_baton, ltoken, rtoken)

def svn_diff_fns_invoke_token_discard(_obj, diff_baton, token):
    r"""svn_diff_fns_invoke_token_discard(svn_diff_fns_t _obj, void * diff_baton, void * token)"""
    return _diff.svn_diff_fns_invoke_token_discard(_obj, diff_baton, token)

def svn_diff_fns_invoke_token_discard_all(_obj, diff_baton):
    r"""svn_diff_fns_invoke_token_discard_all(svn_diff_fns_t _obj, void * diff_baton)"""
    return _diff.svn_diff_fns_invoke_token_discard_all(_obj, diff_baton)

def svn_diff_output_fns_invoke_output_common(_obj, output_baton, original_start, original_length, modified_start, modified_length, latest_start, latest_length):
    r"""svn_diff_output_fns_invoke_output_common(svn_diff_output_fns_t _obj, void * output_baton, apr_off_t original_start, apr_off_t original_length, apr_off_t modified_start, apr_off_t modified_length, apr_off_t latest_start, apr_off_t latest_length) -> svn_error_t"""
    return _diff.svn_diff_output_fns_invoke_output_common(_obj, output_baton, original_start, original_length, modified_start, modified_length, latest_start, latest_length)

def svn_diff_output_fns_invoke_output_diff_modified(_obj, output_baton, original_start, original_length, modified_start, modified_length, latest_start, latest_length):
    r"""svn_diff_output_fns_invoke_output_diff_modified(svn_diff_output_fns_t _obj, void * output_baton, apr_off_t original_start, apr_off_t original_length, apr_off_t modified_start, apr_off_t modified_length, apr_off_t latest_start, apr_off_t latest_length) -> svn_error_t"""
    return _diff.svn_diff_output_fns_invoke_output_diff_modified(_obj, output_baton, original_start, original_length, modified_start, modified_length, latest_start, latest_length)

def svn_diff_output_fns_invoke_output_diff_latest(_obj, output_baton, original_start, original_length, modified_start, modified_length, latest_start, latest_length):
    r"""svn_diff_output_fns_invoke_output_diff_latest(svn_diff_output_fns_t _obj, void * output_baton, apr_off_t original_start, apr_off_t original_length, apr_off_t modified_start, apr_off_t modified_length, apr_off_t latest_start, apr_off_t latest_length) -> svn_error_t"""
    return _diff.svn_diff_output_fns_invoke_output_diff_latest(_obj, output_baton, original_start, original_length, modified_start, modified_length, latest_start, latest_length)

def svn_diff_output_fns_invoke_output_diff_common(_obj, output_baton, original_start, original_length, modified_start, modified_length, latest_start, latest_length):
    r"""svn_diff_output_fns_invoke_output_diff_common(svn_diff_output_fns_t _obj, void * output_baton, apr_off_t original_start, apr_off_t original_length, apr_off_t modified_start, apr_off_t modified_length, apr_off_t latest_start, apr_off_t latest_length) -> svn_error_t"""
    return _diff.svn_diff_output_fns_invoke_output_diff_common(_obj, output_baton, original_start, original_length, modified_start, modified_length, latest_start, latest_length)

def svn_diff_output_fns_invoke_output_conflict(_obj, output_baton, original_start, original_length, modified_start, modified_length, latest_start, latest_length, resolved_diff):
    r"""svn_diff_output_fns_invoke_output_conflict(svn_diff_output_fns_t _obj, void * output_baton, apr_off_t original_start, apr_off_t original_length, apr_off_t modified_start, apr_off_t modified_length, apr_off_t latest_start, apr_off_t latest_length, svn_diff_t resolved_diff) -> svn_error_t"""
    return _diff.svn_diff_output_fns_invoke_output_conflict(_obj, output_baton, original_start, original_length, modified_start, modified_length, latest_start, latest_length, resolved_diff)


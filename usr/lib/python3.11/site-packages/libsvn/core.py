# This file was automatically generated by SWIG (https://www.swig.org).
# Version 4.1.1
#
# Do not make changes to this file unless you know what you are doing - modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info

def _dll_paths():
    import os
    if hasattr(os, 'add_dll_directory'):  # Python 3.8+ on Windows
        cookies = []
        for path in os.environ.get('PATH', '').split(os.pathsep):
            if path and os.path.isabs(path):
                try:
                    cookie = os.add_dll_directory(path)
                except OSError:
                    continue
                else:
                    cookies.append(cookie)
        return cookies
    else:
        return ()

_dll_paths = _dll_paths()
try:
    from . import _core
finally:
    _dll_path = None
    for _dll_path in _dll_paths:
        _dll_path.close()
    del _dll_paths, _dll_path


try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "this":
            set(self, name, value)
        elif name == "thisown":
            self.this.own(value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)



def _copy_metadata_deep(value, old_value):
  """Copy all attributes of old_value into value, recursively traversing
  lists and dicts if needed."""
  if value is None or old_value is None or value is old_value: return

  if isinstance(value, dict):
    for k in value:
      _copy_metadata_deep(value[k], old_value[k])
  elif isinstance(value, list):
    for v, old_v in zip(value, old_value):
      _copy_metadata_deep(v, old_v)
  else:
    try:
      value.__dict__.update(old_value.__dict__)
    except AttributeError:
      pass

def _assert_valid_deep(value):
  """Assert value's validity, recursively traversing lists and dicts."""
  if isinstance(value, dict):
    for k in value:
      _assert_valid_deep(value[k])
  elif isinstance(value, list):
    for v in value:
      _assert_valid_deep(v)
# Ensure that the passed in value isn't a type, which could have an
# assert_valid attribute, but it can not be called without an instance.
  elif type(value) != type:
    try:
      fn = value.assert_valid
    except AttributeError:
      pass
    else:
      fn()



  # SWIG classes generated with -classic do not define this variable,
  # so set it to 0 when it doesn't exist
try:
  _newclass
except NameError:
  _newclass = 0

if _newclass:
  def _get_instance_attr(self, name):
    try:
      return object.__getattribute__(self, name)
    except AttributeError:
      return _swig_getattr(self, object.__getattribute__(self, '__class__'),
                           name)
else:
  def _get_instance_attr(self, name):
    return _swig_getattr(self, self.__class__, name)

def _set_instance_attr(self, name, value):
  return _swig_setattr(self, self.__class__, name, value)


SWIG_SVN_INVALID_REVNUM = _core.SWIG_SVN_INVALID_REVNUM

SWIG_SVN_IGNORED_REVNUM = _core.SWIG_SVN_IGNORED_REVNUM


def apr_initialize():
    r"""apr_initialize() -> apr_status_t"""
    return _core.apr_initialize()

def apr_terminate():
    r"""apr_terminate()"""
    return _core.apr_terminate()

def apr_time_ansi_put(input):
    r"""apr_time_ansi_put(time_t input) -> apr_status_t"""
    return _core.apr_time_ansi_put(input)

def apr_pool_destroy(*args):
    r"""apr_pool_destroy(apr_pool_t p)"""
    return _core.apr_pool_destroy(*args)

def apr_pool_clear(*args):
    r"""apr_pool_clear(apr_pool_t p)"""
    return _core.apr_pool_clear(*args)

def apr_file_open_stdout(*args):
    r"""apr_file_open_stdout(apr_pool_t pool) -> apr_status_t"""
    return _core.apr_file_open_stdout(*args)

def apr_file_open_stderr(*args):
    r"""apr_file_open_stderr(apr_pool_t pool) -> apr_status_t"""
    return _core.apr_file_open_stderr(*args)
SVN_ERR_CATEGORY_SIZE = _core.SVN_ERR_CATEGORY_SIZE

SVN_WARNING = _core.SVN_WARNING

SVN_ERR_BAD_CONTAINING_POOL = _core.SVN_ERR_BAD_CONTAINING_POOL

SVN_ERR_BAD_FILENAME = _core.SVN_ERR_BAD_FILENAME

SVN_ERR_BAD_URL = _core.SVN_ERR_BAD_URL

SVN_ERR_BAD_DATE = _core.SVN_ERR_BAD_DATE

SVN_ERR_BAD_MIME_TYPE = _core.SVN_ERR_BAD_MIME_TYPE

SVN_ERR_BAD_PROPERTY_VALUE = _core.SVN_ERR_BAD_PROPERTY_VALUE

SVN_ERR_BAD_VERSION_FILE_FORMAT = _core.SVN_ERR_BAD_VERSION_FILE_FORMAT

SVN_ERR_BAD_RELATIVE_PATH = _core.SVN_ERR_BAD_RELATIVE_PATH

SVN_ERR_BAD_UUID = _core.SVN_ERR_BAD_UUID

SVN_ERR_BAD_CONFIG_VALUE = _core.SVN_ERR_BAD_CONFIG_VALUE

SVN_ERR_BAD_SERVER_SPECIFICATION = _core.SVN_ERR_BAD_SERVER_SPECIFICATION

SVN_ERR_BAD_CHECKSUM_KIND = _core.SVN_ERR_BAD_CHECKSUM_KIND

SVN_ERR_BAD_CHECKSUM_PARSE = _core.SVN_ERR_BAD_CHECKSUM_PARSE

SVN_ERR_BAD_TOKEN = _core.SVN_ERR_BAD_TOKEN

SVN_ERR_BAD_CHANGELIST_NAME = _core.SVN_ERR_BAD_CHANGELIST_NAME

SVN_ERR_BAD_ATOMIC = _core.SVN_ERR_BAD_ATOMIC

SVN_ERR_BAD_COMPRESSION_METHOD = _core.SVN_ERR_BAD_COMPRESSION_METHOD

SVN_ERR_BAD_PROPERTY_VALUE_EOL = _core.SVN_ERR_BAD_PROPERTY_VALUE_EOL

SVN_ERR_XML_ATTRIB_NOT_FOUND = _core.SVN_ERR_XML_ATTRIB_NOT_FOUND

SVN_ERR_XML_MISSING_ANCESTRY = _core.SVN_ERR_XML_MISSING_ANCESTRY

SVN_ERR_XML_UNKNOWN_ENCODING = _core.SVN_ERR_XML_UNKNOWN_ENCODING

SVN_ERR_XML_MALFORMED = _core.SVN_ERR_XML_MALFORMED

SVN_ERR_XML_UNESCAPABLE_DATA = _core.SVN_ERR_XML_UNESCAPABLE_DATA

SVN_ERR_XML_UNEXPECTED_ELEMENT = _core.SVN_ERR_XML_UNEXPECTED_ELEMENT

SVN_ERR_IO_INCONSISTENT_EOL = _core.SVN_ERR_IO_INCONSISTENT_EOL

SVN_ERR_IO_UNKNOWN_EOL = _core.SVN_ERR_IO_UNKNOWN_EOL

SVN_ERR_IO_CORRUPT_EOL = _core.SVN_ERR_IO_CORRUPT_EOL

SVN_ERR_IO_UNIQUE_NAMES_EXHAUSTED = _core.SVN_ERR_IO_UNIQUE_NAMES_EXHAUSTED

SVN_ERR_IO_PIPE_FRAME_ERROR = _core.SVN_ERR_IO_PIPE_FRAME_ERROR

SVN_ERR_IO_PIPE_READ_ERROR = _core.SVN_ERR_IO_PIPE_READ_ERROR

SVN_ERR_IO_WRITE_ERROR = _core.SVN_ERR_IO_WRITE_ERROR

SVN_ERR_IO_PIPE_WRITE_ERROR = _core.SVN_ERR_IO_PIPE_WRITE_ERROR

SVN_ERR_STREAM_UNEXPECTED_EOF = _core.SVN_ERR_STREAM_UNEXPECTED_EOF

SVN_ERR_STREAM_MALFORMED_DATA = _core.SVN_ERR_STREAM_MALFORMED_DATA

SVN_ERR_STREAM_UNRECOGNIZED_DATA = _core.SVN_ERR_STREAM_UNRECOGNIZED_DATA

SVN_ERR_STREAM_SEEK_NOT_SUPPORTED = _core.SVN_ERR_STREAM_SEEK_NOT_SUPPORTED

SVN_ERR_STREAM_NOT_SUPPORTED = _core.SVN_ERR_STREAM_NOT_SUPPORTED

SVN_ERR_NODE_UNKNOWN_KIND = _core.SVN_ERR_NODE_UNKNOWN_KIND

SVN_ERR_NODE_UNEXPECTED_KIND = _core.SVN_ERR_NODE_UNEXPECTED_KIND

SVN_ERR_ENTRY_NOT_FOUND = _core.SVN_ERR_ENTRY_NOT_FOUND

SVN_ERR_ENTRY_EXISTS = _core.SVN_ERR_ENTRY_EXISTS

SVN_ERR_ENTRY_MISSING_REVISION = _core.SVN_ERR_ENTRY_MISSING_REVISION

SVN_ERR_ENTRY_MISSING_URL = _core.SVN_ERR_ENTRY_MISSING_URL

SVN_ERR_ENTRY_ATTRIBUTE_INVALID = _core.SVN_ERR_ENTRY_ATTRIBUTE_INVALID

SVN_ERR_ENTRY_FORBIDDEN = _core.SVN_ERR_ENTRY_FORBIDDEN

SVN_ERR_WC_OBSTRUCTED_UPDATE = _core.SVN_ERR_WC_OBSTRUCTED_UPDATE

SVN_ERR_WC_UNWIND_MISMATCH = _core.SVN_ERR_WC_UNWIND_MISMATCH

SVN_ERR_WC_UNWIND_EMPTY = _core.SVN_ERR_WC_UNWIND_EMPTY

SVN_ERR_WC_UNWIND_NOT_EMPTY = _core.SVN_ERR_WC_UNWIND_NOT_EMPTY

SVN_ERR_WC_LOCKED = _core.SVN_ERR_WC_LOCKED

SVN_ERR_WC_NOT_LOCKED = _core.SVN_ERR_WC_NOT_LOCKED

SVN_ERR_WC_INVALID_LOCK = _core.SVN_ERR_WC_INVALID_LOCK

SVN_ERR_WC_NOT_WORKING_COPY = _core.SVN_ERR_WC_NOT_WORKING_COPY

SVN_ERR_WC_NOT_DIRECTORY = _core.SVN_ERR_WC_NOT_DIRECTORY

SVN_ERR_WC_NOT_FILE = _core.SVN_ERR_WC_NOT_FILE

SVN_ERR_WC_BAD_ADM_LOG = _core.SVN_ERR_WC_BAD_ADM_LOG

SVN_ERR_WC_PATH_NOT_FOUND = _core.SVN_ERR_WC_PATH_NOT_FOUND

SVN_ERR_WC_NOT_UP_TO_DATE = _core.SVN_ERR_WC_NOT_UP_TO_DATE

SVN_ERR_WC_LEFT_LOCAL_MOD = _core.SVN_ERR_WC_LEFT_LOCAL_MOD

SVN_ERR_WC_SCHEDULE_CONFLICT = _core.SVN_ERR_WC_SCHEDULE_CONFLICT

SVN_ERR_WC_PATH_FOUND = _core.SVN_ERR_WC_PATH_FOUND

SVN_ERR_WC_FOUND_CONFLICT = _core.SVN_ERR_WC_FOUND_CONFLICT

SVN_ERR_WC_CORRUPT = _core.SVN_ERR_WC_CORRUPT

SVN_ERR_WC_CORRUPT_TEXT_BASE = _core.SVN_ERR_WC_CORRUPT_TEXT_BASE

SVN_ERR_WC_NODE_KIND_CHANGE = _core.SVN_ERR_WC_NODE_KIND_CHANGE

SVN_ERR_WC_INVALID_OP_ON_CWD = _core.SVN_ERR_WC_INVALID_OP_ON_CWD

SVN_ERR_WC_BAD_ADM_LOG_START = _core.SVN_ERR_WC_BAD_ADM_LOG_START

SVN_ERR_WC_UNSUPPORTED_FORMAT = _core.SVN_ERR_WC_UNSUPPORTED_FORMAT

SVN_ERR_WC_BAD_PATH = _core.SVN_ERR_WC_BAD_PATH

SVN_ERR_WC_INVALID_SCHEDULE = _core.SVN_ERR_WC_INVALID_SCHEDULE

SVN_ERR_WC_INVALID_RELOCATION = _core.SVN_ERR_WC_INVALID_RELOCATION

SVN_ERR_WC_INVALID_SWITCH = _core.SVN_ERR_WC_INVALID_SWITCH

SVN_ERR_WC_MISMATCHED_CHANGELIST = _core.SVN_ERR_WC_MISMATCHED_CHANGELIST

SVN_ERR_WC_CONFLICT_RESOLVER_FAILURE = _core.SVN_ERR_WC_CONFLICT_RESOLVER_FAILURE

SVN_ERR_WC_COPYFROM_PATH_NOT_FOUND = _core.SVN_ERR_WC_COPYFROM_PATH_NOT_FOUND

SVN_ERR_WC_CHANGELIST_MOVE = _core.SVN_ERR_WC_CHANGELIST_MOVE

SVN_ERR_WC_CANNOT_DELETE_FILE_EXTERNAL = _core.SVN_ERR_WC_CANNOT_DELETE_FILE_EXTERNAL

SVN_ERR_WC_CANNOT_MOVE_FILE_EXTERNAL = _core.SVN_ERR_WC_CANNOT_MOVE_FILE_EXTERNAL

SVN_ERR_WC_DB_ERROR = _core.SVN_ERR_WC_DB_ERROR

SVN_ERR_WC_MISSING = _core.SVN_ERR_WC_MISSING

SVN_ERR_WC_NOT_SYMLINK = _core.SVN_ERR_WC_NOT_SYMLINK

SVN_ERR_WC_PATH_UNEXPECTED_STATUS = _core.SVN_ERR_WC_PATH_UNEXPECTED_STATUS

SVN_ERR_WC_UPGRADE_REQUIRED = _core.SVN_ERR_WC_UPGRADE_REQUIRED

SVN_ERR_WC_CLEANUP_REQUIRED = _core.SVN_ERR_WC_CLEANUP_REQUIRED

SVN_ERR_WC_INVALID_OPERATION_DEPTH = _core.SVN_ERR_WC_INVALID_OPERATION_DEPTH

SVN_ERR_WC_PATH_ACCESS_DENIED = _core.SVN_ERR_WC_PATH_ACCESS_DENIED

SVN_ERR_WC_MIXED_REVISIONS = _core.SVN_ERR_WC_MIXED_REVISIONS

SVN_ERR_WC_DUPLICATE_EXTERNALS_TARGET = _core.SVN_ERR_WC_DUPLICATE_EXTERNALS_TARGET

SVN_ERR_FS_GENERAL = _core.SVN_ERR_FS_GENERAL

SVN_ERR_FS_CLEANUP = _core.SVN_ERR_FS_CLEANUP

SVN_ERR_FS_ALREADY_OPEN = _core.SVN_ERR_FS_ALREADY_OPEN

SVN_ERR_FS_NOT_OPEN = _core.SVN_ERR_FS_NOT_OPEN

SVN_ERR_FS_CORRUPT = _core.SVN_ERR_FS_CORRUPT

SVN_ERR_FS_PATH_SYNTAX = _core.SVN_ERR_FS_PATH_SYNTAX

SVN_ERR_FS_NO_SUCH_REVISION = _core.SVN_ERR_FS_NO_SUCH_REVISION

SVN_ERR_FS_NO_SUCH_TRANSACTION = _core.SVN_ERR_FS_NO_SUCH_TRANSACTION

SVN_ERR_FS_NO_SUCH_ENTRY = _core.SVN_ERR_FS_NO_SUCH_ENTRY

SVN_ERR_FS_NO_SUCH_REPRESENTATION = _core.SVN_ERR_FS_NO_SUCH_REPRESENTATION

SVN_ERR_FS_NO_SUCH_STRING = _core.SVN_ERR_FS_NO_SUCH_STRING

SVN_ERR_FS_NO_SUCH_COPY = _core.SVN_ERR_FS_NO_SUCH_COPY

SVN_ERR_FS_TRANSACTION_NOT_MUTABLE = _core.SVN_ERR_FS_TRANSACTION_NOT_MUTABLE

SVN_ERR_FS_NOT_FOUND = _core.SVN_ERR_FS_NOT_FOUND

SVN_ERR_FS_ID_NOT_FOUND = _core.SVN_ERR_FS_ID_NOT_FOUND

SVN_ERR_FS_NOT_ID = _core.SVN_ERR_FS_NOT_ID

SVN_ERR_FS_NOT_DIRECTORY = _core.SVN_ERR_FS_NOT_DIRECTORY

SVN_ERR_FS_NOT_FILE = _core.SVN_ERR_FS_NOT_FILE

SVN_ERR_FS_NOT_SINGLE_PATH_COMPONENT = _core.SVN_ERR_FS_NOT_SINGLE_PATH_COMPONENT

SVN_ERR_FS_NOT_MUTABLE = _core.SVN_ERR_FS_NOT_MUTABLE

SVN_ERR_FS_ALREADY_EXISTS = _core.SVN_ERR_FS_ALREADY_EXISTS

SVN_ERR_FS_ROOT_DIR = _core.SVN_ERR_FS_ROOT_DIR

SVN_ERR_FS_NOT_TXN_ROOT = _core.SVN_ERR_FS_NOT_TXN_ROOT

SVN_ERR_FS_NOT_REVISION_ROOT = _core.SVN_ERR_FS_NOT_REVISION_ROOT

SVN_ERR_FS_CONFLICT = _core.SVN_ERR_FS_CONFLICT

SVN_ERR_FS_REP_CHANGED = _core.SVN_ERR_FS_REP_CHANGED

SVN_ERR_FS_REP_NOT_MUTABLE = _core.SVN_ERR_FS_REP_NOT_MUTABLE

SVN_ERR_FS_MALFORMED_SKEL = _core.SVN_ERR_FS_MALFORMED_SKEL

SVN_ERR_FS_TXN_OUT_OF_DATE = _core.SVN_ERR_FS_TXN_OUT_OF_DATE

SVN_ERR_FS_BERKELEY_DB = _core.SVN_ERR_FS_BERKELEY_DB

SVN_ERR_FS_BERKELEY_DB_DEADLOCK = _core.SVN_ERR_FS_BERKELEY_DB_DEADLOCK

SVN_ERR_FS_TRANSACTION_DEAD = _core.SVN_ERR_FS_TRANSACTION_DEAD

SVN_ERR_FS_TRANSACTION_NOT_DEAD = _core.SVN_ERR_FS_TRANSACTION_NOT_DEAD

SVN_ERR_FS_UNKNOWN_FS_TYPE = _core.SVN_ERR_FS_UNKNOWN_FS_TYPE

SVN_ERR_FS_NO_USER = _core.SVN_ERR_FS_NO_USER

SVN_ERR_FS_PATH_ALREADY_LOCKED = _core.SVN_ERR_FS_PATH_ALREADY_LOCKED

SVN_ERR_FS_PATH_NOT_LOCKED = _core.SVN_ERR_FS_PATH_NOT_LOCKED

SVN_ERR_FS_BAD_LOCK_TOKEN = _core.SVN_ERR_FS_BAD_LOCK_TOKEN

SVN_ERR_FS_NO_LOCK_TOKEN = _core.SVN_ERR_FS_NO_LOCK_TOKEN

SVN_ERR_FS_LOCK_OWNER_MISMATCH = _core.SVN_ERR_FS_LOCK_OWNER_MISMATCH

SVN_ERR_FS_NO_SUCH_LOCK = _core.SVN_ERR_FS_NO_SUCH_LOCK

SVN_ERR_FS_LOCK_EXPIRED = _core.SVN_ERR_FS_LOCK_EXPIRED

SVN_ERR_FS_OUT_OF_DATE = _core.SVN_ERR_FS_OUT_OF_DATE

SVN_ERR_FS_UNSUPPORTED_FORMAT = _core.SVN_ERR_FS_UNSUPPORTED_FORMAT

SVN_ERR_FS_REP_BEING_WRITTEN = _core.SVN_ERR_FS_REP_BEING_WRITTEN

SVN_ERR_FS_TXN_NAME_TOO_LONG = _core.SVN_ERR_FS_TXN_NAME_TOO_LONG

SVN_ERR_FS_NO_SUCH_NODE_ORIGIN = _core.SVN_ERR_FS_NO_SUCH_NODE_ORIGIN

SVN_ERR_FS_UNSUPPORTED_UPGRADE = _core.SVN_ERR_FS_UNSUPPORTED_UPGRADE

SVN_ERR_FS_NO_SUCH_CHECKSUM_REP = _core.SVN_ERR_FS_NO_SUCH_CHECKSUM_REP

SVN_ERR_FS_PROP_BASEVALUE_MISMATCH = _core.SVN_ERR_FS_PROP_BASEVALUE_MISMATCH

SVN_ERR_FS_INCORRECT_EDITOR_COMPLETION = _core.SVN_ERR_FS_INCORRECT_EDITOR_COMPLETION

SVN_ERR_FS_PACKED_REVPROP_READ_FAILURE = _core.SVN_ERR_FS_PACKED_REVPROP_READ_FAILURE

SVN_ERR_FS_REVPROP_CACHE_INIT_FAILURE = _core.SVN_ERR_FS_REVPROP_CACHE_INIT_FAILURE

SVN_ERR_FS_MALFORMED_TXN_ID = _core.SVN_ERR_FS_MALFORMED_TXN_ID

SVN_ERR_FS_INDEX_CORRUPTION = _core.SVN_ERR_FS_INDEX_CORRUPTION

SVN_ERR_FS_INDEX_REVISION = _core.SVN_ERR_FS_INDEX_REVISION

SVN_ERR_FS_INDEX_OVERFLOW = _core.SVN_ERR_FS_INDEX_OVERFLOW

SVN_ERR_FS_CONTAINER_INDEX = _core.SVN_ERR_FS_CONTAINER_INDEX

SVN_ERR_FS_INDEX_INCONSISTENT = _core.SVN_ERR_FS_INDEX_INCONSISTENT

SVN_ERR_FS_LOCK_OPERATION_FAILED = _core.SVN_ERR_FS_LOCK_OPERATION_FAILED

SVN_ERR_FS_UNSUPPORTED_TYPE = _core.SVN_ERR_FS_UNSUPPORTED_TYPE

SVN_ERR_FS_CONTAINER_SIZE = _core.SVN_ERR_FS_CONTAINER_SIZE

SVN_ERR_FS_MALFORMED_NODEREV_ID = _core.SVN_ERR_FS_MALFORMED_NODEREV_ID

SVN_ERR_FS_INVALID_GENERATION = _core.SVN_ERR_FS_INVALID_GENERATION

SVN_ERR_FS_CORRUPT_REVPROP_MANIFEST = _core.SVN_ERR_FS_CORRUPT_REVPROP_MANIFEST

SVN_ERR_FS_CORRUPT_PROPLIST = _core.SVN_ERR_FS_CORRUPT_PROPLIST

SVN_ERR_FS_AMBIGUOUS_CHECKSUM_REP = _core.SVN_ERR_FS_AMBIGUOUS_CHECKSUM_REP

SVN_ERR_FS_UNRECOGNIZED_IOCTL_CODE = _core.SVN_ERR_FS_UNRECOGNIZED_IOCTL_CODE

SVN_ERR_FS_REP_SHARING_NOT_ALLOWED = _core.SVN_ERR_FS_REP_SHARING_NOT_ALLOWED

SVN_ERR_FS_REP_SHARING_NOT_SUPPORTED = _core.SVN_ERR_FS_REP_SHARING_NOT_SUPPORTED

SVN_ERR_REPOS_LOCKED = _core.SVN_ERR_REPOS_LOCKED

SVN_ERR_REPOS_HOOK_FAILURE = _core.SVN_ERR_REPOS_HOOK_FAILURE

SVN_ERR_REPOS_BAD_ARGS = _core.SVN_ERR_REPOS_BAD_ARGS

SVN_ERR_REPOS_NO_DATA_FOR_REPORT = _core.SVN_ERR_REPOS_NO_DATA_FOR_REPORT

SVN_ERR_REPOS_BAD_REVISION_REPORT = _core.SVN_ERR_REPOS_BAD_REVISION_REPORT

SVN_ERR_REPOS_UNSUPPORTED_VERSION = _core.SVN_ERR_REPOS_UNSUPPORTED_VERSION

SVN_ERR_REPOS_DISABLED_FEATURE = _core.SVN_ERR_REPOS_DISABLED_FEATURE

SVN_ERR_REPOS_POST_COMMIT_HOOK_FAILED = _core.SVN_ERR_REPOS_POST_COMMIT_HOOK_FAILED

SVN_ERR_REPOS_POST_LOCK_HOOK_FAILED = _core.SVN_ERR_REPOS_POST_LOCK_HOOK_FAILED

SVN_ERR_REPOS_POST_UNLOCK_HOOK_FAILED = _core.SVN_ERR_REPOS_POST_UNLOCK_HOOK_FAILED

SVN_ERR_REPOS_UNSUPPORTED_UPGRADE = _core.SVN_ERR_REPOS_UNSUPPORTED_UPGRADE

SVN_ERR_RA_ILLEGAL_URL = _core.SVN_ERR_RA_ILLEGAL_URL

SVN_ERR_RA_NOT_AUTHORIZED = _core.SVN_ERR_RA_NOT_AUTHORIZED

SVN_ERR_RA_UNKNOWN_AUTH = _core.SVN_ERR_RA_UNKNOWN_AUTH

SVN_ERR_RA_NOT_IMPLEMENTED = _core.SVN_ERR_RA_NOT_IMPLEMENTED

SVN_ERR_RA_OUT_OF_DATE = _core.SVN_ERR_RA_OUT_OF_DATE

SVN_ERR_RA_NO_REPOS_UUID = _core.SVN_ERR_RA_NO_REPOS_UUID

SVN_ERR_RA_UNSUPPORTED_ABI_VERSION = _core.SVN_ERR_RA_UNSUPPORTED_ABI_VERSION

SVN_ERR_RA_NOT_LOCKED = _core.SVN_ERR_RA_NOT_LOCKED

SVN_ERR_RA_PARTIAL_REPLAY_NOT_SUPPORTED = _core.SVN_ERR_RA_PARTIAL_REPLAY_NOT_SUPPORTED

SVN_ERR_RA_UUID_MISMATCH = _core.SVN_ERR_RA_UUID_MISMATCH

SVN_ERR_RA_REPOS_ROOT_URL_MISMATCH = _core.SVN_ERR_RA_REPOS_ROOT_URL_MISMATCH

SVN_ERR_RA_SESSION_URL_MISMATCH = _core.SVN_ERR_RA_SESSION_URL_MISMATCH

SVN_ERR_RA_CANNOT_CREATE_TUNNEL = _core.SVN_ERR_RA_CANNOT_CREATE_TUNNEL

SVN_ERR_RA_CANNOT_CREATE_SESSION = _core.SVN_ERR_RA_CANNOT_CREATE_SESSION

SVN_ERR_RA_DAV_SOCK_INIT = _core.SVN_ERR_RA_DAV_SOCK_INIT

SVN_ERR_RA_DAV_CREATING_REQUEST = _core.SVN_ERR_RA_DAV_CREATING_REQUEST

SVN_ERR_RA_DAV_REQUEST_FAILED = _core.SVN_ERR_RA_DAV_REQUEST_FAILED

SVN_ERR_RA_DAV_OPTIONS_REQ_FAILED = _core.SVN_ERR_RA_DAV_OPTIONS_REQ_FAILED

SVN_ERR_RA_DAV_PROPS_NOT_FOUND = _core.SVN_ERR_RA_DAV_PROPS_NOT_FOUND

SVN_ERR_RA_DAV_ALREADY_EXISTS = _core.SVN_ERR_RA_DAV_ALREADY_EXISTS

SVN_ERR_RA_DAV_INVALID_CONFIG_VALUE = _core.SVN_ERR_RA_DAV_INVALID_CONFIG_VALUE

SVN_ERR_RA_DAV_PATH_NOT_FOUND = _core.SVN_ERR_RA_DAV_PATH_NOT_FOUND

SVN_ERR_RA_DAV_PROPPATCH_FAILED = _core.SVN_ERR_RA_DAV_PROPPATCH_FAILED

SVN_ERR_RA_DAV_MALFORMED_DATA = _core.SVN_ERR_RA_DAV_MALFORMED_DATA

SVN_ERR_RA_DAV_RESPONSE_HEADER_BADNESS = _core.SVN_ERR_RA_DAV_RESPONSE_HEADER_BADNESS

SVN_ERR_RA_DAV_RELOCATED = _core.SVN_ERR_RA_DAV_RELOCATED

SVN_ERR_RA_DAV_CONN_TIMEOUT = _core.SVN_ERR_RA_DAV_CONN_TIMEOUT

SVN_ERR_RA_DAV_FORBIDDEN = _core.SVN_ERR_RA_DAV_FORBIDDEN

SVN_ERR_RA_DAV_PRECONDITION_FAILED = _core.SVN_ERR_RA_DAV_PRECONDITION_FAILED

SVN_ERR_RA_DAV_METHOD_NOT_ALLOWED = _core.SVN_ERR_RA_DAV_METHOD_NOT_ALLOWED

SVN_ERR_RA_LOCAL_REPOS_NOT_FOUND = _core.SVN_ERR_RA_LOCAL_REPOS_NOT_FOUND

SVN_ERR_RA_LOCAL_REPOS_OPEN_FAILED = _core.SVN_ERR_RA_LOCAL_REPOS_OPEN_FAILED

SVN_ERR_SVNDIFF_INVALID_HEADER = _core.SVN_ERR_SVNDIFF_INVALID_HEADER

SVN_ERR_SVNDIFF_CORRUPT_WINDOW = _core.SVN_ERR_SVNDIFF_CORRUPT_WINDOW

SVN_ERR_SVNDIFF_BACKWARD_VIEW = _core.SVN_ERR_SVNDIFF_BACKWARD_VIEW

SVN_ERR_SVNDIFF_INVALID_OPS = _core.SVN_ERR_SVNDIFF_INVALID_OPS

SVN_ERR_SVNDIFF_UNEXPECTED_END = _core.SVN_ERR_SVNDIFF_UNEXPECTED_END

SVN_ERR_SVNDIFF_INVALID_COMPRESSED_DATA = _core.SVN_ERR_SVNDIFF_INVALID_COMPRESSED_DATA

SVN_ERR_APMOD_MISSING_PATH_TO_FS = _core.SVN_ERR_APMOD_MISSING_PATH_TO_FS

SVN_ERR_APMOD_MALFORMED_URI = _core.SVN_ERR_APMOD_MALFORMED_URI

SVN_ERR_APMOD_ACTIVITY_NOT_FOUND = _core.SVN_ERR_APMOD_ACTIVITY_NOT_FOUND

SVN_ERR_APMOD_BAD_BASELINE = _core.SVN_ERR_APMOD_BAD_BASELINE

SVN_ERR_APMOD_CONNECTION_ABORTED = _core.SVN_ERR_APMOD_CONNECTION_ABORTED

SVN_ERR_CLIENT_VERSIONED_PATH_REQUIRED = _core.SVN_ERR_CLIENT_VERSIONED_PATH_REQUIRED

SVN_ERR_CLIENT_RA_ACCESS_REQUIRED = _core.SVN_ERR_CLIENT_RA_ACCESS_REQUIRED

SVN_ERR_CLIENT_BAD_REVISION = _core.SVN_ERR_CLIENT_BAD_REVISION

SVN_ERR_CLIENT_DUPLICATE_COMMIT_URL = _core.SVN_ERR_CLIENT_DUPLICATE_COMMIT_URL

SVN_ERR_CLIENT_IS_BINARY_FILE = _core.SVN_ERR_CLIENT_IS_BINARY_FILE

SVN_ERR_CLIENT_INVALID_EXTERNALS_DESCRIPTION = _core.SVN_ERR_CLIENT_INVALID_EXTERNALS_DESCRIPTION

SVN_ERR_CLIENT_MODIFIED = _core.SVN_ERR_CLIENT_MODIFIED

SVN_ERR_CLIENT_IS_DIRECTORY = _core.SVN_ERR_CLIENT_IS_DIRECTORY

SVN_ERR_CLIENT_REVISION_RANGE = _core.SVN_ERR_CLIENT_REVISION_RANGE

SVN_ERR_CLIENT_INVALID_RELOCATION = _core.SVN_ERR_CLIENT_INVALID_RELOCATION

SVN_ERR_CLIENT_REVISION_AUTHOR_CONTAINS_NEWLINE = _core.SVN_ERR_CLIENT_REVISION_AUTHOR_CONTAINS_NEWLINE

SVN_ERR_CLIENT_PROPERTY_NAME = _core.SVN_ERR_CLIENT_PROPERTY_NAME

SVN_ERR_CLIENT_UNRELATED_RESOURCES = _core.SVN_ERR_CLIENT_UNRELATED_RESOURCES

SVN_ERR_CLIENT_MISSING_LOCK_TOKEN = _core.SVN_ERR_CLIENT_MISSING_LOCK_TOKEN

SVN_ERR_CLIENT_MULTIPLE_SOURCES_DISALLOWED = _core.SVN_ERR_CLIENT_MULTIPLE_SOURCES_DISALLOWED

SVN_ERR_CLIENT_NO_VERSIONED_PARENT = _core.SVN_ERR_CLIENT_NO_VERSIONED_PARENT

SVN_ERR_CLIENT_NOT_READY_TO_MERGE = _core.SVN_ERR_CLIENT_NOT_READY_TO_MERGE

SVN_ERR_CLIENT_FILE_EXTERNAL_OVERWRITE_VERSIONED = _core.SVN_ERR_CLIENT_FILE_EXTERNAL_OVERWRITE_VERSIONED

SVN_ERR_CLIENT_PATCH_BAD_STRIP_COUNT = _core.SVN_ERR_CLIENT_PATCH_BAD_STRIP_COUNT

SVN_ERR_CLIENT_CYCLE_DETECTED = _core.SVN_ERR_CLIENT_CYCLE_DETECTED

SVN_ERR_CLIENT_MERGE_UPDATE_REQUIRED = _core.SVN_ERR_CLIENT_MERGE_UPDATE_REQUIRED

SVN_ERR_CLIENT_INVALID_MERGEINFO_NO_MERGETRACKING = _core.SVN_ERR_CLIENT_INVALID_MERGEINFO_NO_MERGETRACKING

SVN_ERR_CLIENT_NO_LOCK_TOKEN = _core.SVN_ERR_CLIENT_NO_LOCK_TOKEN

SVN_ERR_CLIENT_FORBIDDEN_BY_SERVER = _core.SVN_ERR_CLIENT_FORBIDDEN_BY_SERVER

SVN_ERR_CLIENT_CONFLICT_OPTION_NOT_APPLICABLE = _core.SVN_ERR_CLIENT_CONFLICT_OPTION_NOT_APPLICABLE

SVN_ERR_BASE = _core.SVN_ERR_BASE

SVN_ERR_PLUGIN_LOAD_FAILURE = _core.SVN_ERR_PLUGIN_LOAD_FAILURE

SVN_ERR_MALFORMED_FILE = _core.SVN_ERR_MALFORMED_FILE

SVN_ERR_INCOMPLETE_DATA = _core.SVN_ERR_INCOMPLETE_DATA

SVN_ERR_INCORRECT_PARAMS = _core.SVN_ERR_INCORRECT_PARAMS

SVN_ERR_UNVERSIONED_RESOURCE = _core.SVN_ERR_UNVERSIONED_RESOURCE

SVN_ERR_TEST_FAILED = _core.SVN_ERR_TEST_FAILED

SVN_ERR_UNSUPPORTED_FEATURE = _core.SVN_ERR_UNSUPPORTED_FEATURE

SVN_ERR_BAD_PROP_KIND = _core.SVN_ERR_BAD_PROP_KIND

SVN_ERR_ILLEGAL_TARGET = _core.SVN_ERR_ILLEGAL_TARGET

SVN_ERR_DELTA_MD5_CHECKSUM_ABSENT = _core.SVN_ERR_DELTA_MD5_CHECKSUM_ABSENT

SVN_ERR_DIR_NOT_EMPTY = _core.SVN_ERR_DIR_NOT_EMPTY

SVN_ERR_EXTERNAL_PROGRAM = _core.SVN_ERR_EXTERNAL_PROGRAM

SVN_ERR_SWIG_PY_EXCEPTION_SET = _core.SVN_ERR_SWIG_PY_EXCEPTION_SET

SVN_ERR_CHECKSUM_MISMATCH = _core.SVN_ERR_CHECKSUM_MISMATCH

SVN_ERR_CANCELLED = _core.SVN_ERR_CANCELLED

SVN_ERR_INVALID_DIFF_OPTION = _core.SVN_ERR_INVALID_DIFF_OPTION

SVN_ERR_PROPERTY_NOT_FOUND = _core.SVN_ERR_PROPERTY_NOT_FOUND

SVN_ERR_NO_AUTH_FILE_PATH = _core.SVN_ERR_NO_AUTH_FILE_PATH

SVN_ERR_VERSION_MISMATCH = _core.SVN_ERR_VERSION_MISMATCH

SVN_ERR_MERGEINFO_PARSE_ERROR = _core.SVN_ERR_MERGEINFO_PARSE_ERROR

SVN_ERR_CEASE_INVOCATION = _core.SVN_ERR_CEASE_INVOCATION

SVN_ERR_REVNUM_PARSE_FAILURE = _core.SVN_ERR_REVNUM_PARSE_FAILURE

SVN_ERR_ITER_BREAK = _core.SVN_ERR_ITER_BREAK

SVN_ERR_UNKNOWN_CHANGELIST = _core.SVN_ERR_UNKNOWN_CHANGELIST

SVN_ERR_RESERVED_FILENAME_SPECIFIED = _core.SVN_ERR_RESERVED_FILENAME_SPECIFIED

SVN_ERR_UNKNOWN_CAPABILITY = _core.SVN_ERR_UNKNOWN_CAPABILITY

SVN_ERR_TEST_SKIPPED = _core.SVN_ERR_TEST_SKIPPED

SVN_ERR_NO_APR_MEMCACHE = _core.SVN_ERR_NO_APR_MEMCACHE

SVN_ERR_ATOMIC_INIT_FAILURE = _core.SVN_ERR_ATOMIC_INIT_FAILURE

SVN_ERR_SQLITE_ERROR = _core.SVN_ERR_SQLITE_ERROR

SVN_ERR_SQLITE_READONLY = _core.SVN_ERR_SQLITE_READONLY

SVN_ERR_SQLITE_UNSUPPORTED_SCHEMA = _core.SVN_ERR_SQLITE_UNSUPPORTED_SCHEMA

SVN_ERR_SQLITE_BUSY = _core.SVN_ERR_SQLITE_BUSY

SVN_ERR_SQLITE_RESETTING_FOR_ROLLBACK = _core.SVN_ERR_SQLITE_RESETTING_FOR_ROLLBACK

SVN_ERR_SQLITE_CONSTRAINT = _core.SVN_ERR_SQLITE_CONSTRAINT

SVN_ERR_TOO_MANY_MEMCACHED_SERVERS = _core.SVN_ERR_TOO_MANY_MEMCACHED_SERVERS

SVN_ERR_MALFORMED_VERSION_STRING = _core.SVN_ERR_MALFORMED_VERSION_STRING

SVN_ERR_CORRUPTED_ATOMIC_STORAGE = _core.SVN_ERR_CORRUPTED_ATOMIC_STORAGE

SVN_ERR_UTF8PROC_ERROR = _core.SVN_ERR_UTF8PROC_ERROR

SVN_ERR_UTF8_GLOB = _core.SVN_ERR_UTF8_GLOB

SVN_ERR_CORRUPT_PACKED_DATA = _core.SVN_ERR_CORRUPT_PACKED_DATA

SVN_ERR_COMPOSED_ERROR = _core.SVN_ERR_COMPOSED_ERROR

SVN_ERR_INVALID_INPUT = _core.SVN_ERR_INVALID_INPUT

SVN_ERR_SQLITE_ROLLBACK_FAILED = _core.SVN_ERR_SQLITE_ROLLBACK_FAILED

SVN_ERR_LZ4_COMPRESSION_FAILED = _core.SVN_ERR_LZ4_COMPRESSION_FAILED

SVN_ERR_LZ4_DECOMPRESSION_FAILED = _core.SVN_ERR_LZ4_DECOMPRESSION_FAILED

SVN_ERR_CANONICALIZATION_FAILED = _core.SVN_ERR_CANONICALIZATION_FAILED

SVN_ERR_CL_ARG_PARSING_ERROR = _core.SVN_ERR_CL_ARG_PARSING_ERROR

SVN_ERR_CL_INSUFFICIENT_ARGS = _core.SVN_ERR_CL_INSUFFICIENT_ARGS

SVN_ERR_CL_MUTUALLY_EXCLUSIVE_ARGS = _core.SVN_ERR_CL_MUTUALLY_EXCLUSIVE_ARGS

SVN_ERR_CL_ADM_DIR_RESERVED = _core.SVN_ERR_CL_ADM_DIR_RESERVED

SVN_ERR_CL_LOG_MESSAGE_IS_VERSIONED_FILE = _core.SVN_ERR_CL_LOG_MESSAGE_IS_VERSIONED_FILE

SVN_ERR_CL_LOG_MESSAGE_IS_PATHNAME = _core.SVN_ERR_CL_LOG_MESSAGE_IS_PATHNAME

SVN_ERR_CL_COMMIT_IN_ADDED_DIR = _core.SVN_ERR_CL_COMMIT_IN_ADDED_DIR

SVN_ERR_CL_NO_EXTERNAL_EDITOR = _core.SVN_ERR_CL_NO_EXTERNAL_EDITOR

SVN_ERR_CL_BAD_LOG_MESSAGE = _core.SVN_ERR_CL_BAD_LOG_MESSAGE

SVN_ERR_CL_UNNECESSARY_LOG_MESSAGE = _core.SVN_ERR_CL_UNNECESSARY_LOG_MESSAGE

SVN_ERR_CL_NO_EXTERNAL_MERGE_TOOL = _core.SVN_ERR_CL_NO_EXTERNAL_MERGE_TOOL

SVN_ERR_CL_ERROR_PROCESSING_EXTERNALS = _core.SVN_ERR_CL_ERROR_PROCESSING_EXTERNALS

SVN_ERR_CL_REPOS_VERIFY_FAILED = _core.SVN_ERR_CL_REPOS_VERIFY_FAILED

SVN_ERR_RA_SVN_CMD_ERR = _core.SVN_ERR_RA_SVN_CMD_ERR

SVN_ERR_RA_SVN_UNKNOWN_CMD = _core.SVN_ERR_RA_SVN_UNKNOWN_CMD

SVN_ERR_RA_SVN_CONNECTION_CLOSED = _core.SVN_ERR_RA_SVN_CONNECTION_CLOSED

SVN_ERR_RA_SVN_IO_ERROR = _core.SVN_ERR_RA_SVN_IO_ERROR

SVN_ERR_RA_SVN_MALFORMED_DATA = _core.SVN_ERR_RA_SVN_MALFORMED_DATA

SVN_ERR_RA_SVN_REPOS_NOT_FOUND = _core.SVN_ERR_RA_SVN_REPOS_NOT_FOUND

SVN_ERR_RA_SVN_BAD_VERSION = _core.SVN_ERR_RA_SVN_BAD_VERSION

SVN_ERR_RA_SVN_NO_MECHANISMS = _core.SVN_ERR_RA_SVN_NO_MECHANISMS

SVN_ERR_RA_SVN_EDIT_ABORTED = _core.SVN_ERR_RA_SVN_EDIT_ABORTED

SVN_ERR_RA_SVN_REQUEST_SIZE = _core.SVN_ERR_RA_SVN_REQUEST_SIZE

SVN_ERR_RA_SVN_RESPONSE_SIZE = _core.SVN_ERR_RA_SVN_RESPONSE_SIZE

SVN_ERR_AUTHN_CREDS_UNAVAILABLE = _core.SVN_ERR_AUTHN_CREDS_UNAVAILABLE

SVN_ERR_AUTHN_NO_PROVIDER = _core.SVN_ERR_AUTHN_NO_PROVIDER

SVN_ERR_AUTHN_PROVIDERS_EXHAUSTED = _core.SVN_ERR_AUTHN_PROVIDERS_EXHAUSTED

SVN_ERR_AUTHN_CREDS_NOT_SAVED = _core.SVN_ERR_AUTHN_CREDS_NOT_SAVED

SVN_ERR_AUTHN_FAILED = _core.SVN_ERR_AUTHN_FAILED

SVN_ERR_AUTHZ_ROOT_UNREADABLE = _core.SVN_ERR_AUTHZ_ROOT_UNREADABLE

SVN_ERR_AUTHZ_UNREADABLE = _core.SVN_ERR_AUTHZ_UNREADABLE

SVN_ERR_AUTHZ_PARTIALLY_READABLE = _core.SVN_ERR_AUTHZ_PARTIALLY_READABLE

SVN_ERR_AUTHZ_INVALID_CONFIG = _core.SVN_ERR_AUTHZ_INVALID_CONFIG

SVN_ERR_AUTHZ_UNWRITABLE = _core.SVN_ERR_AUTHZ_UNWRITABLE

SVN_ERR_DIFF_DATASOURCE_MODIFIED = _core.SVN_ERR_DIFF_DATASOURCE_MODIFIED

SVN_ERR_DIFF_UNEXPECTED_DATA = _core.SVN_ERR_DIFF_UNEXPECTED_DATA

SVN_ERR_RA_SERF_SSPI_INITIALISATION_FAILED = _core.SVN_ERR_RA_SERF_SSPI_INITIALISATION_FAILED

SVN_ERR_RA_SERF_SSL_CERT_UNTRUSTED = _core.SVN_ERR_RA_SERF_SSL_CERT_UNTRUSTED

SVN_ERR_RA_SERF_GSSAPI_INITIALISATION_FAILED = _core.SVN_ERR_RA_SERF_GSSAPI_INITIALISATION_FAILED

SVN_ERR_RA_SERF_WRAPPED_ERROR = _core.SVN_ERR_RA_SERF_WRAPPED_ERROR

SVN_ERR_RA_SERF_STREAM_BUCKET_READ_ERROR = _core.SVN_ERR_RA_SERF_STREAM_BUCKET_READ_ERROR

SVN_ERR_ASSERTION_FAIL = _core.SVN_ERR_ASSERTION_FAIL

SVN_ERR_ASSERTION_ONLY_TRACING_LINKS = _core.SVN_ERR_ASSERTION_ONLY_TRACING_LINKS

SVN_ERR_ASN1_OUT_OF_DATA = _core.SVN_ERR_ASN1_OUT_OF_DATA

SVN_ERR_ASN1_UNEXPECTED_TAG = _core.SVN_ERR_ASN1_UNEXPECTED_TAG

SVN_ERR_ASN1_INVALID_LENGTH = _core.SVN_ERR_ASN1_INVALID_LENGTH

SVN_ERR_ASN1_LENGTH_MISMATCH = _core.SVN_ERR_ASN1_LENGTH_MISMATCH

SVN_ERR_ASN1_INVALID_DATA = _core.SVN_ERR_ASN1_INVALID_DATA

SVN_ERR_X509_FEATURE_UNAVAILABLE = _core.SVN_ERR_X509_FEATURE_UNAVAILABLE

SVN_ERR_X509_CERT_INVALID_PEM = _core.SVN_ERR_X509_CERT_INVALID_PEM

SVN_ERR_X509_CERT_INVALID_FORMAT = _core.SVN_ERR_X509_CERT_INVALID_FORMAT

SVN_ERR_X509_CERT_INVALID_VERSION = _core.SVN_ERR_X509_CERT_INVALID_VERSION

SVN_ERR_X509_CERT_INVALID_SERIAL = _core.SVN_ERR_X509_CERT_INVALID_SERIAL

SVN_ERR_X509_CERT_INVALID_ALG = _core.SVN_ERR_X509_CERT_INVALID_ALG

SVN_ERR_X509_CERT_INVALID_NAME = _core.SVN_ERR_X509_CERT_INVALID_NAME

SVN_ERR_X509_CERT_INVALID_DATE = _core.SVN_ERR_X509_CERT_INVALID_DATE

SVN_ERR_X509_CERT_INVALID_PUBKEY = _core.SVN_ERR_X509_CERT_INVALID_PUBKEY

SVN_ERR_X509_CERT_INVALID_SIGNATURE = _core.SVN_ERR_X509_CERT_INVALID_SIGNATURE

SVN_ERR_X509_CERT_INVALID_EXTENSIONS = _core.SVN_ERR_X509_CERT_INVALID_EXTENSIONS

SVN_ERR_X509_CERT_UNKNOWN_VERSION = _core.SVN_ERR_X509_CERT_UNKNOWN_VERSION

SVN_ERR_X509_CERT_UNKNOWN_PK_ALG = _core.SVN_ERR_X509_CERT_UNKNOWN_PK_ALG

SVN_ERR_X509_CERT_SIG_MISMATCH = _core.SVN_ERR_X509_CERT_SIG_MISMATCH

SVN_ERR_X509_CERT_VERIFY_FAILED = _core.SVN_ERR_X509_CERT_VERIFY_FAILED

SVN_ERR_LAST = _core.SVN_ERR_LAST


def svn_time_to_cstring(*args):
    r"""svn_time_to_cstring(apr_time_t when, apr_pool_t pool) -> char const *"""
    return _core.svn_time_to_cstring(*args)

def svn_time_from_cstring(*args):
    r"""svn_time_from_cstring(char const * data, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_time_from_cstring(*args)

def svn_time_to_human_cstring(*args):
    r"""svn_time_to_human_cstring(apr_time_t when, apr_pool_t pool) -> char const *"""
    return _core.svn_time_to_human_cstring(*args)

def svn_parse_date(*args):
    r"""svn_parse_date(char const * text, apr_time_t now, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_parse_date(*args)

def svn_sleep_for_timestamps():
    r"""svn_sleep_for_timestamps()"""
    return _core.svn_sleep_for_timestamps()
svn_node_none = _core.svn_node_none

svn_node_file = _core.svn_node_file

svn_node_dir = _core.svn_node_dir

svn_node_unknown = _core.svn_node_unknown

svn_node_symlink = _core.svn_node_symlink

svn_tristate_false = _core.svn_tristate_false

svn_tristate_true = _core.svn_tristate_true

svn_tristate_unknown = _core.svn_tristate_unknown

svn_depth_unknown = _core.svn_depth_unknown

svn_depth_exclude = _core.svn_depth_exclude

svn_depth_empty = _core.svn_depth_empty

svn_depth_files = _core.svn_depth_files

svn_depth_immediates = _core.svn_depth_immediates

svn_depth_infinity = _core.svn_depth_infinity

SVN_UNALIGNED_ACCESS_IS_OK = _core.SVN_UNALIGNED_ACCESS_IS_OK

TRUE = _core.TRUE

FALSE = _core.FALSE

class svn_error_t(object):
    r"""Proxy of C svn_error_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    apr_err = property(_core.svn_error_t_apr_err_get, _core.svn_error_t_apr_err_set, doc=r"""apr_err : apr_status_t""")
    message = property(_core.svn_error_t_message_get, doc=r"""message : p.q(const).char""")
    child = property(_core.svn_error_t_child_get, _core.svn_error_t_child_set, doc=r"""child : p.struct svn_error_t""")
    pool = property(_core.svn_error_t_pool_get, _core.svn_error_t_pool_set, doc=r"""pool : p.apr_pool_t""")
    file = property(_core.svn_error_t_file_get, doc=r"""file : p.q(const).char""")
    line = property(_core.svn_error_t_line_get, _core.svn_error_t_line_set, doc=r"""line : long""")
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __init__(self):
        r"""__init__(svn_error_t self) -> svn_error_t"""
        _core.svn_error_t_swiginit(self, _core.new_svn_error_t())
    __swig_destroy__ = _core.delete_svn_error_t

# Register svn_error_t in _core:
_core.svn_error_t_swigregister(svn_error_t)

def svn_node_kind_to_word(kind):
    r"""svn_node_kind_to_word(svn_node_kind_t kind) -> char const *"""
    return _core.svn_node_kind_to_word(kind)

def svn_node_kind_from_word(word):
    r"""svn_node_kind_from_word(char const * word) -> svn_node_kind_t"""
    return _core.svn_node_kind_from_word(word)

def svn_tristate__to_word(tristate):
    r"""svn_tristate__to_word(svn_tristate_t tristate) -> char const *"""
    return _core.svn_tristate__to_word(tristate)

def svn_tristate__from_word(word):
    r"""svn_tristate__from_word(char const * word) -> svn_tristate_t"""
    return _core.svn_tristate__from_word(word)

def svn_revnum_parse(str):
    r"""svn_revnum_parse(char const * str) -> svn_error_t"""
    return _core.svn_revnum_parse(str)
SVN_REVNUM_T_FMT = _core.SVN_REVNUM_T_FMT

svn_nonrecursive = _core.svn_nonrecursive

svn_recursive = _core.svn_recursive


def svn_depth_to_word(depth):
    r"""svn_depth_to_word(svn_depth_t depth) -> char const *"""
    return _core.svn_depth_to_word(depth)

def svn_depth_from_word(word):
    r"""svn_depth_from_word(char const * word) -> svn_depth_t"""
    return _core.svn_depth_from_word(word)
SVN_DIRENT_KIND = _core.SVN_DIRENT_KIND

SVN_DIRENT_SIZE = _core.SVN_DIRENT_SIZE

SVN_DIRENT_HAS_PROPS = _core.SVN_DIRENT_HAS_PROPS

SVN_DIRENT_CREATED_REV = _core.SVN_DIRENT_CREATED_REV

SVN_DIRENT_TIME = _core.SVN_DIRENT_TIME

SVN_DIRENT_LAST_AUTHOR = _core.SVN_DIRENT_LAST_AUTHOR

class svn_dirent_t(object):
    r"""Proxy of C svn_dirent_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    kind = property(_core.svn_dirent_t_kind_get, _core.svn_dirent_t_kind_set, doc=r"""kind : svn_node_kind_t""")
    size = property(_core.svn_dirent_t_size_get, _core.svn_dirent_t_size_set, doc=r"""size : svn_filesize_t""")
    has_props = property(_core.svn_dirent_t_has_props_get, _core.svn_dirent_t_has_props_set, doc=r"""has_props : svn_boolean_t""")
    created_rev = property(_core.svn_dirent_t_created_rev_get, _core.svn_dirent_t_created_rev_set, doc=r"""created_rev : svn_revnum_t""")
    time = property(_core.svn_dirent_t_time_get, _core.svn_dirent_t_time_set, doc=r"""time : apr_time_t""")
    last_author = property(_core.svn_dirent_t_last_author_get, doc=r"""last_author : p.q(const).char""")
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __init__(self):
        r"""__init__(svn_dirent_t self) -> svn_dirent_t"""
        _core.svn_dirent_t_swiginit(self, _core.new_svn_dirent_t())
    __swig_destroy__ = _core.delete_svn_dirent_t

# Register svn_dirent_t in _core:
_core.svn_dirent_t_swigregister(svn_dirent_t)

def svn_dirent_dup(*args):
    r"""svn_dirent_dup(svn_dirent_t dirent, apr_pool_t pool) -> svn_dirent_t"""
    return _core.svn_dirent_dup(*args)

def svn_dirent_create(*args):
    r"""svn_dirent_create(apr_pool_t result_pool) -> svn_dirent_t"""
    return _core.svn_dirent_create(*args)
SVN_KEYWORD_MAX_LEN = _core.SVN_KEYWORD_MAX_LEN

SVN_KEYWORD_REVISION_LONG = _core.SVN_KEYWORD_REVISION_LONG

SVN_KEYWORD_REVISION_SHORT = _core.SVN_KEYWORD_REVISION_SHORT

SVN_KEYWORD_REVISION_MEDIUM = _core.SVN_KEYWORD_REVISION_MEDIUM

SVN_KEYWORD_DATE_LONG = _core.SVN_KEYWORD_DATE_LONG

SVN_KEYWORD_DATE_SHORT = _core.SVN_KEYWORD_DATE_SHORT

SVN_KEYWORD_AUTHOR_LONG = _core.SVN_KEYWORD_AUTHOR_LONG

SVN_KEYWORD_AUTHOR_SHORT = _core.SVN_KEYWORD_AUTHOR_SHORT

SVN_KEYWORD_URL_LONG = _core.SVN_KEYWORD_URL_LONG

SVN_KEYWORD_URL_SHORT = _core.SVN_KEYWORD_URL_SHORT

SVN_KEYWORD_ID = _core.SVN_KEYWORD_ID

SVN_KEYWORD_HEADER = _core.SVN_KEYWORD_HEADER

class svn_commit_info_t(object):
    r"""Proxy of C svn_commit_info_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    revision = property(_core.svn_commit_info_t_revision_get, _core.svn_commit_info_t_revision_set, doc=r"""revision : svn_revnum_t""")
    date = property(_core.svn_commit_info_t_date_get, _core.svn_commit_info_t_date_set, doc=r"""date : p.q(const).char""")
    author = property(_core.svn_commit_info_t_author_get, _core.svn_commit_info_t_author_set, doc=r"""author : p.q(const).char""")
    post_commit_err = property(_core.svn_commit_info_t_post_commit_err_get, _core.svn_commit_info_t_post_commit_err_set, doc=r"""post_commit_err : p.q(const).char""")
    repos_root = property(_core.svn_commit_info_t_repos_root_get, _core.svn_commit_info_t_repos_root_set, doc=r"""repos_root : p.q(const).char""")
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __init__(self):
        r"""__init__(svn_commit_info_t self) -> svn_commit_info_t"""
        _core.svn_commit_info_t_swiginit(self, _core.new_svn_commit_info_t())
    __swig_destroy__ = _core.delete_svn_commit_info_t

# Register svn_commit_info_t in _core:
_core.svn_commit_info_t_swigregister(svn_commit_info_t)

def svn_create_commit_info(*args):
    r"""svn_create_commit_info(apr_pool_t pool) -> svn_commit_info_t"""
    return _core.svn_create_commit_info(*args)

def svn_commit_info_dup(*args):
    r"""svn_commit_info_dup(svn_commit_info_t src_commit_info, apr_pool_t pool) -> svn_commit_info_t"""
    return _core.svn_commit_info_dup(*args)
class svn_log_changed_path2_t(object):
    r"""Proxy of C svn_log_changed_path2_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    action = property(_core.svn_log_changed_path2_t_action_get, _core.svn_log_changed_path2_t_action_set, doc=r"""action : char""")
    copyfrom_path = property(_core.svn_log_changed_path2_t_copyfrom_path_get, _core.svn_log_changed_path2_t_copyfrom_path_set, doc=r"""copyfrom_path : p.q(const).char""")
    copyfrom_rev = property(_core.svn_log_changed_path2_t_copyfrom_rev_get, _core.svn_log_changed_path2_t_copyfrom_rev_set, doc=r"""copyfrom_rev : svn_revnum_t""")
    node_kind = property(_core.svn_log_changed_path2_t_node_kind_get, _core.svn_log_changed_path2_t_node_kind_set, doc=r"""node_kind : svn_node_kind_t""")
    text_modified = property(_core.svn_log_changed_path2_t_text_modified_get, _core.svn_log_changed_path2_t_text_modified_set, doc=r"""text_modified : svn_tristate_t""")
    props_modified = property(_core.svn_log_changed_path2_t_props_modified_get, _core.svn_log_changed_path2_t_props_modified_set, doc=r"""props_modified : svn_tristate_t""")
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __init__(self):
        r"""__init__(svn_log_changed_path2_t self) -> svn_log_changed_path2_t"""
        _core.svn_log_changed_path2_t_swiginit(self, _core.new_svn_log_changed_path2_t())
    __swig_destroy__ = _core.delete_svn_log_changed_path2_t

# Register svn_log_changed_path2_t in _core:
_core.svn_log_changed_path2_t_swigregister(svn_log_changed_path2_t)

def svn_log_changed_path2_create(*args):
    r"""svn_log_changed_path2_create(apr_pool_t pool) -> svn_log_changed_path2_t"""
    return _core.svn_log_changed_path2_create(*args)

def svn_log_changed_path2_dup(*args):
    r"""svn_log_changed_path2_dup(svn_log_changed_path2_t changed_path, apr_pool_t pool) -> svn_log_changed_path2_t"""
    return _core.svn_log_changed_path2_dup(*args)
class svn_log_changed_path_t(object):
    r"""Proxy of C svn_log_changed_path_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    action = property(_core.svn_log_changed_path_t_action_get, _core.svn_log_changed_path_t_action_set, doc=r"""action : char""")
    copyfrom_path = property(_core.svn_log_changed_path_t_copyfrom_path_get, doc=r"""copyfrom_path : p.q(const).char""")
    copyfrom_rev = property(_core.svn_log_changed_path_t_copyfrom_rev_get, _core.svn_log_changed_path_t_copyfrom_rev_set, doc=r"""copyfrom_rev : svn_revnum_t""")
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __init__(self):
        r"""__init__(svn_log_changed_path_t self) -> svn_log_changed_path_t"""
        _core.svn_log_changed_path_t_swiginit(self, _core.new_svn_log_changed_path_t())
    __swig_destroy__ = _core.delete_svn_log_changed_path_t

# Register svn_log_changed_path_t in _core:
_core.svn_log_changed_path_t_swigregister(svn_log_changed_path_t)

def svn_log_changed_path_dup(*args):
    r"""svn_log_changed_path_dup(svn_log_changed_path_t changed_path, apr_pool_t pool) -> svn_log_changed_path_t"""
    return _core.svn_log_changed_path_dup(*args)
class svn_log_entry_t(object):
    r"""Proxy of C svn_log_entry_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    changed_paths = property(_core.svn_log_entry_t_changed_paths_get, _core.svn_log_entry_t_changed_paths_set, doc=r"""changed_paths : p.apr_hash_t""")
    revision = property(_core.svn_log_entry_t_revision_get, _core.svn_log_entry_t_revision_set, doc=r"""revision : svn_revnum_t""")
    revprops = property(_core.svn_log_entry_t_revprops_get, _core.svn_log_entry_t_revprops_set, doc=r"""revprops : p.apr_hash_t""")
    has_children = property(_core.svn_log_entry_t_has_children_get, _core.svn_log_entry_t_has_children_set, doc=r"""has_children : svn_boolean_t""")
    changed_paths2 = property(_core.svn_log_entry_t_changed_paths2_get, _core.svn_log_entry_t_changed_paths2_set, doc=r"""changed_paths2 : p.apr_hash_t""")
    non_inheritable = property(_core.svn_log_entry_t_non_inheritable_get, _core.svn_log_entry_t_non_inheritable_set, doc=r"""non_inheritable : svn_boolean_t""")
    subtractive_merge = property(_core.svn_log_entry_t_subtractive_merge_get, _core.svn_log_entry_t_subtractive_merge_set, doc=r"""subtractive_merge : svn_boolean_t""")
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __init__(self):
        r"""__init__(svn_log_entry_t self) -> svn_log_entry_t"""
        _core.svn_log_entry_t_swiginit(self, _core.new_svn_log_entry_t())
    __swig_destroy__ = _core.delete_svn_log_entry_t

# Register svn_log_entry_t in _core:
_core.svn_log_entry_t_swigregister(svn_log_entry_t)

def svn_log_entry_create(*args):
    r"""svn_log_entry_create(apr_pool_t pool) -> svn_log_entry_t"""
    return _core.svn_log_entry_create(*args)

def svn_log_entry_dup(*args):
    r"""svn_log_entry_dup(svn_log_entry_t log_entry, apr_pool_t pool) -> svn_log_entry_t"""
    return _core.svn_log_entry_dup(*args)
SVN_STREAM_CHUNK_SIZE = _core.SVN_STREAM_CHUNK_SIZE

SVN__STREAM_CHUNK_SIZE = _core.SVN__STREAM_CHUNK_SIZE


def svn_mime_type_validate(*args):
    r"""svn_mime_type_validate(char const * mime_type, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_mime_type_validate(*args)

def svn_mime_type_is_binary(mime_type):
    r"""svn_mime_type_is_binary(char const * mime_type) -> svn_boolean_t"""
    return _core.svn_mime_type_is_binary(mime_type)
class svn_lock_t(object):
    r"""Proxy of C svn_lock_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    path = property(_core.svn_lock_t_path_get, _core.svn_lock_t_path_set, doc=r"""path : p.q(const).char""")
    token = property(_core.svn_lock_t_token_get, _core.svn_lock_t_token_set, doc=r"""token : p.q(const).char""")
    owner = property(_core.svn_lock_t_owner_get, _core.svn_lock_t_owner_set, doc=r"""owner : p.q(const).char""")
    comment = property(_core.svn_lock_t_comment_get, _core.svn_lock_t_comment_set, doc=r"""comment : p.q(const).char""")
    is_dav_comment = property(_core.svn_lock_t_is_dav_comment_get, _core.svn_lock_t_is_dav_comment_set, doc=r"""is_dav_comment : svn_boolean_t""")
    creation_date = property(_core.svn_lock_t_creation_date_get, _core.svn_lock_t_creation_date_set, doc=r"""creation_date : apr_time_t""")
    expiration_date = property(_core.svn_lock_t_expiration_date_get, _core.svn_lock_t_expiration_date_set, doc=r"""expiration_date : apr_time_t""")
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __init__(self):
        r"""__init__(svn_lock_t self) -> svn_lock_t"""
        _core.svn_lock_t_swiginit(self, _core.new_svn_lock_t())
    __swig_destroy__ = _core.delete_svn_lock_t

# Register svn_lock_t in _core:
_core.svn_lock_t_swigregister(svn_lock_t)

def svn_lock_create(*args):
    r"""svn_lock_create(apr_pool_t pool) -> svn_lock_t"""
    return _core.svn_lock_create(*args)

def svn_lock_dup(*args):
    r"""svn_lock_dup(svn_lock_t lock, apr_pool_t pool) -> svn_lock_t"""
    return _core.svn_lock_dup(*args)

def svn_uuid_generate(*args):
    r"""svn_uuid_generate(apr_pool_t pool) -> char const *"""
    return _core.svn_uuid_generate(*args)
class svn_merge_range_t(object):
    r"""Proxy of C svn_merge_range_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    start = property(_core.svn_merge_range_t_start_get, _core.svn_merge_range_t_start_set, doc=r"""start : svn_revnum_t""")
    end = property(_core.svn_merge_range_t_end_get, _core.svn_merge_range_t_end_set, doc=r"""end : svn_revnum_t""")
    inheritable = property(_core.svn_merge_range_t_inheritable_get, _core.svn_merge_range_t_inheritable_set, doc=r"""inheritable : svn_boolean_t""")
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __init__(self):
        r"""__init__(svn_merge_range_t self) -> svn_merge_range_t"""
        _core.svn_merge_range_t_swiginit(self, _core.new_svn_merge_range_t())
    __swig_destroy__ = _core.delete_svn_merge_range_t

# Register svn_merge_range_t in _core:
_core.svn_merge_range_t_swigregister(svn_merge_range_t)

def svn_merge_range_dup(*args):
    r"""svn_merge_range_dup(svn_merge_range_t range, apr_pool_t pool) -> svn_merge_range_t"""
    return _core.svn_merge_range_dup(*args)

def svn_merge_range_contains_rev(range, rev):
    r"""svn_merge_range_contains_rev(svn_merge_range_t range, svn_revnum_t rev) -> svn_boolean_t"""
    return _core.svn_merge_range_contains_rev(range, rev)
class svn_location_segment_t(object):
    r"""Proxy of C svn_location_segment_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    range_start = property(_core.svn_location_segment_t_range_start_get, _core.svn_location_segment_t_range_start_set, doc=r"""range_start : svn_revnum_t""")
    range_end = property(_core.svn_location_segment_t_range_end_get, _core.svn_location_segment_t_range_end_set, doc=r"""range_end : svn_revnum_t""")
    path = property(_core.svn_location_segment_t_path_get, _core.svn_location_segment_t_path_set, doc=r"""path : p.q(const).char""")
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __init__(self):
        r"""__init__(svn_location_segment_t self) -> svn_location_segment_t"""
        _core.svn_location_segment_t_swiginit(self, _core.new_svn_location_segment_t())
    __swig_destroy__ = _core.delete_svn_location_segment_t

# Register svn_location_segment_t in _core:
_core.svn_location_segment_t_swigregister(svn_location_segment_t)

def svn_location_segment_dup(*args):
    r"""svn_location_segment_dup(svn_location_segment_t segment, apr_pool_t pool) -> svn_location_segment_t"""
    return _core.svn_location_segment_dup(*args)
class svn_version_t(object):
    r"""Proxy of C svn_version_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


# Register svn_version_t in _core:
_core.svn_version_t_swigregister(svn_version_t)

def svn_log_invoke_entry_receiver(*args):
    r"""svn_log_invoke_entry_receiver(svn_log_entry_receiver_t _obj, void * baton, svn_log_entry_t log_entry, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_log_invoke_entry_receiver(*args)

def svn_log_invoke_message_receiver(*args):
    r"""svn_log_invoke_message_receiver(svn_log_message_receiver_t _obj, void * baton, apr_hash_t changed_paths, svn_revnum_t revision, char const * author, char const * date, char const * message, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_log_invoke_message_receiver(*args)

def svn_commit_invoke_callback2(*args):
    r"""svn_commit_invoke_callback2(svn_commit_callback2_t _obj, svn_commit_info_t commit_info, void * baton, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_commit_invoke_callback2(*args)

def svn_commit_invoke_callback(_obj, new_revision, date, author, baton):
    r"""svn_commit_invoke_callback(svn_commit_callback_t _obj, svn_revnum_t new_revision, char const * date, char const * author, void * baton) -> svn_error_t"""
    return _core.svn_commit_invoke_callback(_obj, new_revision, date, author, baton)

def svn_cancel_invoke_func(_obj, cancel_baton):
    r"""svn_cancel_invoke_func(svn_cancel_func_t _obj, void * cancel_baton) -> svn_error_t"""
    return _core.svn_cancel_invoke_func(_obj, cancel_baton)

def svn_location_invoke_segment_receiver(*args):
    r"""svn_location_invoke_segment_receiver(svn_location_segment_receiver_t _obj, svn_location_segment_t segment, void * baton, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_location_invoke_segment_receiver(*args)
class svn_log_entry_receiver_t(object):
    r"""Proxy of C svn_log_entry_receiver_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_log_invoke_entry_receiver(self, *args)


# Register svn_log_entry_receiver_t in _core:
_core.svn_log_entry_receiver_t_swigregister(svn_log_entry_receiver_t)
class svn_log_message_receiver_t(object):
    r"""Proxy of C svn_log_message_receiver_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_log_invoke_message_receiver(self, *args)


# Register svn_log_message_receiver_t in _core:
_core.svn_log_message_receiver_t_swigregister(svn_log_message_receiver_t)
class svn_commit_callback2_t(object):
    r"""Proxy of C svn_commit_callback2_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_commit_invoke_callback2(self, *args)


# Register svn_commit_callback2_t in _core:
_core.svn_commit_callback2_t_swigregister(svn_commit_callback2_t)
class svn_commit_callback_t(object):
    r"""Proxy of C svn_commit_callback_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_commit_invoke_callback(self, *args)


# Register svn_commit_callback_t in _core:
_core.svn_commit_callback_t_swigregister(svn_commit_callback_t)
class svn_cancel_func_t(object):
    r"""Proxy of C svn_cancel_func_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_cancel_invoke_func(self, *args)


# Register svn_cancel_func_t in _core:
_core.svn_cancel_func_t_swigregister(svn_cancel_func_t)
class svn_location_segment_receiver_t(object):
    r"""Proxy of C svn_location_segment_receiver_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_location_invoke_segment_receiver(self, *args)


# Register svn_location_segment_receiver_t in _core:
_core.svn_location_segment_receiver_t_swigregister(svn_location_segment_receiver_t)
SVN_ALLOCATOR_RECOMMENDED_MAX_FREE = _core.SVN_ALLOCATOR_RECOMMENDED_MAX_FREE


def svn_pool_create(*args):
    r"""svn_pool_create(apr_pool_t parent_pool, apr_allocator_t * allocator) -> apr_pool_t"""
    return _core.svn_pool_create(*args)

def svn_pool_create_allocator(thread_safe):
    r"""svn_pool_create_allocator(svn_boolean_t thread_safe) -> apr_allocator_t *"""
    return _core.svn_pool_create_allocator(thread_safe)
SVN_VER_MAJOR = _core.SVN_VER_MAJOR

SVN_VER_MINOR = _core.SVN_VER_MINOR

SVN_VER_PATCH = _core.SVN_VER_PATCH

SVN_VER_MICRO = _core.SVN_VER_MICRO

SVN_VER_LIBRARY = _core.SVN_VER_LIBRARY

SVN_VER_TAG = _core.SVN_VER_TAG

SVN_VER_NUMTAG = _core.SVN_VER_NUMTAG

SVN_VER_REVISION = _core.SVN_VER_REVISION

SVN_VER_NUM = _core.SVN_VER_NUM

SVN_VER_NUMBER = _core.SVN_VER_NUMBER

SVN_VERSION = _core.SVN_VERSION


def svn_ver_compatible(my_version, lib_version):
    r"""svn_ver_compatible(svn_version_t my_version, svn_version_t lib_version) -> svn_boolean_t"""
    return _core.svn_ver_compatible(my_version, lib_version)

def svn_ver_equal(my_version, lib_version):
    r"""svn_ver_equal(svn_version_t my_version, svn_version_t lib_version) -> svn_boolean_t"""
    return _core.svn_ver_equal(my_version, lib_version)
class svn_version_checklist_t(object):
    r"""Proxy of C svn_version_checklist_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    label = property(_core.svn_version_checklist_t_label_get, _core.svn_version_checklist_t_label_set, doc=r"""label : p.q(const).char""")
    version_query = property(_core.svn_version_checklist_t_version_query_get, _core.svn_version_checklist_t_version_query_set, doc=r"""version_query : p.f(void).p.q(const).svn_version_t""")
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def version_query(self, *args):
      return svn_version_checklist_invoke_version_query(self, *args)


    def __init__(self):
        r"""__init__(svn_version_checklist_t self) -> svn_version_checklist_t"""
        _core.svn_version_checklist_t_swiginit(self, _core.new_svn_version_checklist_t())
    __swig_destroy__ = _core.delete_svn_version_checklist_t

# Register svn_version_checklist_t in _core:
_core.svn_version_checklist_t_swigregister(svn_version_checklist_t)

def svn_ver_check_list2(my_version, checklist, comparator):
    r"""svn_ver_check_list2(svn_version_t my_version, svn_version_checklist_t checklist, svn_boolean_t (*)(svn_version_t const *,svn_version_t const *) comparator) -> svn_error_t"""
    return _core.svn_ver_check_list2(my_version, checklist, comparator)

def svn_ver_check_list(my_version, checklist):
    r"""svn_ver_check_list(svn_version_t my_version, svn_version_checklist_t checklist) -> svn_error_t"""
    return _core.svn_ver_check_list(my_version, checklist)

def svn_subr_version():
    r"""svn_subr_version() -> svn_version_t"""
    return _core.svn_subr_version()

def svn_version_extended(*args):
    r"""svn_version_extended(svn_boolean_t verbose, apr_pool_t pool) -> svn_version_extended_t"""
    return _core.svn_version_extended(*args)

def svn_version_ext_build_date(ext_info):
    r"""svn_version_ext_build_date(svn_version_extended_t ext_info) -> char const *"""
    return _core.svn_version_ext_build_date(ext_info)

def svn_version_ext_build_time(ext_info):
    r"""svn_version_ext_build_time(svn_version_extended_t ext_info) -> char const *"""
    return _core.svn_version_ext_build_time(ext_info)

def svn_version_ext_build_host(ext_info):
    r"""svn_version_ext_build_host(svn_version_extended_t ext_info) -> char const *"""
    return _core.svn_version_ext_build_host(ext_info)

def svn_version_ext_copyright(ext_info):
    r"""svn_version_ext_copyright(svn_version_extended_t ext_info) -> char const *"""
    return _core.svn_version_ext_copyright(ext_info)

def svn_version_ext_runtime_host(ext_info):
    r"""svn_version_ext_runtime_host(svn_version_extended_t ext_info) -> char const *"""
    return _core.svn_version_ext_runtime_host(ext_info)

def svn_version_ext_runtime_osname(ext_info):
    r"""svn_version_ext_runtime_osname(svn_version_extended_t ext_info) -> char const *"""
    return _core.svn_version_ext_runtime_osname(ext_info)
class svn_version_ext_linked_lib_t(object):
    r"""Proxy of C svn_version_ext_linked_lib_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    name = property(_core.svn_version_ext_linked_lib_t_name_get, _core.svn_version_ext_linked_lib_t_name_set, doc=r"""name : p.q(const).char""")
    compiled_version = property(_core.svn_version_ext_linked_lib_t_compiled_version_get, _core.svn_version_ext_linked_lib_t_compiled_version_set, doc=r"""compiled_version : p.q(const).char""")
    runtime_version = property(_core.svn_version_ext_linked_lib_t_runtime_version_get, _core.svn_version_ext_linked_lib_t_runtime_version_set, doc=r"""runtime_version : p.q(const).char""")
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __init__(self):
        r"""__init__(svn_version_ext_linked_lib_t self) -> svn_version_ext_linked_lib_t"""
        _core.svn_version_ext_linked_lib_t_swiginit(self, _core.new_svn_version_ext_linked_lib_t())
    __swig_destroy__ = _core.delete_svn_version_ext_linked_lib_t

# Register svn_version_ext_linked_lib_t in _core:
_core.svn_version_ext_linked_lib_t_swigregister(svn_version_ext_linked_lib_t)

def svn_version_ext_linked_libs(ext_info):
    r"""svn_version_ext_linked_libs(svn_version_extended_t ext_info) -> apr_array_header_t"""
    return _core.svn_version_ext_linked_libs(ext_info)
class svn_version_ext_loaded_lib_t(object):
    r"""Proxy of C svn_version_ext_loaded_lib_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    name = property(_core.svn_version_ext_loaded_lib_t_name_get, _core.svn_version_ext_loaded_lib_t_name_set, doc=r"""name : p.q(const).char""")
    version = property(_core.svn_version_ext_loaded_lib_t_version_get, _core.svn_version_ext_loaded_lib_t_version_set, doc=r"""version : p.q(const).char""")
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __init__(self):
        r"""__init__(svn_version_ext_loaded_lib_t self) -> svn_version_ext_loaded_lib_t"""
        _core.svn_version_ext_loaded_lib_t_swiginit(self, _core.new_svn_version_ext_loaded_lib_t())
    __swig_destroy__ = _core.delete_svn_version_ext_loaded_lib_t

# Register svn_version_ext_loaded_lib_t in _core:
_core.svn_version_ext_loaded_lib_t_swigregister(svn_version_ext_loaded_lib_t)

def svn_version_ext_loaded_libs(ext_info):
    r"""svn_version_ext_loaded_libs(svn_version_extended_t ext_info) -> apr_array_header_t"""
    return _core.svn_version_ext_loaded_libs(ext_info)
class svn_version_extended_t(object):
    r"""Proxy of C svn_version_extended_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


# Register svn_version_extended_t in _core:
_core.svn_version_extended_t_swigregister(svn_version_extended_t)

def svn_version_checklist_invoke_version_query(_obj):
    r"""svn_version_checklist_invoke_version_query(svn_version_checklist_t _obj) -> svn_version_t"""
    return _core.svn_version_checklist_invoke_version_query(_obj)

def svn_version_invoke_func(_obj):
    r"""svn_version_invoke_func(svn_version_func_t _obj) -> svn_version_t"""
    return _core.svn_version_invoke_func(_obj)
class svn_version_func_t(object):
    r"""Proxy of C svn_version_func_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_version_invoke_func(self, *args)


# Register svn_version_func_t in _core:
_core.svn_version_func_t_swigregister(svn_version_func_t)

def svn_prop_dup(*args):
    r"""svn_prop_dup(svn_prop_t const * prop, apr_pool_t pool) -> svn_prop_t *"""
    return _core.svn_prop_dup(*args)

def svn_prop_array_dup(*args):
    r"""svn_prop_array_dup(apr_array_header_t array, apr_pool_t pool) -> apr_array_header_t"""
    return _core.svn_prop_array_dup(*args)
class svn_prop_inherited_item_t(object):
    r"""Proxy of C svn_prop_inherited_item_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    path_or_url = property(_core.svn_prop_inherited_item_t_path_or_url_get, _core.svn_prop_inherited_item_t_path_or_url_set, doc=r"""path_or_url : p.q(const).char""")
    prop_hash = property(_core.svn_prop_inherited_item_t_prop_hash_get, _core.svn_prop_inherited_item_t_prop_hash_set, doc=r"""prop_hash : p.apr_hash_t""")
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __init__(self):
        r"""__init__(svn_prop_inherited_item_t self) -> svn_prop_inherited_item_t"""
        _core.svn_prop_inherited_item_t_swiginit(self, _core.new_svn_prop_inherited_item_t())
    __swig_destroy__ = _core.delete_svn_prop_inherited_item_t

# Register svn_prop_inherited_item_t in _core:
_core.svn_prop_inherited_item_t_swigregister(svn_prop_inherited_item_t)

def svn_prop_hash_to_array(*args):
    r"""svn_prop_hash_to_array(apr_hash_t hash, apr_pool_t pool) -> apr_array_header_t"""
    return _core.svn_prop_hash_to_array(*args)

def svn_prop_array_to_hash(*args):
    r"""svn_prop_array_to_hash(apr_array_header_t properties, apr_pool_t result) -> apr_hash_t"""
    return _core.svn_prop_array_to_hash(*args)

def svn_prop_hash_dup(*args):
    r"""svn_prop_hash_dup(apr_hash_t hash, apr_pool_t pool) -> apr_hash_t"""
    return _core.svn_prop_hash_dup(*args)

def svn_prop_get_value(properties, prop_name):
    r"""svn_prop_get_value(apr_hash_t properties, char const * prop_name) -> char const *"""
    return _core.svn_prop_get_value(properties, prop_name)
svn_prop_entry_kind = _core.svn_prop_entry_kind

svn_prop_wc_kind = _core.svn_prop_wc_kind

svn_prop_regular_kind = _core.svn_prop_regular_kind


def svn_property_kind2(prop_name):
    r"""svn_property_kind2(char const * prop_name) -> svn_prop_kind_t"""
    return _core.svn_property_kind2(prop_name)

def svn_property_kind(prop_name):
    r"""svn_property_kind(char const * prop_name) -> svn_prop_kind_t"""
    return _core.svn_property_kind(prop_name)

def svn_prop_is_svn_prop(prop_name):
    r"""svn_prop_is_svn_prop(char const * prop_name) -> svn_boolean_t"""
    return _core.svn_prop_is_svn_prop(prop_name)

def svn_prop_has_svn_prop(*args):
    r"""svn_prop_has_svn_prop(apr_hash_t props, apr_pool_t pool) -> svn_boolean_t"""
    return _core.svn_prop_has_svn_prop(*args)

def svn_prop_is_boolean(prop_name):
    r"""svn_prop_is_boolean(char const * prop_name) -> svn_boolean_t"""
    return _core.svn_prop_is_boolean(prop_name)

def svn_prop_is_known_svn_rev_prop(prop_name):
    r"""svn_prop_is_known_svn_rev_prop(char const * prop_name) -> svn_boolean_t"""
    return _core.svn_prop_is_known_svn_rev_prop(prop_name)

def svn_prop_is_known_svn_node_prop(prop_name):
    r"""svn_prop_is_known_svn_node_prop(char const * prop_name) -> svn_boolean_t"""
    return _core.svn_prop_is_known_svn_node_prop(prop_name)

def svn_prop_is_known_svn_file_prop(prop_name):
    r"""svn_prop_is_known_svn_file_prop(char const * prop_name) -> svn_boolean_t"""
    return _core.svn_prop_is_known_svn_file_prop(prop_name)

def svn_prop_is_known_svn_dir_prop(prop_name):
    r"""svn_prop_is_known_svn_dir_prop(char const * prop_name) -> svn_boolean_t"""
    return _core.svn_prop_is_known_svn_dir_prop(prop_name)

def svn_prop_needs_translation(prop_name):
    r"""svn_prop_needs_translation(char const * prop_name) -> svn_boolean_t"""
    return _core.svn_prop_needs_translation(prop_name)

def svn_categorize_props(*args):
    r"""svn_categorize_props(apr_array_header_t proplist, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_categorize_props(*args)

def svn_prop_diffs(*args):
    r"""svn_prop_diffs(apr_hash_t target_props, apr_hash_t source_props, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_prop_diffs(*args)

def svn_prop_name_is_valid(prop_name):
    r"""svn_prop_name_is_valid(char const * prop_name) -> svn_boolean_t"""
    return _core.svn_prop_name_is_valid(prop_name)
SVN_PROP_PREFIX = _core.SVN_PROP_PREFIX

SVN_PROP_BOOLEAN_TRUE = _core.SVN_PROP_BOOLEAN_TRUE

SVN_PROP_MIME_TYPE = _core.SVN_PROP_MIME_TYPE

SVN_PROP_IGNORE = _core.SVN_PROP_IGNORE

SVN_PROP_EOL_STYLE = _core.SVN_PROP_EOL_STYLE

SVN_PROP_KEYWORDS = _core.SVN_PROP_KEYWORDS

SVN_PROP_EXECUTABLE = _core.SVN_PROP_EXECUTABLE

SVN_PROP_EXECUTABLE_VALUE = _core.SVN_PROP_EXECUTABLE_VALUE

SVN_PROP_NEEDS_LOCK = _core.SVN_PROP_NEEDS_LOCK

SVN_PROP_NEEDS_LOCK_VALUE = _core.SVN_PROP_NEEDS_LOCK_VALUE

SVN_PROP_SPECIAL = _core.SVN_PROP_SPECIAL

SVN_PROP_SPECIAL_VALUE = _core.SVN_PROP_SPECIAL_VALUE

SVN_PROP_EXTERNALS = _core.SVN_PROP_EXTERNALS

SVN_PROP_MERGEINFO = _core.SVN_PROP_MERGEINFO

SVN_PROP_INHERITABLE_AUTO_PROPS = _core.SVN_PROP_INHERITABLE_AUTO_PROPS

SVN_PROP_INHERITABLE_IGNORES = _core.SVN_PROP_INHERITABLE_IGNORES

SVN_PROP_TEXT_TIME = _core.SVN_PROP_TEXT_TIME

SVN_PROP_OWNER = _core.SVN_PROP_OWNER

SVN_PROP_GROUP = _core.SVN_PROP_GROUP

SVN_PROP_UNIX_MODE = _core.SVN_PROP_UNIX_MODE

SVN_PROP_WC_PREFIX = _core.SVN_PROP_WC_PREFIX

SVN_PROP_ENTRY_PREFIX = _core.SVN_PROP_ENTRY_PREFIX

SVN_PROP_ENTRY_COMMITTED_REV = _core.SVN_PROP_ENTRY_COMMITTED_REV

SVN_PROP_ENTRY_COMMITTED_DATE = _core.SVN_PROP_ENTRY_COMMITTED_DATE

SVN_PROP_ENTRY_LAST_AUTHOR = _core.SVN_PROP_ENTRY_LAST_AUTHOR

SVN_PROP_ENTRY_UUID = _core.SVN_PROP_ENTRY_UUID

SVN_PROP_ENTRY_LOCK_TOKEN = _core.SVN_PROP_ENTRY_LOCK_TOKEN

SVN_PROP_CUSTOM_PREFIX = _core.SVN_PROP_CUSTOM_PREFIX

SVN_PROP_REVISION_AUTHOR = _core.SVN_PROP_REVISION_AUTHOR

SVN_PROP_REVISION_LOG = _core.SVN_PROP_REVISION_LOG

SVN_PROP_REVISION_DATE = _core.SVN_PROP_REVISION_DATE

SVN_PROP_REVISION_ORIG_DATE = _core.SVN_PROP_REVISION_ORIG_DATE

SVN_PROP_REVISION_AUTOVERSIONED = _core.SVN_PROP_REVISION_AUTOVERSIONED

SVNSYNC_PROP_PREFIX = _core.SVNSYNC_PROP_PREFIX

SVNSYNC_PROP_LOCK = _core.SVNSYNC_PROP_LOCK

SVNSYNC_PROP_FROM_URL = _core.SVNSYNC_PROP_FROM_URL

SVNSYNC_PROP_FROM_UUID = _core.SVNSYNC_PROP_FROM_UUID

SVNSYNC_PROP_LAST_MERGED_REV = _core.SVNSYNC_PROP_LAST_MERGED_REV

SVNSYNC_PROP_CURRENTLY_COPYING = _core.SVNSYNC_PROP_CURRENTLY_COPYING

SVN_PROP_TXN_PREFIX = _core.SVN_PROP_TXN_PREFIX

SVN_PROP_TXN_CLIENT_COMPAT_VERSION = _core.SVN_PROP_TXN_CLIENT_COMPAT_VERSION

SVN_PROP_TXN_USER_AGENT = _core.SVN_PROP_TXN_USER_AGENT

SVN_PROP_REVISION_PREFIX = _core.SVN_PROP_REVISION_PREFIX

svn_opt_revision_unspecified = _core.svn_opt_revision_unspecified

svn_opt_revision_number = _core.svn_opt_revision_number

svn_opt_revision_date = _core.svn_opt_revision_date

svn_opt_revision_committed = _core.svn_opt_revision_committed

svn_opt_revision_previous = _core.svn_opt_revision_previous

svn_opt_revision_base = _core.svn_opt_revision_base

svn_opt_revision_working = _core.svn_opt_revision_working

svn_opt_revision_head = _core.svn_opt_revision_head

SVN_OPT_MAX_ALIASES = _core.SVN_OPT_MAX_ALIASES

SVN_OPT_MAX_OPTIONS = _core.SVN_OPT_MAX_OPTIONS

SVN_OPT_MAX_PARAGRAPHS = _core.SVN_OPT_MAX_PARAGRAPHS

SVN_OPT_FIRST_LONGOPT_ID = _core.SVN_OPT_FIRST_LONGOPT_ID

class svn_opt_subcommand_desc3_t(object):
    r"""Proxy of C svn_opt_subcommand_desc3_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    name = property(_core.svn_opt_subcommand_desc3_t_name_get, _core.svn_opt_subcommand_desc3_t_name_set, doc=r"""name : p.q(const).char""")
    cmd_func = property(_core.svn_opt_subcommand_desc3_t_cmd_func_get, _core.svn_opt_subcommand_desc3_t_cmd_func_set, doc=r"""cmd_func : p.svn_opt_subcommand_t""")
    aliases = property(_core.svn_opt_subcommand_desc3_t_aliases_get, _core.svn_opt_subcommand_desc3_t_aliases_set, doc=r"""aliases : a(3).p.q(const).char""")
    help = property(_core.svn_opt_subcommand_desc3_t_help_get, _core.svn_opt_subcommand_desc3_t_help_set, doc=r"""help : a(100).p.q(const).char""")
    valid_options = property(_core.svn_opt_subcommand_desc3_t_valid_options_get, _core.svn_opt_subcommand_desc3_t_valid_options_set, doc=r"""valid_options : a(50).int""")
    desc_overrides = property(_core.svn_opt_subcommand_desc3_t_desc_overrides_get, doc=r"""desc_overrides : a(50).svn_opt_subcommand_desc3_t_desc_overrides""")
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __init__(self):
        r"""__init__(svn_opt_subcommand_desc3_t self) -> svn_opt_subcommand_desc3_t"""
        _core.svn_opt_subcommand_desc3_t_swiginit(self, _core.new_svn_opt_subcommand_desc3_t())
    __swig_destroy__ = _core.delete_svn_opt_subcommand_desc3_t

# Register svn_opt_subcommand_desc3_t in _core:
_core.svn_opt_subcommand_desc3_t_swigregister(svn_opt_subcommand_desc3_t)
class svn_opt_subcommand_desc3_t_desc_overrides(object):
    r"""Proxy of C svn_opt_subcommand_desc3_t_desc_overrides struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    optch = property(_core.svn_opt_subcommand_desc3_t_desc_overrides_optch_get, _core.svn_opt_subcommand_desc3_t_desc_overrides_optch_set, doc=r"""optch : int""")
    desc = property(_core.svn_opt_subcommand_desc3_t_desc_overrides_desc_get, _core.svn_opt_subcommand_desc3_t_desc_overrides_desc_set, doc=r"""desc : p.q(const).char""")

    def __init__(self):
        r"""__init__(svn_opt_subcommand_desc3_t_desc_overrides self) -> svn_opt_subcommand_desc3_t_desc_overrides"""
        _core.svn_opt_subcommand_desc3_t_desc_overrides_swiginit(self, _core.new_svn_opt_subcommand_desc3_t_desc_overrides())
    __swig_destroy__ = _core.delete_svn_opt_subcommand_desc3_t_desc_overrides

# Register svn_opt_subcommand_desc3_t_desc_overrides in _core:
_core.svn_opt_subcommand_desc3_t_desc_overrides_swigregister(svn_opt_subcommand_desc3_t_desc_overrides)
class svn_opt_subcommand_desc2_t(object):
    r"""Proxy of C svn_opt_subcommand_desc2_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    name = property(_core.svn_opt_subcommand_desc2_t_name_get, _core.svn_opt_subcommand_desc2_t_name_set, doc=r"""name : p.q(const).char""")
    cmd_func = property(_core.svn_opt_subcommand_desc2_t_cmd_func_get, _core.svn_opt_subcommand_desc2_t_cmd_func_set, doc=r"""cmd_func : p.svn_opt_subcommand_t""")
    aliases = property(_core.svn_opt_subcommand_desc2_t_aliases_get, _core.svn_opt_subcommand_desc2_t_aliases_set, doc=r"""aliases : a(3).p.q(const).char""")
    help = property(_core.svn_opt_subcommand_desc2_t_help_get, _core.svn_opt_subcommand_desc2_t_help_set, doc=r"""help : p.q(const).char""")
    valid_options = property(_core.svn_opt_subcommand_desc2_t_valid_options_get, _core.svn_opt_subcommand_desc2_t_valid_options_set, doc=r"""valid_options : a(50).int""")
    desc_overrides = property(_core.svn_opt_subcommand_desc2_t_desc_overrides_get, doc=r"""desc_overrides : a(50).svn_opt_subcommand_desc2_t_desc_overrides""")
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __init__(self):
        r"""__init__(svn_opt_subcommand_desc2_t self) -> svn_opt_subcommand_desc2_t"""
        _core.svn_opt_subcommand_desc2_t_swiginit(self, _core.new_svn_opt_subcommand_desc2_t())
    __swig_destroy__ = _core.delete_svn_opt_subcommand_desc2_t

# Register svn_opt_subcommand_desc2_t in _core:
_core.svn_opt_subcommand_desc2_t_swigregister(svn_opt_subcommand_desc2_t)
class svn_opt_subcommand_desc2_t_desc_overrides(object):
    r"""Proxy of C svn_opt_subcommand_desc2_t_desc_overrides struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    optch = property(_core.svn_opt_subcommand_desc2_t_desc_overrides_optch_get, _core.svn_opt_subcommand_desc2_t_desc_overrides_optch_set, doc=r"""optch : int""")
    desc = property(_core.svn_opt_subcommand_desc2_t_desc_overrides_desc_get, _core.svn_opt_subcommand_desc2_t_desc_overrides_desc_set, doc=r"""desc : p.q(const).char""")

    def __init__(self):
        r"""__init__(svn_opt_subcommand_desc2_t_desc_overrides self) -> svn_opt_subcommand_desc2_t_desc_overrides"""
        _core.svn_opt_subcommand_desc2_t_desc_overrides_swiginit(self, _core.new_svn_opt_subcommand_desc2_t_desc_overrides())
    __swig_destroy__ = _core.delete_svn_opt_subcommand_desc2_t_desc_overrides

# Register svn_opt_subcommand_desc2_t_desc_overrides in _core:
_core.svn_opt_subcommand_desc2_t_desc_overrides_swigregister(svn_opt_subcommand_desc2_t_desc_overrides)
class svn_opt_subcommand_desc_t(object):
    r"""Proxy of C svn_opt_subcommand_desc_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    name = property(_core.svn_opt_subcommand_desc_t_name_get, _core.svn_opt_subcommand_desc_t_name_set, doc=r"""name : p.q(const).char""")
    cmd_func = property(_core.svn_opt_subcommand_desc_t_cmd_func_get, _core.svn_opt_subcommand_desc_t_cmd_func_set, doc=r"""cmd_func : p.svn_opt_subcommand_t""")
    aliases = property(_core.svn_opt_subcommand_desc_t_aliases_get, _core.svn_opt_subcommand_desc_t_aliases_set, doc=r"""aliases : a(3).p.q(const).char""")
    help = property(_core.svn_opt_subcommand_desc_t_help_get, _core.svn_opt_subcommand_desc_t_help_set, doc=r"""help : p.q(const).char""")
    valid_options = property(_core.svn_opt_subcommand_desc_t_valid_options_get, _core.svn_opt_subcommand_desc_t_valid_options_set, doc=r"""valid_options : a(50).int""")
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __init__(self):
        r"""__init__(svn_opt_subcommand_desc_t self) -> svn_opt_subcommand_desc_t"""
        _core.svn_opt_subcommand_desc_t_swiginit(self, _core.new_svn_opt_subcommand_desc_t())
    __swig_destroy__ = _core.delete_svn_opt_subcommand_desc_t

# Register svn_opt_subcommand_desc_t in _core:
_core.svn_opt_subcommand_desc_t_swigregister(svn_opt_subcommand_desc_t)

def svn_opt_get_canonical_subcommand3(table, cmd_name):
    r"""svn_opt_get_canonical_subcommand3(svn_opt_subcommand_desc3_t table, char const * cmd_name) -> svn_opt_subcommand_desc3_t"""
    return _core.svn_opt_get_canonical_subcommand3(table, cmd_name)

def svn_opt_get_canonical_subcommand2(table, cmd_name):
    r"""svn_opt_get_canonical_subcommand2(svn_opt_subcommand_desc2_t table, char const * cmd_name) -> svn_opt_subcommand_desc2_t"""
    return _core.svn_opt_get_canonical_subcommand2(table, cmd_name)

def svn_opt_get_canonical_subcommand(table, cmd_name):
    r"""svn_opt_get_canonical_subcommand(svn_opt_subcommand_desc_t table, char const * cmd_name) -> svn_opt_subcommand_desc_t"""
    return _core.svn_opt_get_canonical_subcommand(table, cmd_name)

def svn_opt_get_option_from_code3(*args):
    r"""svn_opt_get_option_from_code3(int code, apr_getopt_option_t const * option_table, svn_opt_subcommand_desc3_t command, apr_pool_t pool) -> apr_getopt_option_t const *"""
    return _core.svn_opt_get_option_from_code3(*args)

def svn_opt_get_option_from_code2(*args):
    r"""svn_opt_get_option_from_code2(int code, apr_getopt_option_t const * option_table, svn_opt_subcommand_desc2_t command, apr_pool_t pool) -> apr_getopt_option_t const *"""
    return _core.svn_opt_get_option_from_code2(*args)

def svn_opt_get_option_from_code(code, option_table):
    r"""svn_opt_get_option_from_code(int code, apr_getopt_option_t const * option_table) -> apr_getopt_option_t const *"""
    return _core.svn_opt_get_option_from_code(code, option_table)

def svn_opt_subcommand_takes_option4(command, option_code):
    r"""svn_opt_subcommand_takes_option4(svn_opt_subcommand_desc3_t command, int option_code) -> svn_boolean_t"""
    return _core.svn_opt_subcommand_takes_option4(command, option_code)

def svn_opt_subcommand_takes_option3(command, option_code):
    r"""svn_opt_subcommand_takes_option3(svn_opt_subcommand_desc2_t command, int option_code) -> svn_boolean_t"""
    return _core.svn_opt_subcommand_takes_option3(command, option_code)

def svn_opt_subcommand_takes_option2(command, option_code):
    r"""svn_opt_subcommand_takes_option2(svn_opt_subcommand_desc2_t command, int option_code) -> svn_boolean_t"""
    return _core.svn_opt_subcommand_takes_option2(command, option_code)

def svn_opt_subcommand_takes_option(command, option_code):
    r"""svn_opt_subcommand_takes_option(svn_opt_subcommand_desc_t command, int option_code) -> svn_boolean_t"""
    return _core.svn_opt_subcommand_takes_option(command, option_code)

def svn_opt_print_generic_help3(*args):
    r"""svn_opt_print_generic_help3(char const * header, svn_opt_subcommand_desc3_t cmd_table, apr_getopt_option_t const * opt_table, char const * footer, apr_pool_t pool, FILE * stream)"""
    return _core.svn_opt_print_generic_help3(*args)

def svn_opt_print_generic_help2(*args):
    r"""svn_opt_print_generic_help2(char const * header, svn_opt_subcommand_desc2_t cmd_table, apr_getopt_option_t const * opt_table, char const * footer, apr_pool_t pool, FILE * stream)"""
    return _core.svn_opt_print_generic_help2(*args)

def svn_opt_format_option(*args):
    r"""svn_opt_format_option(apr_getopt_option_t const * opt, svn_boolean_t doc, apr_pool_t pool)"""
    return _core.svn_opt_format_option(*args)

def svn_opt_subcommand_help4(*args):
    r"""svn_opt_subcommand_help4(char const * subcommand, svn_opt_subcommand_desc3_t table, apr_getopt_option_t const * options_table, apr_pool_t pool)"""
    return _core.svn_opt_subcommand_help4(*args)

def svn_opt_subcommand_help3(*args):
    r"""svn_opt_subcommand_help3(char const * subcommand, svn_opt_subcommand_desc2_t table, apr_getopt_option_t const * options_table, apr_pool_t pool)"""
    return _core.svn_opt_subcommand_help3(*args)

def svn_opt_subcommand_help2(*args):
    r"""svn_opt_subcommand_help2(char const * subcommand, svn_opt_subcommand_desc2_t table, apr_getopt_option_t const * options_table, apr_pool_t pool)"""
    return _core.svn_opt_subcommand_help2(*args)

def svn_opt_subcommand_help(*args):
    r"""svn_opt_subcommand_help(char const * subcommand, svn_opt_subcommand_desc_t table, apr_getopt_option_t const * options_table, apr_pool_t pool)"""
    return _core.svn_opt_subcommand_help(*args)
class svn_opt_revision_value_t(object):
    r"""Proxy of C svn_opt_revision_value_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    number = property(_core.svn_opt_revision_value_t_number_get, _core.svn_opt_revision_value_t_number_set, doc=r"""number : svn_revnum_t""")
    date = property(_core.svn_opt_revision_value_t_date_get, _core.svn_opt_revision_value_t_date_set, doc=r"""date : apr_time_t""")
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __init__(self):
        r"""__init__(svn_opt_revision_value_t self) -> svn_opt_revision_value_t"""
        _core.svn_opt_revision_value_t_swiginit(self, _core.new_svn_opt_revision_value_t())
    __swig_destroy__ = _core.delete_svn_opt_revision_value_t

# Register svn_opt_revision_value_t in _core:
_core.svn_opt_revision_value_t_swigregister(svn_opt_revision_value_t)
class svn_opt_revision_t(object):
    r"""Proxy of C svn_opt_revision_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    kind = property(_core.svn_opt_revision_t_kind_get, _core.svn_opt_revision_t_kind_set, doc=r"""kind : enum svn_opt_revision_kind""")
    value = property(_core.svn_opt_revision_t_value_get, _core.svn_opt_revision_t_value_set, doc=r"""value : svn_opt_revision_value_t""")
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __init__(self):
        r"""__init__(svn_opt_revision_t self) -> svn_opt_revision_t"""
        _core.svn_opt_revision_t_swiginit(self, _core.new_svn_opt_revision_t())
    __swig_destroy__ = _core.delete_svn_opt_revision_t

# Register svn_opt_revision_t in _core:
_core.svn_opt_revision_t_swigregister(svn_opt_revision_t)
class svn_opt_revision_range_t(object):
    r"""Proxy of C svn_opt_revision_range_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    start = property(_core.svn_opt_revision_range_t_start_get, _core.svn_opt_revision_range_t_start_set, doc=r"""start : svn_opt_revision_t""")
    end = property(_core.svn_opt_revision_range_t_end_get, _core.svn_opt_revision_range_t_end_set, doc=r"""end : svn_opt_revision_t""")
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __init__(self):
        r"""__init__(svn_opt_revision_range_t self) -> svn_opt_revision_range_t"""
        _core.svn_opt_revision_range_t_swiginit(self, _core.new_svn_opt_revision_range_t())
    __swig_destroy__ = _core.delete_svn_opt_revision_range_t

# Register svn_opt_revision_range_t in _core:
_core.svn_opt_revision_range_t_swigregister(svn_opt_revision_range_t)

def svn_opt_parse_revision(*args):
    r"""svn_opt_parse_revision(svn_opt_revision_t start_revision, svn_opt_revision_t end_revision, char const * arg, apr_pool_t pool) -> int"""
    return _core.svn_opt_parse_revision(*args)

def svn_opt_parse_revision_to_range(*args):
    r"""svn_opt_parse_revision_to_range(apr_array_header_t opt_ranges, char const * arg, apr_pool_t pool) -> int"""
    return _core.svn_opt_parse_revision_to_range(*args)

def svn_opt_resolve_revisions(*args):
    r"""svn_opt_resolve_revisions(svn_opt_revision_t peg_rev, svn_opt_revision_t op_rev, svn_boolean_t is_url, svn_boolean_t notice_local_mods, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_opt_resolve_revisions(*args)

def svn_opt_args_to_target_array3(*args):
    r"""svn_opt_args_to_target_array3(apr_getopt_t * os, apr_array_header_t known_targets, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_opt_args_to_target_array3(*args)

def svn_opt_args_to_target_array2(*args):
    r"""svn_opt_args_to_target_array2(apr_getopt_t * os, apr_array_header_t known_targets, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_opt_args_to_target_array2(*args)

def svn_opt_parse_revprop(*args):
    r"""svn_opt_parse_revprop(char const * revprop_spec, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_opt_parse_revprop(*args)

def svn_opt_push_implicit_dot_target(*args):
    r"""svn_opt_push_implicit_dot_target(apr_array_header_t targets, apr_pool_t pool)"""
    return _core.svn_opt_push_implicit_dot_target(*args)

def svn_opt_parse_num_args(*args):
    r"""svn_opt_parse_num_args(apr_getopt_t * os, int num_args, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_opt_parse_num_args(*args)

def svn_opt_parse_all_args(*args):
    r"""svn_opt_parse_all_args(apr_getopt_t * os, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_opt_parse_all_args(*args)

def svn_opt_parse_path(*args):
    r"""svn_opt_parse_path(svn_opt_revision_t rev, char const * path, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_opt_parse_path(*args)

def svn_opt_print_help5(*args):
    r"""svn_opt_print_help5(apr_getopt_t * os, char const * pgm_name, svn_boolean_t print_version, svn_boolean_t quiet, svn_boolean_t verbose, char const * version_footer, char const * header, svn_opt_subcommand_desc3_t cmd_table, apr_getopt_option_t const * option_table, char const * footer, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_opt_print_help5(*args)

def svn_opt_print_help4(*args):
    r"""svn_opt_print_help4(apr_getopt_t * os, char const * pgm_name, svn_boolean_t print_version, svn_boolean_t quiet, svn_boolean_t verbose, char const * version_footer, char const * header, svn_opt_subcommand_desc2_t cmd_table, apr_getopt_option_t const * option_table, char const * footer, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_opt_print_help4(*args)

def svn_opt_print_help3(*args):
    r"""svn_opt_print_help3(apr_getopt_t * os, char const * pgm_name, svn_boolean_t print_version, svn_boolean_t quiet, char const * version_footer, char const * header, svn_opt_subcommand_desc2_t cmd_table, apr_getopt_option_t const * option_table, char const * footer, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_opt_print_help3(*args)

def svn_opt_print_help2(*args):
    r"""svn_opt_print_help2(apr_getopt_t * os, char const * pgm_name, svn_boolean_t print_version, svn_boolean_t quiet, char const * version_footer, char const * header, svn_opt_subcommand_desc2_t cmd_table, apr_getopt_option_t const * option_table, char const * footer, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_opt_print_help2(*args)

def svn_opt_print_help(*args):
    r"""svn_opt_print_help(apr_getopt_t * os, char const * pgm_name, svn_boolean_t print_version, svn_boolean_t quiet, char const * version_footer, char const * header, svn_opt_subcommand_desc_t cmd_table, apr_getopt_option_t const * option_table, char const * footer, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_opt_print_help(*args)

def svn_cmdline_init(progname, error_stream):
    r"""svn_cmdline_init(char const * progname, FILE * error_stream) -> int"""
    return _core.svn_cmdline_init(progname, error_stream)

def svn_cmdline_create_auth_baton2(*args):
    r"""svn_cmdline_create_auth_baton2(svn_boolean_t non_interactive, char const * username, char const * password, char const * config_dir, svn_boolean_t no_auth_cache, svn_boolean_t trust_server_cert_unknown_ca, svn_boolean_t trust_server_cert_cn_mismatch, svn_boolean_t trust_server_cert_expired, svn_boolean_t trust_server_cert_not_yet_valid, svn_boolean_t trust_server_cert_other_failure, svn_config_t cfg, svn_cancel_func_t cancel_func, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_cmdline_create_auth_baton2(*args)

def svn_cmdline_create_auth_baton(*args):
    r"""svn_cmdline_create_auth_baton(svn_boolean_t non_interactive, char const * username, char const * password, char const * config_dir, svn_boolean_t no_auth_cache, svn_boolean_t trust_server_cert, svn_config_t cfg, svn_cancel_func_t cancel_func, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_cmdline_create_auth_baton(*args)
class svn_auth_provider_t(object):
    r"""Proxy of C svn_auth_provider_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    cred_kind = property(_core.svn_auth_provider_t_cred_kind_get, _core.svn_auth_provider_t_cred_kind_set, doc=r"""cred_kind : p.q(const).char""")
    first_credentials = property(_core.svn_auth_provider_t_first_credentials_get, _core.svn_auth_provider_t_first_credentials_set, doc=r"""first_credentials : p.f(p.p.void,p.p.void,p.void,p.apr_hash_t,p.q(const).char,p.apr_pool_t).p.svn_error_t""")
    next_credentials = property(_core.svn_auth_provider_t_next_credentials_get, _core.svn_auth_provider_t_next_credentials_set, doc=r"""next_credentials : p.f(p.p.void,p.void,p.void,p.apr_hash_t,p.q(const).char,p.apr_pool_t).p.svn_error_t""")
    save_credentials = property(_core.svn_auth_provider_t_save_credentials_get, _core.svn_auth_provider_t_save_credentials_set, doc=r"""save_credentials : p.f(p.svn_boolean_t,p.void,p.void,p.apr_hash_t,p.q(const).char,p.apr_pool_t).p.svn_error_t""")
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def first_credentials(self, *args):
      return svn_auth_provider_invoke_first_credentials(self, *args)


    def next_credentials(self, *args):
      return svn_auth_provider_invoke_next_credentials(self, *args)


    def save_credentials(self, *args):
      return svn_auth_provider_invoke_save_credentials(self, *args)


    def __init__(self):
        r"""__init__(svn_auth_provider_t self) -> svn_auth_provider_t"""
        _core.svn_auth_provider_t_swiginit(self, _core.new_svn_auth_provider_t())
    __swig_destroy__ = _core.delete_svn_auth_provider_t

# Register svn_auth_provider_t in _core:
_core.svn_auth_provider_t_swigregister(svn_auth_provider_t)
class svn_auth_provider_object_t(object):
    r"""Proxy of C svn_auth_provider_object_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    vtable = property(_core.svn_auth_provider_object_t_vtable_get, _core.svn_auth_provider_object_t_vtable_set, doc=r"""vtable : p.q(const).svn_auth_provider_t""")
    provider_baton = property(_core.svn_auth_provider_object_t_provider_baton_get, _core.svn_auth_provider_object_t_provider_baton_set, doc=r"""provider_baton : p.void""")
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __init__(self):
        r"""__init__(svn_auth_provider_object_t self) -> svn_auth_provider_object_t"""
        _core.svn_auth_provider_object_t_swiginit(self, _core.new_svn_auth_provider_object_t())
    __swig_destroy__ = _core.delete_svn_auth_provider_object_t

# Register svn_auth_provider_object_t in _core:
_core.svn_auth_provider_object_t_swigregister(svn_auth_provider_object_t)
SVN_AUTH_CRED_SIMPLE = _core.SVN_AUTH_CRED_SIMPLE

class svn_auth_cred_simple_t(object):
    r"""Proxy of C svn_auth_cred_simple_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    username = property(_core.svn_auth_cred_simple_t_username_get, _core.svn_auth_cred_simple_t_username_set, doc=r"""username : p.q(const).char""")
    password = property(_core.svn_auth_cred_simple_t_password_get, _core.svn_auth_cred_simple_t_password_set, doc=r"""password : p.q(const).char""")
    may_save = property(_core.svn_auth_cred_simple_t_may_save_get, _core.svn_auth_cred_simple_t_may_save_set, doc=r"""may_save : svn_boolean_t""")
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __init__(self):
        r"""__init__(svn_auth_cred_simple_t self) -> svn_auth_cred_simple_t"""
        _core.svn_auth_cred_simple_t_swiginit(self, _core.new_svn_auth_cred_simple_t())
    __swig_destroy__ = _core.delete_svn_auth_cred_simple_t

# Register svn_auth_cred_simple_t in _core:
_core.svn_auth_cred_simple_t_swigregister(svn_auth_cred_simple_t)
SVN_AUTH_CRED_USERNAME = _core.SVN_AUTH_CRED_USERNAME

class svn_auth_cred_username_t(object):
    r"""Proxy of C svn_auth_cred_username_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    username = property(_core.svn_auth_cred_username_t_username_get, _core.svn_auth_cred_username_t_username_set, doc=r"""username : p.q(const).char""")
    may_save = property(_core.svn_auth_cred_username_t_may_save_get, _core.svn_auth_cred_username_t_may_save_set, doc=r"""may_save : svn_boolean_t""")
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __init__(self):
        r"""__init__(svn_auth_cred_username_t self) -> svn_auth_cred_username_t"""
        _core.svn_auth_cred_username_t_swiginit(self, _core.new_svn_auth_cred_username_t())
    __swig_destroy__ = _core.delete_svn_auth_cred_username_t

# Register svn_auth_cred_username_t in _core:
_core.svn_auth_cred_username_t_swigregister(svn_auth_cred_username_t)
SVN_AUTH_CRED_SSL_CLIENT_CERT = _core.SVN_AUTH_CRED_SSL_CLIENT_CERT

class svn_auth_cred_ssl_client_cert_t(object):
    r"""Proxy of C svn_auth_cred_ssl_client_cert_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    cert_file = property(_core.svn_auth_cred_ssl_client_cert_t_cert_file_get, _core.svn_auth_cred_ssl_client_cert_t_cert_file_set, doc=r"""cert_file : p.q(const).char""")
    may_save = property(_core.svn_auth_cred_ssl_client_cert_t_may_save_get, _core.svn_auth_cred_ssl_client_cert_t_may_save_set, doc=r"""may_save : svn_boolean_t""")
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __init__(self):
        r"""__init__(svn_auth_cred_ssl_client_cert_t self) -> svn_auth_cred_ssl_client_cert_t"""
        _core.svn_auth_cred_ssl_client_cert_t_swiginit(self, _core.new_svn_auth_cred_ssl_client_cert_t())
    __swig_destroy__ = _core.delete_svn_auth_cred_ssl_client_cert_t

# Register svn_auth_cred_ssl_client_cert_t in _core:
_core.svn_auth_cred_ssl_client_cert_t_swigregister(svn_auth_cred_ssl_client_cert_t)
SVN_AUTH_CRED_SSL_CLIENT_CERT_PW = _core.SVN_AUTH_CRED_SSL_CLIENT_CERT_PW

class svn_auth_cred_ssl_client_cert_pw_t(object):
    r"""Proxy of C svn_auth_cred_ssl_client_cert_pw_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    password = property(_core.svn_auth_cred_ssl_client_cert_pw_t_password_get, _core.svn_auth_cred_ssl_client_cert_pw_t_password_set, doc=r"""password : p.q(const).char""")
    may_save = property(_core.svn_auth_cred_ssl_client_cert_pw_t_may_save_get, _core.svn_auth_cred_ssl_client_cert_pw_t_may_save_set, doc=r"""may_save : svn_boolean_t""")
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __init__(self):
        r"""__init__(svn_auth_cred_ssl_client_cert_pw_t self) -> svn_auth_cred_ssl_client_cert_pw_t"""
        _core.svn_auth_cred_ssl_client_cert_pw_t_swiginit(self, _core.new_svn_auth_cred_ssl_client_cert_pw_t())
    __swig_destroy__ = _core.delete_svn_auth_cred_ssl_client_cert_pw_t

# Register svn_auth_cred_ssl_client_cert_pw_t in _core:
_core.svn_auth_cred_ssl_client_cert_pw_t_swigregister(svn_auth_cred_ssl_client_cert_pw_t)
SVN_AUTH_CRED_SSL_SERVER_TRUST = _core.SVN_AUTH_CRED_SSL_SERVER_TRUST

class svn_auth_ssl_server_cert_info_t(object):
    r"""Proxy of C svn_auth_ssl_server_cert_info_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    hostname = property(_core.svn_auth_ssl_server_cert_info_t_hostname_get, _core.svn_auth_ssl_server_cert_info_t_hostname_set, doc=r"""hostname : p.q(const).char""")
    fingerprint = property(_core.svn_auth_ssl_server_cert_info_t_fingerprint_get, _core.svn_auth_ssl_server_cert_info_t_fingerprint_set, doc=r"""fingerprint : p.q(const).char""")
    valid_from = property(_core.svn_auth_ssl_server_cert_info_t_valid_from_get, _core.svn_auth_ssl_server_cert_info_t_valid_from_set, doc=r"""valid_from : p.q(const).char""")
    valid_until = property(_core.svn_auth_ssl_server_cert_info_t_valid_until_get, _core.svn_auth_ssl_server_cert_info_t_valid_until_set, doc=r"""valid_until : p.q(const).char""")
    issuer_dname = property(_core.svn_auth_ssl_server_cert_info_t_issuer_dname_get, _core.svn_auth_ssl_server_cert_info_t_issuer_dname_set, doc=r"""issuer_dname : p.q(const).char""")
    ascii_cert = property(_core.svn_auth_ssl_server_cert_info_t_ascii_cert_get, _core.svn_auth_ssl_server_cert_info_t_ascii_cert_set, doc=r"""ascii_cert : p.q(const).char""")
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __init__(self):
        r"""__init__(svn_auth_ssl_server_cert_info_t self) -> svn_auth_ssl_server_cert_info_t"""
        _core.svn_auth_ssl_server_cert_info_t_swiginit(self, _core.new_svn_auth_ssl_server_cert_info_t())
    __swig_destroy__ = _core.delete_svn_auth_ssl_server_cert_info_t

# Register svn_auth_ssl_server_cert_info_t in _core:
_core.svn_auth_ssl_server_cert_info_t_swigregister(svn_auth_ssl_server_cert_info_t)

def svn_auth_ssl_server_cert_info_dup(*args):
    r"""svn_auth_ssl_server_cert_info_dup(svn_auth_ssl_server_cert_info_t info, apr_pool_t pool) -> svn_auth_ssl_server_cert_info_t"""
    return _core.svn_auth_ssl_server_cert_info_dup(*args)
class svn_auth_cred_ssl_server_trust_t(object):
    r"""Proxy of C svn_auth_cred_ssl_server_trust_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    may_save = property(_core.svn_auth_cred_ssl_server_trust_t_may_save_get, _core.svn_auth_cred_ssl_server_trust_t_may_save_set, doc=r"""may_save : svn_boolean_t""")
    accepted_failures = property(_core.svn_auth_cred_ssl_server_trust_t_accepted_failures_get, _core.svn_auth_cred_ssl_server_trust_t_accepted_failures_set, doc=r"""accepted_failures : apr_uint32_t""")
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __init__(self):
        r"""__init__(svn_auth_cred_ssl_server_trust_t self) -> svn_auth_cred_ssl_server_trust_t"""
        _core.svn_auth_cred_ssl_server_trust_t_swiginit(self, _core.new_svn_auth_cred_ssl_server_trust_t())
    __swig_destroy__ = _core.delete_svn_auth_cred_ssl_server_trust_t

# Register svn_auth_cred_ssl_server_trust_t in _core:
_core.svn_auth_cred_ssl_server_trust_t_swigregister(svn_auth_cred_ssl_server_trust_t)
SVN_AUTH_SSL_NOTYETVALID = _core.SVN_AUTH_SSL_NOTYETVALID

SVN_AUTH_SSL_EXPIRED = _core.SVN_AUTH_SSL_EXPIRED

SVN_AUTH_SSL_CNMISMATCH = _core.SVN_AUTH_SSL_CNMISMATCH

SVN_AUTH_SSL_UNKNOWNCA = _core.SVN_AUTH_SSL_UNKNOWNCA

SVN_AUTH_SSL_OTHER = _core.SVN_AUTH_SSL_OTHER


def svn_auth_open(*args):
    r"""svn_auth_open(apr_array_header_t providers, apr_pool_t pool)"""
    val = _core.svn_auth_open(*args)

    val.__dict__["_deps"] = list(args[0])


    return val

def svn_auth_set_parameter(auth_baton, name, value):
    r"""svn_auth_set_parameter(svn_auth_baton_t auth_baton, char const * name, void const * value)"""
    return _core.svn_auth_set_parameter(auth_baton, name, value)
SVN_AUTH_PARAM_PREFIX = _core.SVN_AUTH_PARAM_PREFIX

SVN_AUTH_PARAM_DEFAULT_USERNAME = _core.SVN_AUTH_PARAM_DEFAULT_USERNAME

SVN_AUTH_PARAM_DEFAULT_PASSWORD = _core.SVN_AUTH_PARAM_DEFAULT_PASSWORD

SVN_AUTH_PARAM_NON_INTERACTIVE = _core.SVN_AUTH_PARAM_NON_INTERACTIVE

SVN_AUTH_PARAM_DONT_STORE_PASSWORDS = _core.SVN_AUTH_PARAM_DONT_STORE_PASSWORDS

SVN_AUTH_PARAM_STORE_PLAINTEXT_PASSWORDS = _core.SVN_AUTH_PARAM_STORE_PLAINTEXT_PASSWORDS

SVN_AUTH_PARAM_DONT_STORE_SSL_CLIENT_CERT_PP = _core.SVN_AUTH_PARAM_DONT_STORE_SSL_CLIENT_CERT_PP

SVN_AUTH_PARAM_STORE_SSL_CLIENT_CERT_PP_PLAINTEXT = _core.SVN_AUTH_PARAM_STORE_SSL_CLIENT_CERT_PP_PLAINTEXT

SVN_AUTH_PARAM_NO_AUTH_CACHE = _core.SVN_AUTH_PARAM_NO_AUTH_CACHE

SVN_AUTH_PARAM_SSL_SERVER_FAILURES = _core.SVN_AUTH_PARAM_SSL_SERVER_FAILURES

SVN_AUTH_PARAM_SSL_SERVER_CERT_INFO = _core.SVN_AUTH_PARAM_SSL_SERVER_CERT_INFO

SVN_AUTH_PARAM_CONFIG_CATEGORY_CONFIG = _core.SVN_AUTH_PARAM_CONFIG_CATEGORY_CONFIG

SVN_AUTH_PARAM_CONFIG_CATEGORY_SERVERS = _core.SVN_AUTH_PARAM_CONFIG_CATEGORY_SERVERS

SVN_AUTH_PARAM_CONFIG = _core.SVN_AUTH_PARAM_CONFIG

SVN_AUTH_PARAM_SERVER_GROUP = _core.SVN_AUTH_PARAM_SERVER_GROUP

SVN_AUTH_PARAM_CONFIG_DIR = _core.SVN_AUTH_PARAM_CONFIG_DIR


def svn_auth_first_credentials(*args):
    r"""svn_auth_first_credentials(char const * cred_kind, char const * realmstring, svn_auth_baton_t auth_baton, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_auth_first_credentials(*args)

def svn_auth_next_credentials(*args):
    r"""svn_auth_next_credentials(svn_auth_iterstate_t state, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_auth_next_credentials(*args)

def svn_auth_save_credentials(*args):
    r"""svn_auth_save_credentials(svn_auth_iterstate_t state, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_auth_save_credentials(*args)

def svn_auth_forget_credentials(*args):
    r"""svn_auth_forget_credentials(svn_auth_baton_t auth_baton, char const * cred_kind, char const * realmstring, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_auth_forget_credentials(*args)

def svn_auth_get_simple_prompt_provider(*args):
    r"""svn_auth_get_simple_prompt_provider(svn_auth_simple_prompt_func_t prompt_func, int retry_limit, apr_pool_t pool)"""
    return _core.svn_auth_get_simple_prompt_provider(*args)

def svn_auth_get_username_prompt_provider(*args):
    r"""svn_auth_get_username_prompt_provider(svn_auth_username_prompt_func_t prompt_func, int retry_limit, apr_pool_t pool)"""
    return _core.svn_auth_get_username_prompt_provider(*args)

def svn_auth_get_simple_provider2(*args):
    r"""svn_auth_get_simple_provider2(svn_auth_plaintext_prompt_func_t plaintext_prompt_func, void * prompt_baton, apr_pool_t pool)"""
    return _core.svn_auth_get_simple_provider2(*args)

def svn_auth_get_simple_provider(*args):
    r"""svn_auth_get_simple_provider(apr_pool_t pool)"""
    return _core.svn_auth_get_simple_provider(*args)

def svn_auth_get_platform_specific_provider(*args):
    r"""svn_auth_get_platform_specific_provider(char const * provider_name, char const * provider_type, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_auth_get_platform_specific_provider(*args)

def svn_auth_get_platform_specific_client_providers(*args):
    r"""svn_auth_get_platform_specific_client_providers(svn_config_t config, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_auth_get_platform_specific_client_providers(*args)
SVN_AUTH_PARAM_GNOME_KEYRING_UNLOCK_PROMPT_FUNC = _core.SVN_AUTH_PARAM_GNOME_KEYRING_UNLOCK_PROMPT_FUNC

SVN_AUTH_PARAM_GNOME_KEYRING_UNLOCK_PROMPT_BATON = _core.SVN_AUTH_PARAM_GNOME_KEYRING_UNLOCK_PROMPT_BATON


def svn_auth_get_username_provider(*args):
    r"""svn_auth_get_username_provider(apr_pool_t pool)"""
    return _core.svn_auth_get_username_provider(*args)

def svn_auth_get_ssl_server_trust_file_provider(*args):
    r"""svn_auth_get_ssl_server_trust_file_provider(apr_pool_t pool)"""
    return _core.svn_auth_get_ssl_server_trust_file_provider(*args)

def svn_auth_get_ssl_client_cert_file_provider(*args):
    r"""svn_auth_get_ssl_client_cert_file_provider(apr_pool_t pool)"""
    return _core.svn_auth_get_ssl_client_cert_file_provider(*args)

def svn_auth_get_ssl_client_cert_pw_file_provider2(*args):
    r"""svn_auth_get_ssl_client_cert_pw_file_provider2(svn_auth_plaintext_passphrase_prompt_func_t plaintext_passphrase_prompt_func, void * prompt_baton, apr_pool_t pool)"""
    return _core.svn_auth_get_ssl_client_cert_pw_file_provider2(*args)

def svn_auth_get_ssl_client_cert_pw_file_provider(*args):
    r"""svn_auth_get_ssl_client_cert_pw_file_provider(apr_pool_t pool)"""
    return _core.svn_auth_get_ssl_client_cert_pw_file_provider(*args)

def svn_auth_get_ssl_server_trust_prompt_provider(*args):
    r"""svn_auth_get_ssl_server_trust_prompt_provider(svn_auth_ssl_server_trust_prompt_func_t prompt_func, apr_pool_t pool)"""
    return _core.svn_auth_get_ssl_server_trust_prompt_provider(*args)

def svn_auth_get_ssl_client_cert_prompt_provider(*args):
    r"""svn_auth_get_ssl_client_cert_prompt_provider(svn_auth_ssl_client_cert_prompt_func_t prompt_func, int retry_limit, apr_pool_t pool)"""
    return _core.svn_auth_get_ssl_client_cert_prompt_provider(*args)

def svn_auth_get_ssl_client_cert_pw_prompt_provider(*args):
    r"""svn_auth_get_ssl_client_cert_pw_prompt_provider(svn_auth_ssl_client_cert_pw_prompt_func_t prompt_func, int retry_limit, apr_pool_t pool)"""
    return _core.svn_auth_get_ssl_client_cert_pw_prompt_provider(*args)
class svn_auth_baton_t(object):
    r"""Proxy of C svn_auth_baton_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


# Register svn_auth_baton_t in _core:
_core.svn_auth_baton_t_swigregister(svn_auth_baton_t)
class svn_auth_iterstate_t(object):
    r"""Proxy of C svn_auth_iterstate_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


# Register svn_auth_iterstate_t in _core:
_core.svn_auth_iterstate_t_swigregister(svn_auth_iterstate_t)

def svn_auth_provider_invoke_first_credentials(*args):
    r"""svn_auth_provider_invoke_first_credentials(svn_auth_provider_t _obj, void * provider_baton, apr_hash_t parameters, char const * realmstring, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_auth_provider_invoke_first_credentials(*args)

def svn_auth_provider_invoke_next_credentials(*args):
    r"""svn_auth_provider_invoke_next_credentials(svn_auth_provider_t _obj, void * iter_baton, void * provider_baton, apr_hash_t parameters, char const * realmstring, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_auth_provider_invoke_next_credentials(*args)

def svn_auth_provider_invoke_save_credentials(*args):
    r"""svn_auth_provider_invoke_save_credentials(svn_auth_provider_t _obj, void * credentials, void * provider_baton, apr_hash_t parameters, char const * realmstring, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_auth_provider_invoke_save_credentials(*args)

def svn_auth_invoke_simple_provider_func(*args):
    r"""svn_auth_invoke_simple_provider_func(svn_auth_simple_provider_func_t _obj, apr_pool_t pool)"""
    return _core.svn_auth_invoke_simple_provider_func(*args)

def svn_auth_invoke_ssl_client_cert_pw_provider_func(*args):
    r"""svn_auth_invoke_ssl_client_cert_pw_provider_func(svn_auth_ssl_client_cert_pw_provider_func_t _obj, apr_pool_t pool)"""
    return _core.svn_auth_invoke_ssl_client_cert_pw_provider_func(*args)

def svn_auth_invoke_simple_prompt_func(*args):
    r"""svn_auth_invoke_simple_prompt_func(svn_auth_simple_prompt_func_t _obj, void * baton, char const * realm, char const * username, svn_boolean_t may_save, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_auth_invoke_simple_prompt_func(*args)

def svn_auth_invoke_username_prompt_func(*args):
    r"""svn_auth_invoke_username_prompt_func(svn_auth_username_prompt_func_t _obj, void * baton, char const * realm, svn_boolean_t may_save, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_auth_invoke_username_prompt_func(*args)

def svn_auth_invoke_ssl_server_trust_prompt_func(*args):
    r"""svn_auth_invoke_ssl_server_trust_prompt_func(svn_auth_ssl_server_trust_prompt_func_t _obj, void * baton, char const * realm, apr_uint32_t failures, svn_auth_ssl_server_cert_info_t cert_info, svn_boolean_t may_save, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_auth_invoke_ssl_server_trust_prompt_func(*args)

def svn_auth_invoke_ssl_client_cert_prompt_func(*args):
    r"""svn_auth_invoke_ssl_client_cert_prompt_func(svn_auth_ssl_client_cert_prompt_func_t _obj, void * baton, char const * realm, svn_boolean_t may_save, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_auth_invoke_ssl_client_cert_prompt_func(*args)

def svn_auth_invoke_ssl_client_cert_pw_prompt_func(*args):
    r"""svn_auth_invoke_ssl_client_cert_pw_prompt_func(svn_auth_ssl_client_cert_pw_prompt_func_t _obj, void * baton, char const * realm, svn_boolean_t may_save, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_auth_invoke_ssl_client_cert_pw_prompt_func(*args)

def svn_auth_invoke_plaintext_prompt_func(*args):
    r"""svn_auth_invoke_plaintext_prompt_func(svn_auth_plaintext_prompt_func_t _obj, char const * realmstring, void * baton, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_auth_invoke_plaintext_prompt_func(*args)

def svn_auth_invoke_plaintext_passphrase_prompt_func(*args):
    r"""svn_auth_invoke_plaintext_passphrase_prompt_func(svn_auth_plaintext_passphrase_prompt_func_t _obj, char const * realmstring, void * baton, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_auth_invoke_plaintext_passphrase_prompt_func(*args)
class svn_auth_simple_provider_func_t(object):
    r"""Proxy of C svn_auth_simple_provider_func_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_auth_invoke_simple_provider_func(self, *args)


# Register svn_auth_simple_provider_func_t in _core:
_core.svn_auth_simple_provider_func_t_swigregister(svn_auth_simple_provider_func_t)
class svn_auth_ssl_client_cert_pw_provider_func_t(object):
    r"""Proxy of C svn_auth_ssl_client_cert_pw_provider_func_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_auth_invoke_ssl_client_cert_pw_provider_func(self, *args)


# Register svn_auth_ssl_client_cert_pw_provider_func_t in _core:
_core.svn_auth_ssl_client_cert_pw_provider_func_t_swigregister(svn_auth_ssl_client_cert_pw_provider_func_t)
class svn_auth_simple_prompt_func_t(object):
    r"""Proxy of C svn_auth_simple_prompt_func_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_auth_invoke_simple_prompt_func(self, *args)


# Register svn_auth_simple_prompt_func_t in _core:
_core.svn_auth_simple_prompt_func_t_swigregister(svn_auth_simple_prompt_func_t)
class svn_auth_username_prompt_func_t(object):
    r"""Proxy of C svn_auth_username_prompt_func_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_auth_invoke_username_prompt_func(self, *args)


# Register svn_auth_username_prompt_func_t in _core:
_core.svn_auth_username_prompt_func_t_swigregister(svn_auth_username_prompt_func_t)
class svn_auth_ssl_server_trust_prompt_func_t(object):
    r"""Proxy of C svn_auth_ssl_server_trust_prompt_func_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_auth_invoke_ssl_server_trust_prompt_func(self, *args)


# Register svn_auth_ssl_server_trust_prompt_func_t in _core:
_core.svn_auth_ssl_server_trust_prompt_func_t_swigregister(svn_auth_ssl_server_trust_prompt_func_t)
class svn_auth_ssl_client_cert_prompt_func_t(object):
    r"""Proxy of C svn_auth_ssl_client_cert_prompt_func_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_auth_invoke_ssl_client_cert_prompt_func(self, *args)


# Register svn_auth_ssl_client_cert_prompt_func_t in _core:
_core.svn_auth_ssl_client_cert_prompt_func_t_swigregister(svn_auth_ssl_client_cert_prompt_func_t)
class svn_auth_ssl_client_cert_pw_prompt_func_t(object):
    r"""Proxy of C svn_auth_ssl_client_cert_pw_prompt_func_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_auth_invoke_ssl_client_cert_pw_prompt_func(self, *args)


# Register svn_auth_ssl_client_cert_pw_prompt_func_t in _core:
_core.svn_auth_ssl_client_cert_pw_prompt_func_t_swigregister(svn_auth_ssl_client_cert_pw_prompt_func_t)
class svn_auth_plaintext_prompt_func_t(object):
    r"""Proxy of C svn_auth_plaintext_prompt_func_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_auth_invoke_plaintext_prompt_func(self, *args)


# Register svn_auth_plaintext_prompt_func_t in _core:
_core.svn_auth_plaintext_prompt_func_t_swigregister(svn_auth_plaintext_prompt_func_t)
class svn_auth_plaintext_passphrase_prompt_func_t(object):
    r"""Proxy of C svn_auth_plaintext_passphrase_prompt_func_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_auth_invoke_plaintext_passphrase_prompt_func(self, *args)


# Register svn_auth_plaintext_passphrase_prompt_func_t in _core:
_core.svn_auth_plaintext_passphrase_prompt_func_t_swigregister(svn_auth_plaintext_passphrase_prompt_func_t)
class svn_auth_gnome_keyring_unlock_prompt_func_t(object):
    r"""Proxy of C svn_auth_gnome_keyring_unlock_prompt_func_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_auth_invoke_gnome_keyring_unlock_prompt_func(self, *args)


# Register svn_auth_gnome_keyring_unlock_prompt_func_t in _core:
_core.svn_auth_gnome_keyring_unlock_prompt_func_t_swigregister(svn_auth_gnome_keyring_unlock_prompt_func_t)
SVN_CONFIG_CATEGORY_SERVERS = _core.SVN_CONFIG_CATEGORY_SERVERS

SVN_CONFIG_SECTION_GROUPS = _core.SVN_CONFIG_SECTION_GROUPS

SVN_CONFIG_SECTION_GLOBAL = _core.SVN_CONFIG_SECTION_GLOBAL

SVN_CONFIG_OPTION_HTTP_PROXY_HOST = _core.SVN_CONFIG_OPTION_HTTP_PROXY_HOST

SVN_CONFIG_OPTION_HTTP_PROXY_PORT = _core.SVN_CONFIG_OPTION_HTTP_PROXY_PORT

SVN_CONFIG_OPTION_HTTP_PROXY_USERNAME = _core.SVN_CONFIG_OPTION_HTTP_PROXY_USERNAME

SVN_CONFIG_OPTION_HTTP_PROXY_PASSWORD = _core.SVN_CONFIG_OPTION_HTTP_PROXY_PASSWORD

SVN_CONFIG_OPTION_HTTP_PROXY_EXCEPTIONS = _core.SVN_CONFIG_OPTION_HTTP_PROXY_EXCEPTIONS

SVN_CONFIG_OPTION_HTTP_TIMEOUT = _core.SVN_CONFIG_OPTION_HTTP_TIMEOUT

SVN_CONFIG_OPTION_HTTP_COMPRESSION = _core.SVN_CONFIG_OPTION_HTTP_COMPRESSION

SVN_CONFIG_OPTION_NEON_DEBUG_MASK = _core.SVN_CONFIG_OPTION_NEON_DEBUG_MASK

SVN_CONFIG_OPTION_HTTP_AUTH_TYPES = _core.SVN_CONFIG_OPTION_HTTP_AUTH_TYPES

SVN_CONFIG_OPTION_SSL_AUTHORITY_FILES = _core.SVN_CONFIG_OPTION_SSL_AUTHORITY_FILES

SVN_CONFIG_OPTION_SSL_TRUST_DEFAULT_CA = _core.SVN_CONFIG_OPTION_SSL_TRUST_DEFAULT_CA

SVN_CONFIG_OPTION_SSL_CLIENT_CERT_FILE = _core.SVN_CONFIG_OPTION_SSL_CLIENT_CERT_FILE

SVN_CONFIG_OPTION_SSL_CLIENT_CERT_PASSWORD = _core.SVN_CONFIG_OPTION_SSL_CLIENT_CERT_PASSWORD

SVN_CONFIG_OPTION_SSL_PKCS11_PROVIDER = _core.SVN_CONFIG_OPTION_SSL_PKCS11_PROVIDER

SVN_CONFIG_OPTION_HTTP_LIBRARY = _core.SVN_CONFIG_OPTION_HTTP_LIBRARY

SVN_CONFIG_OPTION_STORE_PASSWORDS = _core.SVN_CONFIG_OPTION_STORE_PASSWORDS

SVN_CONFIG_OPTION_STORE_PLAINTEXT_PASSWORDS = _core.SVN_CONFIG_OPTION_STORE_PLAINTEXT_PASSWORDS

SVN_CONFIG_OPTION_STORE_AUTH_CREDS = _core.SVN_CONFIG_OPTION_STORE_AUTH_CREDS

SVN_CONFIG_OPTION_STORE_SSL_CLIENT_CERT_PP = _core.SVN_CONFIG_OPTION_STORE_SSL_CLIENT_CERT_PP

SVN_CONFIG_OPTION_STORE_SSL_CLIENT_CERT_PP_PLAINTEXT = _core.SVN_CONFIG_OPTION_STORE_SSL_CLIENT_CERT_PP_PLAINTEXT

SVN_CONFIG_OPTION_USERNAME = _core.SVN_CONFIG_OPTION_USERNAME

SVN_CONFIG_OPTION_HTTP_BULK_UPDATES = _core.SVN_CONFIG_OPTION_HTTP_BULK_UPDATES

SVN_CONFIG_OPTION_HTTP_MAX_CONNECTIONS = _core.SVN_CONFIG_OPTION_HTTP_MAX_CONNECTIONS

SVN_CONFIG_OPTION_HTTP_CHUNKED_REQUESTS = _core.SVN_CONFIG_OPTION_HTTP_CHUNKED_REQUESTS

SVN_CONFIG_OPTION_SERF_LOG_COMPONENTS = _core.SVN_CONFIG_OPTION_SERF_LOG_COMPONENTS

SVN_CONFIG_OPTION_SERF_LOG_LEVEL = _core.SVN_CONFIG_OPTION_SERF_LOG_LEVEL

SVN_CONFIG_CATEGORY_CONFIG = _core.SVN_CONFIG_CATEGORY_CONFIG

SVN_CONFIG_SECTION_AUTH = _core.SVN_CONFIG_SECTION_AUTH

SVN_CONFIG_OPTION_PASSWORD_STORES = _core.SVN_CONFIG_OPTION_PASSWORD_STORES

SVN_CONFIG_OPTION_KWALLET_WALLET = _core.SVN_CONFIG_OPTION_KWALLET_WALLET

SVN_CONFIG_OPTION_KWALLET_SVN_APPLICATION_NAME_WITH_PID = _core.SVN_CONFIG_OPTION_KWALLET_SVN_APPLICATION_NAME_WITH_PID

SVN_CONFIG_OPTION_SSL_CLIENT_CERT_FILE_PROMPT = _core.SVN_CONFIG_OPTION_SSL_CLIENT_CERT_FILE_PROMPT

SVN_CONFIG_SECTION_HELPERS = _core.SVN_CONFIG_SECTION_HELPERS

SVN_CONFIG_OPTION_EDITOR_CMD = _core.SVN_CONFIG_OPTION_EDITOR_CMD

SVN_CONFIG_OPTION_DIFF_CMD = _core.SVN_CONFIG_OPTION_DIFF_CMD

SVN_CONFIG_OPTION_DIFF_EXTENSIONS = _core.SVN_CONFIG_OPTION_DIFF_EXTENSIONS

SVN_CONFIG_OPTION_DIFF3_CMD = _core.SVN_CONFIG_OPTION_DIFF3_CMD

SVN_CONFIG_OPTION_DIFF3_HAS_PROGRAM_ARG = _core.SVN_CONFIG_OPTION_DIFF3_HAS_PROGRAM_ARG

SVN_CONFIG_OPTION_MERGE_TOOL_CMD = _core.SVN_CONFIG_OPTION_MERGE_TOOL_CMD

SVN_CONFIG_SECTION_MISCELLANY = _core.SVN_CONFIG_SECTION_MISCELLANY

SVN_CONFIG_OPTION_GLOBAL_IGNORES = _core.SVN_CONFIG_OPTION_GLOBAL_IGNORES

SVN_CONFIG_OPTION_LOG_ENCODING = _core.SVN_CONFIG_OPTION_LOG_ENCODING

SVN_CONFIG_OPTION_USE_COMMIT_TIMES = _core.SVN_CONFIG_OPTION_USE_COMMIT_TIMES

SVN_CONFIG_OPTION_TEMPLATE_ROOT = _core.SVN_CONFIG_OPTION_TEMPLATE_ROOT

SVN_CONFIG_OPTION_ENABLE_AUTO_PROPS = _core.SVN_CONFIG_OPTION_ENABLE_AUTO_PROPS

SVN_CONFIG_OPTION_ENABLE_MAGIC_FILE = _core.SVN_CONFIG_OPTION_ENABLE_MAGIC_FILE

SVN_CONFIG_OPTION_NO_UNLOCK = _core.SVN_CONFIG_OPTION_NO_UNLOCK

SVN_CONFIG_OPTION_MIMETYPES_FILE = _core.SVN_CONFIG_OPTION_MIMETYPES_FILE

SVN_CONFIG_OPTION_PRESERVED_CF_EXTS = _core.SVN_CONFIG_OPTION_PRESERVED_CF_EXTS

SVN_CONFIG_OPTION_INTERACTIVE_CONFLICTS = _core.SVN_CONFIG_OPTION_INTERACTIVE_CONFLICTS

SVN_CONFIG_OPTION_MEMORY_CACHE_SIZE = _core.SVN_CONFIG_OPTION_MEMORY_CACHE_SIZE

SVN_CONFIG_OPTION_DIFF_IGNORE_CONTENT_TYPE = _core.SVN_CONFIG_OPTION_DIFF_IGNORE_CONTENT_TYPE

SVN_CONFIG_SECTION_TUNNELS = _core.SVN_CONFIG_SECTION_TUNNELS

SVN_CONFIG_SECTION_AUTO_PROPS = _core.SVN_CONFIG_SECTION_AUTO_PROPS

SVN_CONFIG_SECTION_WORKING_COPY = _core.SVN_CONFIG_SECTION_WORKING_COPY

SVN_CONFIG_OPTION_SQLITE_EXCLUSIVE = _core.SVN_CONFIG_OPTION_SQLITE_EXCLUSIVE

SVN_CONFIG_OPTION_SQLITE_EXCLUSIVE_CLIENTS = _core.SVN_CONFIG_OPTION_SQLITE_EXCLUSIVE_CLIENTS

SVN_CONFIG_OPTION_SQLITE_BUSY_TIMEOUT = _core.SVN_CONFIG_OPTION_SQLITE_BUSY_TIMEOUT

SVN_CONFIG_SECTION_GENERAL = _core.SVN_CONFIG_SECTION_GENERAL

SVN_CONFIG_OPTION_ANON_ACCESS = _core.SVN_CONFIG_OPTION_ANON_ACCESS

SVN_CONFIG_OPTION_AUTH_ACCESS = _core.SVN_CONFIG_OPTION_AUTH_ACCESS

SVN_CONFIG_OPTION_PASSWORD_DB = _core.SVN_CONFIG_OPTION_PASSWORD_DB

SVN_CONFIG_OPTION_REALM = _core.SVN_CONFIG_OPTION_REALM

SVN_CONFIG_OPTION_AUTHZ_DB = _core.SVN_CONFIG_OPTION_AUTHZ_DB

SVN_CONFIG_OPTION_GROUPS_DB = _core.SVN_CONFIG_OPTION_GROUPS_DB

SVN_CONFIG_OPTION_FORCE_USERNAME_CASE = _core.SVN_CONFIG_OPTION_FORCE_USERNAME_CASE

SVN_CONFIG_OPTION_HOOKS_ENV = _core.SVN_CONFIG_OPTION_HOOKS_ENV

SVN_CONFIG_SECTION_SASL = _core.SVN_CONFIG_SECTION_SASL

SVN_CONFIG_OPTION_USE_SASL = _core.SVN_CONFIG_OPTION_USE_SASL

SVN_CONFIG_OPTION_MIN_SSF = _core.SVN_CONFIG_OPTION_MIN_SSF

SVN_CONFIG_OPTION_MAX_SSF = _core.SVN_CONFIG_OPTION_MAX_SSF

SVN_CONFIG_SECTION_USERS = _core.SVN_CONFIG_SECTION_USERS

SVN_CONFIG__DEFAULT_GLOBAL_IGNORES_LINE_1 = _core.SVN_CONFIG__DEFAULT_GLOBAL_IGNORES_LINE_1

SVN_CONFIG__DEFAULT_GLOBAL_IGNORES_LINE_2 = _core.SVN_CONFIG__DEFAULT_GLOBAL_IGNORES_LINE_2

SVN_CONFIG_DEFAULT_GLOBAL_IGNORES = _core.SVN_CONFIG_DEFAULT_GLOBAL_IGNORES

SVN_CONFIG_TRUE = _core.SVN_CONFIG_TRUE

SVN_CONFIG_FALSE = _core.SVN_CONFIG_FALSE

SVN_CONFIG_ASK = _core.SVN_CONFIG_ASK

SVN_CONFIG_DEFAULT_OPTION_STORE_PASSWORDS = _core.SVN_CONFIG_DEFAULT_OPTION_STORE_PASSWORDS

SVN_CONFIG_DEFAULT_OPTION_STORE_PLAINTEXT_PASSWORDS = _core.SVN_CONFIG_DEFAULT_OPTION_STORE_PLAINTEXT_PASSWORDS

SVN_CONFIG_DEFAULT_OPTION_STORE_AUTH_CREDS = _core.SVN_CONFIG_DEFAULT_OPTION_STORE_AUTH_CREDS

SVN_CONFIG_DEFAULT_OPTION_STORE_SSL_CLIENT_CERT_PP = _core.SVN_CONFIG_DEFAULT_OPTION_STORE_SSL_CLIENT_CERT_PP

SVN_CONFIG_DEFAULT_OPTION_STORE_SSL_CLIENT_CERT_PP_PLAINTEXT = _core.SVN_CONFIG_DEFAULT_OPTION_STORE_SSL_CLIENT_CERT_PP_PLAINTEXT

SVN_CONFIG_DEFAULT_OPTION_HTTP_MAX_CONNECTIONS = _core.SVN_CONFIG_DEFAULT_OPTION_HTTP_MAX_CONNECTIONS


def svn_config_get_config(*args):
    r"""svn_config_get_config(char const * config_dir, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_config_get_config(*args)

def svn_config_create2(*args):
    r"""svn_config_create2(svn_boolean_t section_names_case_sensitive, svn_boolean_t option_names_case_sensitive, apr_pool_t result_pool) -> svn_error_t"""
    return _core.svn_config_create2(*args)

def svn_config_create(*args):
    r"""svn_config_create(svn_boolean_t section_names_case_sensitive, apr_pool_t result_pool) -> svn_error_t"""
    return _core.svn_config_create(*args)

def svn_config_read3(*args):
    r"""svn_config_read3(char const * file, svn_boolean_t must_exist, svn_boolean_t section_names_case_sensitive, svn_boolean_t option_names_case_sensitive, apr_pool_t result_pool) -> svn_error_t"""
    return _core.svn_config_read3(*args)

def svn_config_read2(*args):
    r"""svn_config_read2(char const * file, svn_boolean_t must_exist, svn_boolean_t section_names_case_sensitive, apr_pool_t result_pool) -> svn_error_t"""
    return _core.svn_config_read2(*args)

def svn_config_read(*args):
    r"""svn_config_read(char const * file, svn_boolean_t must_exist, apr_pool_t result_pool) -> svn_error_t"""
    return _core.svn_config_read(*args)

def svn_config_parse(*args):
    r"""svn_config_parse(svn_stream_t stream, svn_boolean_t section_names_case_sensitive, svn_boolean_t option_names_case_sensitive, apr_pool_t result_pool) -> svn_error_t"""
    return _core.svn_config_parse(*args)

def svn_config_merge(cfg, file, must_exist):
    r"""svn_config_merge(svn_config_t cfg, char const * file, svn_boolean_t must_exist) -> svn_error_t"""
    return _core.svn_config_merge(cfg, file, must_exist)

def svn_config_get(cfg, section, option, default_value):
    r"""svn_config_get(svn_config_t cfg, char const * section, char const * option, char const * default_value)"""
    return _core.svn_config_get(cfg, section, option, default_value)

def svn_config_set(cfg, section, option, value):
    r"""svn_config_set(svn_config_t cfg, char const * section, char const * option, char const * value)"""
    return _core.svn_config_set(cfg, section, option, value)

def svn_config_get_bool(cfg, section, option, default_value):
    r"""svn_config_get_bool(svn_config_t cfg, char const * section, char const * option, svn_boolean_t default_value) -> svn_error_t"""
    return _core.svn_config_get_bool(cfg, section, option, default_value)

def svn_config_set_bool(cfg, section, option, value):
    r"""svn_config_set_bool(svn_config_t cfg, char const * section, char const * option, svn_boolean_t value)"""
    return _core.svn_config_set_bool(cfg, section, option, value)

def svn_config_get_int64(cfg, section, option, default_value):
    r"""svn_config_get_int64(svn_config_t cfg, char const * section, char const * option, apr_int64_t default_value) -> svn_error_t"""
    return _core.svn_config_get_int64(cfg, section, option, default_value)

def svn_config_set_int64(cfg, section, option, value):
    r"""svn_config_set_int64(svn_config_t cfg, char const * section, char const * option, apr_int64_t value)"""
    return _core.svn_config_set_int64(cfg, section, option, value)

def svn_config_get_yes_no_ask(cfg, section, option, default_value):
    r"""svn_config_get_yes_no_ask(svn_config_t cfg, char const * section, char const * option, char const * default_value) -> svn_error_t"""
    return _core.svn_config_get_yes_no_ask(cfg, section, option, default_value)

def svn_config_get_tristate(cfg, valuep, section, option, unknown_value, default_value):
    r"""svn_config_get_tristate(svn_config_t cfg, svn_tristate_t * valuep, char const * section, char const * option, char const * unknown_value, svn_tristate_t default_value) -> svn_error_t"""
    return _core.svn_config_get_tristate(cfg, valuep, section, option, unknown_value, default_value)

def svn_config_enumerate_sections(cfg, callback, baton):
    r"""svn_config_enumerate_sections(svn_config_t cfg, svn_config_section_enumerator_t callback, void * baton) -> int"""
    return _core.svn_config_enumerate_sections(cfg, callback, baton)

def svn_config_enumerate_sections2(*args):
    r"""svn_config_enumerate_sections2(svn_config_t cfg, svn_config_section_enumerator2_t callback, apr_pool_t pool) -> int"""
    return _core.svn_config_enumerate_sections2(*args)

def svn_config_enumerate(cfg, section, callback, baton):
    r"""svn_config_enumerate(svn_config_t cfg, char const * section, svn_config_enumerator_t callback, void * baton) -> int"""
    return _core.svn_config_enumerate(cfg, section, callback, baton)

def svn_config_enumerate2(*args):
    r"""svn_config_enumerate2(svn_config_t cfg, char const * section, svn_config_enumerator2_t callback, apr_pool_t pool) -> int"""
    return _core.svn_config_enumerate2(*args)

def svn_config_has_section(cfg, section):
    r"""svn_config_has_section(svn_config_t cfg, char const * section) -> svn_boolean_t"""
    return _core.svn_config_has_section(cfg, section)

def svn_config_find_group(*args):
    r"""svn_config_find_group(svn_config_t cfg, char const * key, char const * master_section, apr_pool_t pool) -> char const *"""
    return _core.svn_config_find_group(*args)

def svn_config_get_server_setting(cfg, server_group, option_name, default_value):
    r"""svn_config_get_server_setting(svn_config_t cfg, char const * server_group, char const * option_name, char const * default_value) -> char const *"""
    return _core.svn_config_get_server_setting(cfg, server_group, option_name, default_value)

def svn_config_get_server_setting_int(*args):
    r"""svn_config_get_server_setting_int(svn_config_t cfg, char const * server_group, char const * option_name, apr_int64_t default_value, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_config_get_server_setting_int(*args)

def svn_config_get_server_setting_bool(cfg, server_group, option_name, default_value):
    r"""svn_config_get_server_setting_bool(svn_config_t cfg, char const * server_group, char const * option_name, svn_boolean_t default_value) -> svn_error_t"""
    return _core.svn_config_get_server_setting_bool(cfg, server_group, option_name, default_value)

def svn_config_ensure(*args):
    r"""svn_config_ensure(char const * config_dir, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_config_ensure(*args)
SVN_CONFIG_REALMSTRING_KEY = _core.SVN_CONFIG_REALMSTRING_KEY

SVN_CONFIG_AUTHN_USERNAME_KEY = _core.SVN_CONFIG_AUTHN_USERNAME_KEY

SVN_CONFIG_AUTHN_PASSWORD_KEY = _core.SVN_CONFIG_AUTHN_PASSWORD_KEY

SVN_CONFIG_AUTHN_PASSPHRASE_KEY = _core.SVN_CONFIG_AUTHN_PASSPHRASE_KEY

SVN_CONFIG_AUTHN_PASSTYPE_KEY = _core.SVN_CONFIG_AUTHN_PASSTYPE_KEY

SVN_CONFIG_AUTHN_ASCII_CERT_KEY = _core.SVN_CONFIG_AUTHN_ASCII_CERT_KEY

SVN_CONFIG_AUTHN_FAILURES_KEY = _core.SVN_CONFIG_AUTHN_FAILURES_KEY


def svn_config_read_auth_data(*args):
    r"""svn_config_read_auth_data(char const * cred_kind, char const * realmstring, char const * config_dir, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_config_read_auth_data(*args)

def svn_config_write_auth_data(*args):
    r"""svn_config_write_auth_data(apr_hash_t hash, char const * cred_kind, char const * realmstring, char const * config_dir, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_config_write_auth_data(*args)

def svn_config_walk_auth_data(*args):
    r"""svn_config_walk_auth_data(char const * config_dir, svn_config_auth_walk_func_t walk_func, apr_pool_t scratch_pool) -> svn_error_t"""
    return _core.svn_config_walk_auth_data(*args)

def svn_config_get_user_config_path(*args):
    r"""svn_config_get_user_config_path(char const * config_dir, char const * fname, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_config_get_user_config_path(*args)

def svn_config_dup(*args):
    r"""svn_config_dup(svn_config_t src, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_config_dup(*args)

def svn_config_copy_config(*args):
    r"""svn_config_copy_config(apr_hash_t src_hash, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_config_copy_config(*args)
class svn_config_t(object):
    r"""Proxy of C svn_config_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


# Register svn_config_t in _core:
_core.svn_config_t_swigregister(svn_config_t)

def svn_config_invoke_section_enumerator(_obj, name, baton):
    r"""svn_config_invoke_section_enumerator(svn_config_section_enumerator_t _obj, char const * name, void * baton) -> svn_boolean_t"""
    return _core.svn_config_invoke_section_enumerator(_obj, name, baton)

def svn_config_invoke_section_enumerator2(*args):
    r"""svn_config_invoke_section_enumerator2(svn_config_section_enumerator2_t _obj, char const * name, void * baton, apr_pool_t pool) -> svn_boolean_t"""
    return _core.svn_config_invoke_section_enumerator2(*args)

def svn_config_invoke_enumerator(_obj, name, value, baton):
    r"""svn_config_invoke_enumerator(svn_config_enumerator_t _obj, char const * name, char const * value, void * baton) -> svn_boolean_t"""
    return _core.svn_config_invoke_enumerator(_obj, name, value, baton)

def svn_config_invoke_enumerator2(*args):
    r"""svn_config_invoke_enumerator2(svn_config_enumerator2_t _obj, char const * name, char const * value, void * baton, apr_pool_t pool) -> svn_boolean_t"""
    return _core.svn_config_invoke_enumerator2(*args)

def svn_config_invoke_auth_walk_func(*args):
    r"""svn_config_invoke_auth_walk_func(svn_config_auth_walk_func_t _obj, void * walk_baton, char const * cred_kind, char const * realmstring, apr_hash_t hash, apr_pool_t scratch_pool) -> svn_error_t"""
    return _core.svn_config_invoke_auth_walk_func(*args)
class svn_config_section_enumerator_t(object):
    r"""Proxy of C svn_config_section_enumerator_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_config_invoke_section_enumerator(self, *args)


# Register svn_config_section_enumerator_t in _core:
_core.svn_config_section_enumerator_t_swigregister(svn_config_section_enumerator_t)
class svn_config_section_enumerator2_t(object):
    r"""Proxy of C svn_config_section_enumerator2_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_config_invoke_section_enumerator2(self, *args)


# Register svn_config_section_enumerator2_t in _core:
_core.svn_config_section_enumerator2_t_swigregister(svn_config_section_enumerator2_t)
class svn_config_enumerator_t(object):
    r"""Proxy of C svn_config_enumerator_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_config_invoke_enumerator(self, *args)


# Register svn_config_enumerator_t in _core:
_core.svn_config_enumerator_t_swigregister(svn_config_enumerator_t)
class svn_config_enumerator2_t(object):
    r"""Proxy of C svn_config_enumerator2_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_config_invoke_enumerator2(self, *args)


# Register svn_config_enumerator2_t in _core:
_core.svn_config_enumerator2_t_swigregister(svn_config_enumerator2_t)
class svn_config_auth_walk_func_t(object):
    r"""Proxy of C svn_config_auth_walk_func_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_config_invoke_auth_walk_func(self, *args)


# Register svn_config_auth_walk_func_t in _core:
_core.svn_config_auth_walk_func_t_swigregister(svn_config_auth_walk_func_t)

def svn_utf_initialize2(*args):
    r"""svn_utf_initialize2(svn_boolean_t assume_native_utf8, apr_pool_t pool)"""
    return _core.svn_utf_initialize2(*args)

def svn_utf_initialize(*args):
    r"""svn_utf_initialize(apr_pool_t pool)"""
    return _core.svn_utf_initialize(*args)

def svn_utf_stringbuf_to_utf8(*args):
    r"""svn_utf_stringbuf_to_utf8(svn_stringbuf_t const * src, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_utf_stringbuf_to_utf8(*args)

def svn_utf_string_to_utf8(*args):
    r"""svn_utf_string_to_utf8(svn_string_t const * src, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_utf_string_to_utf8(*args)

def svn_utf_cstring_to_utf8(*args):
    r"""svn_utf_cstring_to_utf8(char const * src, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_utf_cstring_to_utf8(*args)

def svn_utf_cstring_to_utf8_ex2(*args):
    r"""svn_utf_cstring_to_utf8_ex2(char const * src, char const * frompage, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_utf_cstring_to_utf8_ex2(*args)

def svn_utf_cstring_to_utf8_ex(*args):
    r"""svn_utf_cstring_to_utf8_ex(char const * src, char const * frompage, char const * convset_key, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_utf_cstring_to_utf8_ex(*args)

def svn_utf_stringbuf_from_utf8(*args):
    r"""svn_utf_stringbuf_from_utf8(svn_stringbuf_t const * src, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_utf_stringbuf_from_utf8(*args)

def svn_utf_string_from_utf8(*args):
    r"""svn_utf_string_from_utf8(svn_string_t const * src, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_utf_string_from_utf8(*args)

def svn_utf_cstring_from_utf8(*args):
    r"""svn_utf_cstring_from_utf8(char const * src, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_utf_cstring_from_utf8(*args)

def svn_utf_cstring_from_utf8_ex2(*args):
    r"""svn_utf_cstring_from_utf8_ex2(char const * src, char const * topage, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_utf_cstring_from_utf8_ex2(*args)

def svn_utf_cstring_from_utf8_ex(*args):
    r"""svn_utf_cstring_from_utf8_ex(char const * src, char const * topage, char const * convset_key, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_utf_cstring_from_utf8_ex(*args)

def svn_utf_cstring_from_utf8_fuzzy(*args):
    r"""svn_utf_cstring_from_utf8_fuzzy(char const * src, apr_pool_t pool) -> char const *"""
    return _core.svn_utf_cstring_from_utf8_fuzzy(*args)

def svn_utf_cstring_from_utf8_stringbuf(*args):
    r"""svn_utf_cstring_from_utf8_stringbuf(svn_stringbuf_t const * src, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_utf_cstring_from_utf8_stringbuf(*args)

def svn_utf_cstring_from_utf8_string(*args):
    r"""svn_utf_cstring_from_utf8_string(svn_string_t const * src, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_utf_cstring_from_utf8_string(*args)

def svn_utf_cstring_utf8_width(cstr):
    r"""svn_utf_cstring_utf8_width(char const * cstr) -> int"""
    return _core.svn_utf_cstring_utf8_width(cstr)

def svn_nls_init():
    r"""svn_nls_init() -> svn_error_t"""
    return _core.svn_nls_init()

def svn_path_internal_style(*args):
    r"""svn_path_internal_style(char const * path, apr_pool_t pool) -> char const *"""
    return _core.svn_path_internal_style(*args)

def svn_path_local_style(*args):
    r"""svn_path_local_style(char const * path, apr_pool_t pool) -> char const *"""
    return _core.svn_path_local_style(*args)

def svn_path_splitext(*args):
    r"""svn_path_splitext(char const * path, apr_pool_t pool)"""
    return _core.svn_path_splitext(*args)

def svn_path_is_empty(path):
    r"""svn_path_is_empty(char const * path) -> int"""
    return _core.svn_path_is_empty(path)

def svn_dirent_is_root(dirent, len):
    r"""svn_dirent_is_root(char const * dirent, apr_size_t len) -> svn_boolean_t"""
    return _core.svn_dirent_is_root(dirent, len)

def svn_path_canonicalize(*args):
    r"""svn_path_canonicalize(char const * path, apr_pool_t pool) -> char const *"""
    return _core.svn_path_canonicalize(*args)

def svn_path_is_canonical(*args):
    r"""svn_path_is_canonical(char const * path, apr_pool_t pool) -> svn_boolean_t"""
    return _core.svn_path_is_canonical(*args)

def svn_path_compare_paths(path1, path2):
    r"""svn_path_compare_paths(char const * path1, char const * path2) -> int"""
    return _core.svn_path_compare_paths(path1, path2)

def svn_path_get_longest_ancestor(*args):
    r"""svn_path_get_longest_ancestor(char const * path1, char const * path2, apr_pool_t pool) -> char *"""
    return _core.svn_path_get_longest_ancestor(*args)

def svn_path_is_dotpath_present(path):
    r"""svn_path_is_dotpath_present(char const * path) -> svn_boolean_t"""
    return _core.svn_path_is_dotpath_present(path)

def svn_path_is_url(path):
    r"""svn_path_is_url(char const * path) -> svn_boolean_t"""
    return _core.svn_path_is_url(path)

def svn_path_is_uri_safe(path):
    r"""svn_path_is_uri_safe(char const * path) -> svn_boolean_t"""
    return _core.svn_path_is_uri_safe(path)

def svn_path_url_add_component2(*args):
    r"""svn_path_url_add_component2(char const * url, char const * component, apr_pool_t pool) -> char const *"""
    return _core.svn_path_url_add_component2(*args)

def svn_path_is_repos_relative_url(path):
    r"""svn_path_is_repos_relative_url(char const * path) -> svn_boolean_t"""
    return _core.svn_path_is_repos_relative_url(path)

def svn_path_resolve_repos_relative_url(*args):
    r"""svn_path_resolve_repos_relative_url(char const * relative_url, char const * repos_root_url, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_path_resolve_repos_relative_url(*args)

def svn_path_illegal_path_escape(*args):
    r"""svn_path_illegal_path_escape(char const * path, apr_pool_t pool) -> char const *"""
    return _core.svn_path_illegal_path_escape(*args)

def svn_dirent_internal_style(*args):
    r"""svn_dirent_internal_style(char const * dirent, apr_pool_t result_pool) -> char const *"""
    return _core.svn_dirent_internal_style(*args)

def svn_dirent_internal_style_safe(*args):
    r"""svn_dirent_internal_style_safe(char const * dirent, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _core.svn_dirent_internal_style_safe(*args)

def svn_dirent_local_style(*args):
    r"""svn_dirent_local_style(char const * dirent, apr_pool_t result_pool) -> char const *"""
    return _core.svn_dirent_local_style(*args)

def svn_dirent_join(*args):
    r"""svn_dirent_join(char const * base, char const * component, apr_pool_t result_pool) -> char *"""
    return _core.svn_dirent_join(*args)

def svn_relpath_join(*args):
    r"""svn_relpath_join(char const * base, char const * component, apr_pool_t result_pool) -> char *"""
    return _core.svn_relpath_join(*args)

def svn_dirent_basename(*args):
    r"""svn_dirent_basename(char const * dirent, apr_pool_t result_pool) -> char const *"""
    return _core.svn_dirent_basename(*args)

def svn_dirent_dirname(*args):
    r"""svn_dirent_dirname(char const * dirent, apr_pool_t result_pool) -> char *"""
    return _core.svn_dirent_dirname(*args)

def svn_dirent_split(*args):
    r"""svn_dirent_split(char const * dirent, apr_pool_t result_pool)"""
    return _core.svn_dirent_split(*args)

def svn_relpath_split(*args):
    r"""svn_relpath_split(char const * relpath, apr_pool_t result_pool)"""
    return _core.svn_relpath_split(*args)

def svn_relpath_basename(*args):
    r"""svn_relpath_basename(char const * relpath, apr_pool_t result_pool) -> char const *"""
    return _core.svn_relpath_basename(*args)

def svn_relpath_dirname(*args):
    r"""svn_relpath_dirname(char const * relpath, apr_pool_t result_pool) -> char *"""
    return _core.svn_relpath_dirname(*args)

def svn_relpath_prefix(*args):
    r"""svn_relpath_prefix(char const * relpath, int max_components, apr_pool_t result_pool) -> char const *"""
    return _core.svn_relpath_prefix(*args)

def svn_uri_split(*args):
    r"""svn_uri_split(char const * uri, apr_pool_t result_pool)"""
    return _core.svn_uri_split(*args)

def svn_uri_basename(*args):
    r"""svn_uri_basename(char const * uri, apr_pool_t result_pool) -> char const *"""
    return _core.svn_uri_basename(*args)

def svn_uri_dirname(*args):
    r"""svn_uri_dirname(char const * uri, apr_pool_t result_pool) -> char *"""
    return _core.svn_uri_dirname(*args)

def svn_dirent_is_absolute(dirent):
    r"""svn_dirent_is_absolute(char const * dirent) -> svn_boolean_t"""
    return _core.svn_dirent_is_absolute(dirent)

def svn_uri_is_root(uri, len):
    r"""svn_uri_is_root(char const * uri, apr_size_t len) -> svn_boolean_t"""
    return _core.svn_uri_is_root(uri, len)

def svn_dirent_canonicalize(*args):
    r"""svn_dirent_canonicalize(char const * dirent, apr_pool_t result_pool) -> char const *"""
    return _core.svn_dirent_canonicalize(*args)

def svn_dirent_canonicalize_safe(*args):
    r"""svn_dirent_canonicalize_safe(char const * dirent, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _core.svn_dirent_canonicalize_safe(*args)

def svn_relpath_canonicalize(*args):
    r"""svn_relpath_canonicalize(char const * relpath, apr_pool_t result_pool) -> char const *"""
    return _core.svn_relpath_canonicalize(*args)

def svn_relpath_canonicalize_safe(*args):
    r"""svn_relpath_canonicalize_safe(char const * relpath, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _core.svn_relpath_canonicalize_safe(*args)

def svn_uri_canonicalize(*args):
    r"""svn_uri_canonicalize(char const * uri, apr_pool_t result_pool) -> char const *"""
    return _core.svn_uri_canonicalize(*args)

def svn_uri_canonicalize_safe(*args):
    r"""svn_uri_canonicalize_safe(char const * uri, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _core.svn_uri_canonicalize_safe(*args)

def svn_dirent_is_canonical(*args):
    r"""svn_dirent_is_canonical(char const * dirent, apr_pool_t scratch_pool) -> svn_boolean_t"""
    return _core.svn_dirent_is_canonical(*args)

def svn_relpath_is_canonical(relpath):
    r"""svn_relpath_is_canonical(char const * relpath) -> svn_boolean_t"""
    return _core.svn_relpath_is_canonical(relpath)

def svn_uri_is_canonical(*args):
    r"""svn_uri_is_canonical(char const * uri, apr_pool_t scratch_pool) -> svn_boolean_t"""
    return _core.svn_uri_is_canonical(*args)

def svn_dirent_get_longest_ancestor(*args):
    r"""svn_dirent_get_longest_ancestor(char const * dirent1, char const * dirent2, apr_pool_t result_pool) -> char *"""
    return _core.svn_dirent_get_longest_ancestor(*args)

def svn_relpath_get_longest_ancestor(*args):
    r"""svn_relpath_get_longest_ancestor(char const * relpath1, char const * relpath2, apr_pool_t result_pool) -> char *"""
    return _core.svn_relpath_get_longest_ancestor(*args)

def svn_uri_get_longest_ancestor(*args):
    r"""svn_uri_get_longest_ancestor(char const * uri1, char const * uri2, apr_pool_t result_pool) -> char *"""
    return _core.svn_uri_get_longest_ancestor(*args)

def svn_dirent_get_absolute(*args):
    r"""svn_dirent_get_absolute(char const * relative, apr_pool_t result_pool) -> svn_error_t"""
    return _core.svn_dirent_get_absolute(*args)

def svn_dirent_is_child(*args):
    r"""svn_dirent_is_child(char const * parent_dirent, char const * child_dirent, apr_pool_t result_pool) -> char const *"""
    return _core.svn_dirent_is_child(*args)

def svn_dirent_is_ancestor(parent_dirent, child_dirent):
    r"""svn_dirent_is_ancestor(char const * parent_dirent, char const * child_dirent) -> svn_boolean_t"""
    return _core.svn_dirent_is_ancestor(parent_dirent, child_dirent)

def svn_uri__is_ancestor(parent_uri, child_uri):
    r"""svn_uri__is_ancestor(char const * parent_uri, char const * child_uri) -> svn_boolean_t"""
    return _core.svn_uri__is_ancestor(parent_uri, child_uri)

def svn_dirent_skip_ancestor(parent_dirent, child_dirent):
    r"""svn_dirent_skip_ancestor(char const * parent_dirent, char const * child_dirent) -> char const *"""
    return _core.svn_dirent_skip_ancestor(parent_dirent, child_dirent)

def svn_relpath_skip_ancestor(parent_relpath, child_relpath):
    r"""svn_relpath_skip_ancestor(char const * parent_relpath, char const * child_relpath) -> char const *"""
    return _core.svn_relpath_skip_ancestor(parent_relpath, child_relpath)

def svn_uri_skip_ancestor(*args):
    r"""svn_uri_skip_ancestor(char const * parent_uri, char const * child_uri, apr_pool_t result_pool) -> char const *"""
    return _core.svn_uri_skip_ancestor(*args)

def svn_uri_get_dirent_from_file_url(*args):
    r"""svn_uri_get_dirent_from_file_url(char const * url, apr_pool_t result_pool) -> svn_error_t"""
    return _core.svn_uri_get_dirent_from_file_url(*args)

def svn_uri_get_file_url_from_dirent(*args):
    r"""svn_uri_get_file_url_from_dirent(char const * dirent, apr_pool_t result_pool) -> svn_error_t"""
    return _core.svn_uri_get_file_url_from_dirent(*args)
SVN_MERGEINFO_NONINHERITABLE_STR = _core.SVN_MERGEINFO_NONINHERITABLE_STR


def svn_mergeinfo_parse(*args):
    r"""svn_mergeinfo_parse(char const * input, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_mergeinfo_parse(*args)

def svn_mergeinfo_diff2(*args):
    r"""svn_mergeinfo_diff2(apr_hash_t mergefrom, apr_hash_t mergeto, svn_boolean_t consider_inheritance, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _core.svn_mergeinfo_diff2(*args)

def svn_mergeinfo_diff(*args):
    r"""svn_mergeinfo_diff(apr_hash_t mergefrom, apr_hash_t mergeto, svn_boolean_t consider_inheritance, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_mergeinfo_diff(*args)

def svn_mergeinfo_merge2(*args):
    r"""svn_mergeinfo_merge2(apr_hash_t mergeinfo, apr_hash_t changes, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _core.svn_mergeinfo_merge2(*args)

def svn_mergeinfo_catalog_merge(*args):
    r"""svn_mergeinfo_catalog_merge(apr_hash_t mergeinfo_catalog, apr_hash_t changes_catalog, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _core.svn_mergeinfo_catalog_merge(*args)

def svn_mergeinfo_remove(*args):
    r"""svn_mergeinfo_remove(apr_hash_t eraser, apr_hash_t whiteboard, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_mergeinfo_remove(*args)

def svn_mergeinfo_remove2(*args):
    r"""svn_mergeinfo_remove2(apr_hash_t eraser, apr_hash_t whiteboard, svn_boolean_t consider_inheritance, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _core.svn_mergeinfo_remove2(*args)

def svn_rangelist_diff(*args):
    r"""svn_rangelist_diff(apr_array_header_t _from, apr_array_header_t to, svn_boolean_t consider_inheritance, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_rangelist_diff(*args)

def svn_rangelist_merge2(*args):
    r"""svn_rangelist_merge2(apr_array_header_t rangelist, apr_array_header_t changes, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _core.svn_rangelist_merge2(*args)

def svn_rangelist_remove(*args):
    r"""svn_rangelist_remove(apr_array_header_t eraser, apr_array_header_t whiteboard, svn_boolean_t consider_inheritance, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_rangelist_remove(*args)

def svn_mergeinfo_intersect2(*args):
    r"""svn_mergeinfo_intersect2(apr_hash_t mergeinfo1, apr_hash_t mergeinfo2, svn_boolean_t consider_inheritance, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _core.svn_mergeinfo_intersect2(*args)

def svn_mergeinfo_intersect(*args):
    r"""svn_mergeinfo_intersect(apr_hash_t mergeinfo1, apr_hash_t mergeinfo2, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_mergeinfo_intersect(*args)

def svn_rangelist_intersect(*args):
    r"""svn_rangelist_intersect(apr_array_header_t rangelist1, apr_array_header_t rangelist2, svn_boolean_t consider_inheritance, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_rangelist_intersect(*args)

def svn_rangelist_to_string(*args):
    r"""svn_rangelist_to_string(apr_array_header_t rangelist, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_rangelist_to_string(*args)

def svn_rangelist_inheritable2(*args):
    r"""svn_rangelist_inheritable2(apr_array_header_t rangelist, svn_revnum_t start, svn_revnum_t end, svn_boolean_t inheritable, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _core.svn_rangelist_inheritable2(*args)

def svn_rangelist_inheritable(*args):
    r"""svn_rangelist_inheritable(apr_array_header_t rangelist, svn_revnum_t start, svn_revnum_t end, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_rangelist_inheritable(*args)

def svn_mergeinfo_inheritable2(*args):
    r"""svn_mergeinfo_inheritable2(apr_hash_t mergeinfo, char const * path, svn_revnum_t start, svn_revnum_t end, svn_boolean_t inheritable, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _core.svn_mergeinfo_inheritable2(*args)

def svn_mergeinfo_inheritable(*args):
    r"""svn_mergeinfo_inheritable(apr_hash_t mergeinfo, char const * path, svn_revnum_t start, svn_revnum_t end, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_mergeinfo_inheritable(*args)

def svn_mergeinfo_to_string(*args):
    r"""svn_mergeinfo_to_string(apr_hash_t mergeinput, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_mergeinfo_to_string(*args)

def svn_mergeinfo_catalog_dup(*args):
    r"""svn_mergeinfo_catalog_dup(apr_hash_t mergeinfo_catalog, apr_pool_t pool) -> apr_hash_t"""
    return _core.svn_mergeinfo_catalog_dup(*args)

def svn_mergeinfo_dup(*args):
    r"""svn_mergeinfo_dup(apr_hash_t mergeinfo, apr_pool_t pool) -> apr_hash_t"""
    return _core.svn_mergeinfo_dup(*args)

def svn_rangelist_dup(*args):
    r"""svn_rangelist_dup(apr_array_header_t rangelist, apr_pool_t pool) -> apr_array_header_t"""
    return _core.svn_rangelist_dup(*args)
svn_mergeinfo_explicit = _core.svn_mergeinfo_explicit

svn_mergeinfo_inherited = _core.svn_mergeinfo_inherited

svn_mergeinfo_nearest_ancestor = _core.svn_mergeinfo_nearest_ancestor


def svn_inheritance_to_word(inherit):
    r"""svn_inheritance_to_word(svn_mergeinfo_inheritance_t inherit) -> char const *"""
    return _core.svn_inheritance_to_word(inherit)

def svn_inheritance_from_word(word):
    r"""svn_inheritance_from_word(char const * word) -> svn_mergeinfo_inheritance_t"""
    return _core.svn_inheritance_from_word(word)
svn_io_file_del_none = _core.svn_io_file_del_none

svn_io_file_del_on_close = _core.svn_io_file_del_on_close

svn_io_file_del_on_pool_cleanup = _core.svn_io_file_del_on_pool_cleanup

class svn_io_dirent2_t(object):
    r"""Proxy of C svn_io_dirent2_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    kind = property(_core.svn_io_dirent2_t_kind_get, _core.svn_io_dirent2_t_kind_set, doc=r"""kind : svn_node_kind_t""")
    special = property(_core.svn_io_dirent2_t_special_get, _core.svn_io_dirent2_t_special_set, doc=r"""special : svn_boolean_t""")
    filesize = property(_core.svn_io_dirent2_t_filesize_get, _core.svn_io_dirent2_t_filesize_set, doc=r"""filesize : svn_filesize_t""")
    mtime = property(_core.svn_io_dirent2_t_mtime_get, _core.svn_io_dirent2_t_mtime_set, doc=r"""mtime : apr_time_t""")
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __init__(self):
        r"""__init__(svn_io_dirent2_t self) -> svn_io_dirent2_t"""
        _core.svn_io_dirent2_t_swiginit(self, _core.new_svn_io_dirent2_t())
    __swig_destroy__ = _core.delete_svn_io_dirent2_t

# Register svn_io_dirent2_t in _core:
_core.svn_io_dirent2_t_swigregister(svn_io_dirent2_t)

def svn_io_dirent2_create(*args):
    r"""svn_io_dirent2_create(apr_pool_t result_pool) -> svn_io_dirent2_t"""
    return _core.svn_io_dirent2_create(*args)

def svn_io_dirent2_dup(*args):
    r"""svn_io_dirent2_dup(svn_io_dirent2_t item, apr_pool_t result_pool) -> svn_io_dirent2_t"""
    return _core.svn_io_dirent2_dup(*args)
class svn_io_dirent_t(object):
    r"""Proxy of C svn_io_dirent_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    kind = property(_core.svn_io_dirent_t_kind_get, _core.svn_io_dirent_t_kind_set, doc=r"""kind : svn_node_kind_t""")
    special = property(_core.svn_io_dirent_t_special_get, _core.svn_io_dirent_t_special_set, doc=r"""special : svn_boolean_t""")
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __init__(self):
        r"""__init__(svn_io_dirent_t self) -> svn_io_dirent_t"""
        _core.svn_io_dirent_t_swiginit(self, _core.new_svn_io_dirent_t())
    __swig_destroy__ = _core.delete_svn_io_dirent_t

# Register svn_io_dirent_t in _core:
_core.svn_io_dirent_t_swigregister(svn_io_dirent_t)

def svn_io_open_uniquely_named(*args):
    r"""svn_io_open_uniquely_named(char const * dirpath, char const * filename, char const * suffix, svn_io_file_del_t delete_when, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _core.svn_io_open_uniquely_named(*args)

def svn_io_open_unique_file3(*args):
    r"""svn_io_open_unique_file3(char const * dirpath, svn_io_file_del_t delete_when, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _core.svn_io_open_unique_file3(*args)

def svn_io_open_unique_file2(*args):
    r"""svn_io_open_unique_file2(char const * path, char const * suffix, svn_io_file_del_t delete_when, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_io_open_unique_file2(*args)

def svn_io_open_unique_file(*args):
    r"""svn_io_open_unique_file(char const * path, char const * suffix, svn_boolean_t delete_on_close, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_io_open_unique_file(*args)

def svn_io_copy_perms(*args):
    r"""svn_io_copy_perms(char const * src, char const * dst, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_io_copy_perms(*args)

def svn_io_sleep_for_timestamps(*args):
    r"""svn_io_sleep_for_timestamps(char const * path, apr_pool_t pool)"""
    return _core.svn_io_sleep_for_timestamps(*args)

def svn_io_filesizes_three_different_p(*args):
    r"""svn_io_filesizes_three_different_p(char const * file1, char const * file2, char const * file3, apr_pool_t scratch_pool) -> svn_error_t"""
    return _core.svn_io_filesizes_three_different_p(*args)

def svn_io_file_checksum2(*args):
    r"""svn_io_file_checksum2(char const * file, svn_checksum_kind_t kind, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_io_file_checksum2(*args)

def svn_io_file_checksum(*args):
    r"""svn_io_file_checksum(char const * file, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_io_file_checksum(*args)

def svn_io_files_contents_same_p(*args):
    r"""svn_io_files_contents_same_p(char const * file1, char const * file2, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_io_files_contents_same_p(*args)

def svn_io_files_contents_three_same_p(*args):
    r"""svn_io_files_contents_three_same_p(char const * file1, char const * file2, char const * file3, apr_pool_t scratch_pool) -> svn_error_t"""
    return _core.svn_io_files_contents_three_same_p(*args)

def svn_io_file_create_bytes(*args):
    r"""svn_io_file_create_bytes(char const * file, void const * contents, apr_size_t length, apr_pool_t scratch_pool) -> svn_error_t"""
    return _core.svn_io_file_create_bytes(*args)

def svn_io_file_create_empty(*args):
    r"""svn_io_file_create_empty(char const * file, apr_pool_t scratch_pool) -> svn_error_t"""
    return _core.svn_io_file_create_empty(*args)

def svn_io_lock_open_file(*args):
    r"""svn_io_lock_open_file(apr_file_t lockfile_handle, svn_boolean_t exclusive, svn_boolean_t nonblocking, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_io_lock_open_file(*args)

def svn_io_unlock_open_file(*args):
    r"""svn_io_unlock_open_file(apr_file_t lockfile_handle, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_io_unlock_open_file(*args)

def svn_stream_set_read2(stream, read_fn, read_full_fn):
    r"""svn_stream_set_read2(svn_stream_t stream, svn_read_fn_t read_fn, svn_read_fn_t read_full_fn)"""
    return _core.svn_stream_set_read2(stream, read_fn, read_full_fn)

def svn_stream_set_skip(stream, skip_fn):
    r"""svn_stream_set_skip(svn_stream_t stream, svn_stream_skip_fn_t skip_fn)"""
    return _core.svn_stream_set_skip(stream, skip_fn)

def svn_stream_set_mark(stream, mark_fn):
    r"""svn_stream_set_mark(svn_stream_t stream, svn_stream_mark_fn_t mark_fn)"""
    return _core.svn_stream_set_mark(stream, mark_fn)

def svn_stream_set_seek(stream, seek_fn):
    r"""svn_stream_set_seek(svn_stream_t stream, svn_stream_seek_fn_t seek_fn)"""
    return _core.svn_stream_set_seek(stream, seek_fn)

def svn_stream_set_data_available(stream, data_available):
    r"""svn_stream_set_data_available(svn_stream_t stream, svn_stream_data_available_fn_t data_available)"""
    return _core.svn_stream_set_data_available(stream, data_available)

def svn_stream_set_readline(stream, readline_fn):
    r"""svn_stream_set_readline(svn_stream_t stream, svn_stream_readline_fn_t readline_fn)"""
    return _core.svn_stream_set_readline(stream, readline_fn)

def svn_stream_empty(*args):
    r"""svn_stream_empty(apr_pool_t pool) -> svn_stream_t"""
    return _core.svn_stream_empty(*args)

def svn_stream_disown(*args):
    r"""svn_stream_disown(svn_stream_t stream, apr_pool_t pool) -> svn_stream_t"""
    return _core.svn_stream_disown(*args)

def svn_stream_open_readonly(*args):
    r"""svn_stream_open_readonly(char const * path, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _core.svn_stream_open_readonly(*args)

def svn_stream_open_writable(*args):
    r"""svn_stream_open_writable(char const * path, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _core.svn_stream_open_writable(*args)

def svn_stream_open_unique(*args):
    r"""svn_stream_open_unique(char const * dirpath, svn_io_file_del_t delete_when, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _core.svn_stream_open_unique(*args)

def svn_stream_from_aprfile2(*args):
    r"""svn_stream_from_aprfile2(apr_file_t file, svn_boolean_t disown, apr_pool_t pool) -> svn_stream_t"""
    return _core.svn_stream_from_aprfile2(*args)

def svn_stream_from_aprfile(*args):
    r"""svn_stream_from_aprfile(apr_file_t file, apr_pool_t pool) -> svn_stream_t"""
    return _core.svn_stream_from_aprfile(*args)

def svn_stream_for_stdin2(*args):
    r"""svn_stream_for_stdin2(svn_boolean_t buffered, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_stream_for_stdin2(*args)

def svn_stream_for_stdin(*args):
    r"""svn_stream_for_stdin(apr_pool_t pool) -> svn_error_t"""
    return _core.svn_stream_for_stdin(*args)

def svn_stream_for_stderr(*args):
    r"""svn_stream_for_stderr(apr_pool_t pool) -> svn_error_t"""
    return _core.svn_stream_for_stderr(*args)

def svn_stream_for_stdout(*args):
    r"""svn_stream_for_stdout(apr_pool_t pool) -> svn_error_t"""
    return _core.svn_stream_for_stdout(*args)

def svn_stringbuf_from_stream(*args):
    r"""svn_stringbuf_from_stream(svn_stream_t stream, apr_size_t len_hint, apr_pool_t result_pool) -> svn_error_t"""
    return _core.svn_stringbuf_from_stream(*args)

def svn_stream_from_stringbuf(*args):
    r"""svn_stream_from_stringbuf(svn_stringbuf_t * str, apr_pool_t pool) -> svn_stream_t"""
    return _core.svn_stream_from_stringbuf(*args)

def svn_stream_from_string(*args):
    r"""svn_stream_from_string(svn_string_t const * str, apr_pool_t pool) -> svn_stream_t"""
    return _core.svn_stream_from_string(*args)

def svn_stream_buffered(*args):
    r"""svn_stream_buffered(apr_pool_t result_pool) -> svn_stream_t"""
    return _core.svn_stream_buffered(*args)

def svn_stream_compressed(*args):
    r"""svn_stream_compressed(svn_stream_t stream, apr_pool_t pool) -> svn_stream_t"""
    return _core.svn_stream_compressed(*args)

def svn_stream_checksummed2(*args):
    r"""svn_stream_checksummed2(svn_stream_t stream, svn_checksum_kind_t checksum_kind, svn_boolean_t read_all, apr_pool_t pool) -> svn_stream_t"""
    return _core.svn_stream_checksummed2(*args)

def svn_stream_contents_checksum(*args):
    r"""svn_stream_contents_checksum(svn_stream_t stream, svn_checksum_kind_t kind, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _core.svn_stream_contents_checksum(*args)

def svn_stream_read_full(stream, buffer):
    r"""svn_stream_read_full(svn_stream_t stream, char * buffer) -> svn_error_t"""
    return _core.svn_stream_read_full(stream, buffer)

def svn_stream_supports_partial_read(stream):
    r"""svn_stream_supports_partial_read(svn_stream_t stream) -> svn_boolean_t"""
    return _core.svn_stream_supports_partial_read(stream)

def svn_stream_read2(stream, buffer):
    r"""svn_stream_read2(svn_stream_t stream, char * buffer) -> svn_error_t"""
    return _core.svn_stream_read2(stream, buffer)

def svn_stream_read(stream, buffer):
    r"""svn_stream_read(svn_stream_t stream, char * buffer) -> svn_error_t"""
    return _core.svn_stream_read(stream, buffer)

def svn_stream_skip(stream, len):
    r"""svn_stream_skip(svn_stream_t stream, apr_size_t len) -> svn_error_t"""
    return _core.svn_stream_skip(stream, len)

def svn_stream_write(stream, data):
    r"""svn_stream_write(svn_stream_t stream, char const * data) -> svn_error_t"""
    return _core.svn_stream_write(stream, data)

def svn_stream_close(stream):
    r"""svn_stream_close(svn_stream_t stream) -> svn_error_t"""
    return _core.svn_stream_close(stream)

def svn_stream_reset(stream):
    r"""svn_stream_reset(svn_stream_t stream) -> svn_error_t"""
    return _core.svn_stream_reset(stream)

def svn_stream_supports_mark(stream):
    r"""svn_stream_supports_mark(svn_stream_t stream) -> svn_boolean_t"""
    return _core.svn_stream_supports_mark(stream)

def svn_stream_supports_reset(stream):
    r"""svn_stream_supports_reset(svn_stream_t stream) -> svn_boolean_t"""
    return _core.svn_stream_supports_reset(stream)

def svn_stream_mark(*args):
    r"""svn_stream_mark(svn_stream_t stream, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_stream_mark(*args)

def svn_stream_seek(stream, mark):
    r"""svn_stream_seek(svn_stream_t stream, svn_stream_mark_t mark) -> svn_error_t"""
    return _core.svn_stream_seek(stream, mark)

def svn_stream_data_available(stream):
    r"""svn_stream_data_available(svn_stream_t stream) -> svn_error_t"""
    return _core.svn_stream_data_available(stream)

def svn_stream_tee(*args):
    r"""svn_stream_tee(svn_stream_t out1, svn_stream_t out2, apr_pool_t pool) -> svn_stream_t"""
    return _core.svn_stream_tee(*args)

def svn_stream_puts(stream, str):
    r"""svn_stream_puts(svn_stream_t stream, char const * str) -> svn_error_t"""
    return _core.svn_stream_puts(stream, str)

def svn_stream_readline(*args):
    r"""svn_stream_readline(svn_stream_t stream, char const * eol, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_stream_readline(*args)

def svn_stream_copy3(*args):
    r"""svn_stream_copy3(svn_stream_t _from, svn_stream_t to, svn_cancel_func_t cancel_func, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_stream_copy3(*args)

def svn_stream_copy2(*args):
    r"""svn_stream_copy2(svn_stream_t _from, svn_stream_t to, svn_cancel_func_t cancel_func, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_stream_copy2(*args)

def svn_stream_copy(*args):
    r"""svn_stream_copy(svn_stream_t _from, svn_stream_t to, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_stream_copy(*args)

def svn_stream_contents_same2(*args):
    r"""svn_stream_contents_same2(svn_stream_t stream1, svn_stream_t stream2, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_stream_contents_same2(*args)

def svn_stream_contents_same(*args):
    r"""svn_stream_contents_same(svn_stream_t stream1, svn_stream_t stream2, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_stream_contents_same(*args)

def svn_string_from_stream2(*args):
    r"""svn_string_from_stream2(svn_stream_t stream, apr_size_t len_hint, apr_pool_t result_pool) -> svn_error_t"""
    return _core.svn_string_from_stream2(*args)

def svn_string_from_stream(*args):
    r"""svn_string_from_stream(svn_stream_t stream, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _core.svn_string_from_stream(*args)

def svn_stream_lazyopen_create(*args):
    r"""svn_stream_lazyopen_create(svn_stream_lazyopen_func_t open_func, void * open_baton, svn_boolean_t open_on_close, apr_pool_t result_pool) -> svn_stream_t"""
    return _core.svn_stream_lazyopen_create(*args)

def svn_stringbuf_from_file2(*args):
    r"""svn_stringbuf_from_file2(char const * filename, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_stringbuf_from_file2(*args)

def svn_stringbuf_from_file(*args):
    r"""svn_stringbuf_from_file(char const * filename, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_stringbuf_from_file(*args)

def svn_stringbuf_from_aprfile(*args):
    r"""svn_stringbuf_from_aprfile(apr_file_t file, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_stringbuf_from_aprfile(*args)

def svn_io_remove_file2(*args):
    r"""svn_io_remove_file2(char const * path, svn_boolean_t ignore_enoent, apr_pool_t scratch_pool) -> svn_error_t"""
    return _core.svn_io_remove_file2(*args)

def svn_io_remove_file(*args):
    r"""svn_io_remove_file(char const * path, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_io_remove_file(*args)

def svn_io_remove_dir2(*args):
    r"""svn_io_remove_dir2(char const * path, svn_boolean_t ignore_enoent, svn_cancel_func_t cancel_func, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_io_remove_dir2(*args)

def svn_io_remove_dir(*args):
    r"""svn_io_remove_dir(char const * path, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_io_remove_dir(*args)

def svn_io_get_dirents3(*args):
    r"""svn_io_get_dirents3(char const * path, svn_boolean_t only_check_type, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _core.svn_io_get_dirents3(*args)

def svn_io_stat_dirent2(*args):
    r"""svn_io_stat_dirent2(char const * path, svn_boolean_t verify_truename, svn_boolean_t ignore_enoent, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _core.svn_io_stat_dirent2(*args)

def svn_io_stat_dirent(*args):
    r"""svn_io_stat_dirent(char const * path, svn_boolean_t ignore_enoent, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _core.svn_io_stat_dirent(*args)

def svn_io_dir_walk2(*args):
    r"""svn_io_dir_walk2(char const * dirname, apr_int32_t wanted, svn_io_walk_func_t walk_func, void * walk_baton, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_io_dir_walk2(*args)

def svn_io_start_cmd3(*args):
    r"""svn_io_start_cmd3(apr_proc_t * cmd_proc, char const * path, char const * cmd, char const *const * args, char const *const * env, svn_boolean_t inherit, svn_boolean_t infile_pipe, apr_file_t infile, svn_boolean_t outfile_pipe, apr_file_t outfile, svn_boolean_t errfile_pipe, apr_file_t errfile, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_io_start_cmd3(*args)

def svn_io_start_cmd2(*args):
    r"""svn_io_start_cmd2(apr_proc_t * cmd_proc, char const * path, char const * cmd, char const *const * args, svn_boolean_t inherit, svn_boolean_t infile_pipe, apr_file_t infile, svn_boolean_t outfile_pipe, apr_file_t outfile, svn_boolean_t errfile_pipe, apr_file_t errfile, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_io_start_cmd2(*args)

def svn_io_run_diff2(*args):
    r"""svn_io_run_diff2(char const * dir, char const *const * user_args, int num_user_args, char const * label1, char const * label2, char const * _from, char const * to, apr_file_t outfile, apr_file_t errfile, char const * diff_cmd, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_io_run_diff2(*args)

def svn_io_run_diff3_3(*args):
    r"""svn_io_run_diff3_3(char const * dir, char const * mine, char const * older, char const * yours, char const * mine_label, char const * older_label, char const * yours_label, apr_file_t merged, char const * diff3_cmd, apr_array_header_t user_args, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_io_run_diff3_3(*args)

def svn_io_parse_mimetypes_file(*args):
    r"""svn_io_parse_mimetypes_file(char const * mimetypes_file, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_io_parse_mimetypes_file(*args)

def svn_io_detect_mimetype2(*args):
    r"""svn_io_detect_mimetype2(char const * file, apr_hash_t mimetype_map, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_io_detect_mimetype2(*args)

def svn_io_detect_mimetype(*args):
    r"""svn_io_detect_mimetype(char const * file, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_io_detect_mimetype(*args)

def svn_io_is_binary_data(buf, len):
    r"""svn_io_is_binary_data(void const * buf, apr_size_t len) -> svn_boolean_t"""
    return _core.svn_io_is_binary_data(buf, len)

def svn_io_file_putc(*args):
    r"""svn_io_file_putc(char ch, apr_file_t file, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_io_file_putc(*args)

def svn_io_file_size_get(*args):
    r"""svn_io_file_size_get(apr_file_t file, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_io_file_size_get(*args)

def svn_io_file_get_offset(*args):
    r"""svn_io_file_get_offset(apr_off_t * offset_p, apr_file_t file, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_io_file_get_offset(*args)

def svn_io_file_read_full2(*args):
    r"""svn_io_file_read_full2(apr_file_t file, void * buf, apr_size_t nbytes, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_io_file_read_full2(*args)

def svn_io_file_aligned_seek(*args):
    r"""svn_io_file_aligned_seek(apr_file_t file, apr_off_t block_size, apr_off_t * buffer_start, apr_off_t offset, apr_pool_t scratch_pool) -> svn_error_t"""
    return _core.svn_io_file_aligned_seek(*args)

def svn_io_file_flush(*args):
    r"""svn_io_file_flush(apr_file_t file, apr_pool_t scratch_pool) -> svn_error_t"""
    return _core.svn_io_file_flush(*args)

def svn_io_write_atomic2(*args):
    r"""svn_io_write_atomic2(char const * final_path, void const * buf, apr_size_t nbytes, char const * copy_perms_path, svn_boolean_t flush_to_disk, apr_pool_t scratch_pool) -> svn_error_t"""
    return _core.svn_io_write_atomic2(*args)

def svn_io_write_atomic(*args):
    r"""svn_io_write_atomic(char const * final_path, void const * buf, apr_size_t nbytes, char const * copy_perms_path, apr_pool_t scratch_pool) -> svn_error_t"""
    return _core.svn_io_write_atomic(*args)

def svn_io_write_unique(*args):
    r"""svn_io_write_unique(char const * dirpath, void const * buf, apr_size_t nbytes, svn_io_file_del_t delete_when, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_io_write_unique(*args)

def svn_io_file_trunc(*args):
    r"""svn_io_file_trunc(apr_file_t file, apr_off_t offset, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_io_file_trunc(*args)

def svn_io_file_rename2(*args):
    r"""svn_io_file_rename2(char const * from_path, char const * to_path, svn_boolean_t flush_to_disk, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_io_file_rename2(*args)

def svn_io_dir_close(thedir):
    r"""svn_io_dir_close(apr_dir_t * thedir) -> svn_error_t"""
    return _core.svn_io_dir_close(thedir)

def svn_io_file_name_get(*args):
    r"""svn_io_file_name_get(apr_file_t file, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_io_file_name_get(*args)

def svn_io_file_readline(*args):
    r"""svn_io_file_readline(apr_file_t file, apr_size_t max_len, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _core.svn_io_file_readline(*args)
class svn_stream_t(object):
    r"""Proxy of C svn_stream_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


# Register svn_stream_t in _core:
_core.svn_stream_t_swigregister(svn_stream_t)
class svn_stream_mark_t(object):
    r"""Proxy of C svn_stream_mark_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


# Register svn_stream_mark_t in _core:
_core.svn_stream_mark_t_swigregister(svn_stream_mark_t)

def svn_read_invoke_fn(_obj, baton, buffer):
    r"""svn_read_invoke_fn(svn_read_fn_t _obj, void * baton, char * buffer) -> svn_error_t"""
    return _core.svn_read_invoke_fn(_obj, baton, buffer)

def svn_stream_invoke_skip_fn(_obj, baton, len):
    r"""svn_stream_invoke_skip_fn(svn_stream_skip_fn_t _obj, void * baton, apr_size_t len) -> svn_error_t"""
    return _core.svn_stream_invoke_skip_fn(_obj, baton, len)

def svn_write_invoke_fn(_obj, baton, data):
    r"""svn_write_invoke_fn(svn_write_fn_t _obj, void * baton, char const * data) -> svn_error_t"""
    return _core.svn_write_invoke_fn(_obj, baton, data)

def svn_close_invoke_fn(_obj, baton):
    r"""svn_close_invoke_fn(svn_close_fn_t _obj, void * baton) -> svn_error_t"""
    return _core.svn_close_invoke_fn(_obj, baton)

def svn_stream_invoke_mark_fn(*args):
    r"""svn_stream_invoke_mark_fn(svn_stream_mark_fn_t _obj, void * baton, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_stream_invoke_mark_fn(*args)

def svn_stream_invoke_seek_fn(_obj, baton, mark):
    r"""svn_stream_invoke_seek_fn(svn_stream_seek_fn_t _obj, void * baton, svn_stream_mark_t mark) -> svn_error_t"""
    return _core.svn_stream_invoke_seek_fn(_obj, baton, mark)

def svn_stream_invoke_data_available_fn(_obj, baton):
    r"""svn_stream_invoke_data_available_fn(svn_stream_data_available_fn_t _obj, void * baton) -> svn_error_t"""
    return _core.svn_stream_invoke_data_available_fn(_obj, baton)

def svn_stream_invoke_readline_fn(*args):
    r"""svn_stream_invoke_readline_fn(svn_stream_readline_fn_t _obj, void * baton, char const * eol, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_stream_invoke_readline_fn(*args)

def svn_stream_invoke_lazyopen_func(*args):
    r"""svn_stream_invoke_lazyopen_func(svn_stream_lazyopen_func_t _obj, void * baton, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _core.svn_stream_invoke_lazyopen_func(*args)

def svn_io_invoke_walk_func(*args):
    r"""svn_io_invoke_walk_func(svn_io_walk_func_t _obj, void * baton, char const * path, apr_finfo_t const * finfo, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_io_invoke_walk_func(*args)
class svn_read_fn_t(object):
    r"""Proxy of C svn_read_fn_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_read_invoke_fn(self, *args)


# Register svn_read_fn_t in _core:
_core.svn_read_fn_t_swigregister(svn_read_fn_t)
class svn_stream_skip_fn_t(object):
    r"""Proxy of C svn_stream_skip_fn_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_stream_invoke_skip_fn(self, *args)


# Register svn_stream_skip_fn_t in _core:
_core.svn_stream_skip_fn_t_swigregister(svn_stream_skip_fn_t)
class svn_write_fn_t(object):
    r"""Proxy of C svn_write_fn_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_write_invoke_fn(self, *args)


# Register svn_write_fn_t in _core:
_core.svn_write_fn_t_swigregister(svn_write_fn_t)
class svn_close_fn_t(object):
    r"""Proxy of C svn_close_fn_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_close_invoke_fn(self, *args)


# Register svn_close_fn_t in _core:
_core.svn_close_fn_t_swigregister(svn_close_fn_t)
class svn_stream_mark_fn_t(object):
    r"""Proxy of C svn_stream_mark_fn_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_stream_invoke_mark_fn(self, *args)


# Register svn_stream_mark_fn_t in _core:
_core.svn_stream_mark_fn_t_swigregister(svn_stream_mark_fn_t)
class svn_stream_seek_fn_t(object):
    r"""Proxy of C svn_stream_seek_fn_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_stream_invoke_seek_fn(self, *args)


# Register svn_stream_seek_fn_t in _core:
_core.svn_stream_seek_fn_t_swigregister(svn_stream_seek_fn_t)
class svn_stream_data_available_fn_t(object):
    r"""Proxy of C svn_stream_data_available_fn_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_stream_invoke_data_available_fn(self, *args)


# Register svn_stream_data_available_fn_t in _core:
_core.svn_stream_data_available_fn_t_swigregister(svn_stream_data_available_fn_t)
class svn_stream_readline_fn_t(object):
    r"""Proxy of C svn_stream_readline_fn_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_stream_invoke_readline_fn(self, *args)


# Register svn_stream_readline_fn_t in _core:
_core.svn_stream_readline_fn_t_swigregister(svn_stream_readline_fn_t)
class svn_stream_lazyopen_func_t(object):
    r"""Proxy of C svn_stream_lazyopen_func_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_stream_invoke_lazyopen_func(self, *args)


# Register svn_stream_lazyopen_func_t in _core:
_core.svn_stream_lazyopen_func_t_swigregister(svn_stream_lazyopen_func_t)
class svn_io_walk_func_t(object):
    r"""Proxy of C svn_io_walk_func_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_io_invoke_walk_func(self, *args)


# Register svn_io_walk_func_t in _core:
_core.svn_io_walk_func_t_swigregister(svn_io_walk_func_t)
svn_checksum_md5 = _core.svn_checksum_md5

svn_checksum_sha1 = _core.svn_checksum_sha1

svn_checksum_fnv1a_32 = _core.svn_checksum_fnv1a_32

svn_checksum_fnv1a_32x4 = _core.svn_checksum_fnv1a_32x4

class svn_checksum_t(object):
    r"""Proxy of C svn_checksum_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    digest = property(_core.svn_checksum_t_digest_get, _core.svn_checksum_t_digest_set, doc=r"""digest : p.q(const).unsigned char""")
    kind = property(_core.svn_checksum_t_kind_get, _core.svn_checksum_t_kind_set, doc=r"""kind : svn_checksum_kind_t""")
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __init__(self):
        r"""__init__(svn_checksum_t self) -> svn_checksum_t"""
        _core.svn_checksum_t_swiginit(self, _core.new_svn_checksum_t())
    __swig_destroy__ = _core.delete_svn_checksum_t

# Register svn_checksum_t in _core:
_core.svn_checksum_t_swigregister(svn_checksum_t)

def svn_checksum_create(*args):
    r"""svn_checksum_create(svn_checksum_kind_t kind, apr_pool_t pool) -> svn_checksum_t"""
    return _core.svn_checksum_create(*args)

def svn_checksum_clear(checksum):
    r"""svn_checksum_clear(svn_checksum_t checksum) -> svn_error_t"""
    return _core.svn_checksum_clear(checksum)

def svn_checksum_match(checksum1, checksum2):
    r"""svn_checksum_match(svn_checksum_t checksum1, svn_checksum_t checksum2) -> svn_boolean_t"""
    return _core.svn_checksum_match(checksum1, checksum2)

def svn_checksum_dup(*args):
    r"""svn_checksum_dup(svn_checksum_t checksum, apr_pool_t pool) -> svn_checksum_t"""
    return _core.svn_checksum_dup(*args)

def svn_checksum_to_cstring_display(*args):
    r"""svn_checksum_to_cstring_display(svn_checksum_t checksum, apr_pool_t pool) -> char const *"""
    return _core.svn_checksum_to_cstring_display(*args)

def svn_checksum_to_cstring(*args):
    r"""svn_checksum_to_cstring(svn_checksum_t checksum, apr_pool_t pool) -> char const *"""
    return _core.svn_checksum_to_cstring(*args)

def svn_checksum_serialize(*args):
    r"""svn_checksum_serialize(svn_checksum_t checksum, apr_pool_t result_pool, apr_pool_t scratch_pool) -> char const *"""
    return _core.svn_checksum_serialize(*args)

def svn_checksum_deserialize(*args):
    r"""svn_checksum_deserialize(char const * data, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _core.svn_checksum_deserialize(*args)

def svn_checksum_parse_hex(*args):
    r"""svn_checksum_parse_hex(svn_checksum_kind_t kind, char const * hex, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_checksum_parse_hex(*args)

def svn_checksum(*args):
    r"""svn_checksum(svn_checksum_kind_t kind, void const * data, apr_size_t len, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_checksum(*args)

def svn_checksum_empty_checksum(*args):
    r"""svn_checksum_empty_checksum(svn_checksum_kind_t kind, apr_pool_t pool) -> svn_checksum_t"""
    return _core.svn_checksum_empty_checksum(*args)

def svn_checksum_ctx_create(*args):
    r"""svn_checksum_ctx_create(svn_checksum_kind_t kind, apr_pool_t pool) -> svn_checksum_ctx_t"""
    return _core.svn_checksum_ctx_create(*args)

def svn_checksum_ctx_reset(ctx):
    r"""svn_checksum_ctx_reset(svn_checksum_ctx_t ctx) -> svn_error_t"""
    return _core.svn_checksum_ctx_reset(ctx)

def svn_checksum_update(ctx, data, len):
    r"""svn_checksum_update(svn_checksum_ctx_t ctx, void const * data, apr_size_t len) -> svn_error_t"""
    return _core.svn_checksum_update(ctx, data, len)

def svn_checksum_final(*args):
    r"""svn_checksum_final(svn_checksum_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_checksum_final(*args)

def svn_checksum_size(checksum):
    r"""svn_checksum_size(svn_checksum_t checksum) -> apr_size_t"""
    return _core.svn_checksum_size(checksum)

def svn_checksum_is_empty_checksum(checksum):
    r"""svn_checksum_is_empty_checksum(svn_checksum_t checksum) -> svn_boolean_t"""
    return _core.svn_checksum_is_empty_checksum(checksum)

def svn_checksum_mismatch_err(*args):
    r"""svn_checksum_mismatch_err(svn_checksum_t expected, svn_checksum_t actual, apr_pool_t scratch_pool, char const * fmt) -> svn_error_t"""
    return _core.svn_checksum_mismatch_err(*args)
class svn_checksum_ctx_t(object):
    r"""Proxy of C svn_checksum_ctx_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


# Register svn_checksum_ctx_t in _core:
_core.svn_checksum_ctx_t_swigregister(svn_checksum_ctx_t)
class svn_cache_config_t(object):
    r"""Proxy of C svn_cache_config_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    cache_size = property(_core.svn_cache_config_t_cache_size_get, _core.svn_cache_config_t_cache_size_set, doc=r"""cache_size : apr_uint64_t""")
    file_handle_count = property(_core.svn_cache_config_t_file_handle_count_get, _core.svn_cache_config_t_file_handle_count_set, doc=r"""file_handle_count : apr_size_t""")
    single_threaded = property(_core.svn_cache_config_t_single_threaded_get, _core.svn_cache_config_t_single_threaded_set, doc=r"""single_threaded : svn_boolean_t""")
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __init__(self):
        r"""__init__(svn_cache_config_t self) -> svn_cache_config_t"""
        _core.svn_cache_config_t_swiginit(self, _core.new_svn_cache_config_t())
    __swig_destroy__ = _core.delete_svn_cache_config_t

# Register svn_cache_config_t in _core:
_core.svn_cache_config_t_swigregister(svn_cache_config_t)

def svn_cache_config_get():
    r"""svn_cache_config_get() -> svn_cache_config_t"""
    return _core.svn_cache_config_get()

def svn_cache_config_set(settings):
    r"""svn_cache_config_set(svn_cache_config_t settings)"""
    return _core.svn_cache_config_set(settings)

def svn_auth_set_gnome_keyring_unlock_prompt_func(ab, prompt_func):
    r"""svn_auth_set_gnome_keyring_unlock_prompt_func(svn_auth_baton_t ab, svn_auth_gnome_keyring_unlock_prompt_func_t prompt_func)"""
    return _core.svn_auth_set_gnome_keyring_unlock_prompt_func(ab, prompt_func)

def svn_swig_py_set_application_pool(*args):
    r"""svn_swig_py_set_application_pool(PyObject * py_pool, apr_pool_t pool)"""
    return _core.svn_swig_py_set_application_pool(*args)

def svn_swig_py_clear_application_pool():
    r"""svn_swig_py_clear_application_pool()"""
    return _core.svn_swig_py_clear_application_pool()
class apr_array_header_t(object):
    r"""Proxy of C apr_array_header_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


# Register apr_array_header_t in _core:
_core.apr_array_header_t_swigregister(apr_array_header_t)
class apr_file_t(object):
    r"""Proxy of C apr_file_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


# Register apr_file_t in _core:
_core.apr_file_t_swigregister(apr_file_t)
class apr_hash_t(object):
    r"""Proxy of C apr_hash_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


# Register apr_hash_t in _core:
_core.apr_hash_t_swigregister(apr_hash_t)

import threading

application_pool = None
application_pool_lock = threading.Lock()
class GenericSWIGWrapper:
  def __init__(self, this, pool):
    """Create new Generic SWIG wrapper object"""
    import weakref
    self.this = this
    self._parent_pool = pool
    self._is_valid = weakref.ref(pool._is_valid)

  def set_parent_pool(self, pool):
    """Set the parent pool of this object"""
    self._parent_pool = pool
    self._is_valid = weakref.ref(pool._is_valid)

  def valid(self):
    """Is this object valid?"""
    return self._is_valid()

  def assert_valid(self):
    """Assert that this object is still valid"""
    assert self.valid(), "This object has already been destroyed"

  def _unwrap(self):
    """Return underlying SWIG object"""
    self.assert_valid()
    return self.this

def _mark_weakpool_invalid(weakpool):
  if weakpool:
    pool = weakpool()
    if pool:
      try:
        del pool._is_valid
      except AttributeError:
        pass



class apr_pool_t(object):
    r"""Proxy of C apr_pool_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def set_parent_pool(self, parent_pool=None):
      """Create a new memory pool"""
      global application_pool

      try:
        application_pool_lock.acquire()

        self._parent_pool = parent_pool or application_pool
        self._mark_valid()

    # Protect important functions from GC
        self._apr_pool_destroy = _core.apr_pool_destroy
        self._svn_swig_py_clear_application_pool = \
          _core.svn_swig_py_clear_application_pool

    # If we are an application-level pool,
    # then set this pool to be the application-level pool
        if not self._parent_pool:
          svn_swig_py_set_application_pool(self, self)
          application_pool = self
      finally:
        application_pool_lock.release()

    def valid(self):
      """Check whether this memory pool and its parents
      are still valid"""
      try:
        self._is_valid
      except AttributeError:
        return False
    # We must check whether the parent pool is valid even if
    # the pool is valid because weakref's callback is not
    # invoked when it is finalized by cyclic garbage collector
      if self._parent_pool:
        return self._parent_pool.valid()
      else:
        return True

    def assert_valid(self):
      """Assert that this memory_pool is still valid."""
      assert self.valid(), "This pool has already been destroyed"

    def clear(self):
      """Clear embedded memory pool. Invalidate all subpools."""
      pool = self._parent_pool
      apr_pool_clear(self)
      self.set_parent_pool(pool)

    def destroy(self):
      """Destroy embedded memory pool. If you do not destroy
      the memory pool manually, Python will destroy it
      automatically."""
      global application_pool

      self.assert_valid()

      is_application_pool = not self._parent_pool

    # Destroy pool
      self._apr_pool_destroy(self)

    # Clear application pool if necessary
      if is_application_pool:
        application_pool = None
        self._svn_swig_py_clear_application_pool()

    # Mark self as invalid
      try:
        del self._parent_pool
      except AttributeError:
        pass

      try:
        del self._is_valid
      except AttributeError:
        pass

    def __del__(self):
      """Automatically destroy memory pools, if necessary"""
      if self.valid():
        self.destroy()

    def _mark_valid(self):
      """Mark pool as valid"""

      self._weakparent = None

      if self._parent_pool:
        import weakref

    # Make sure that the parent object is valid
        self._parent_pool.assert_valid()

    # Refer to self using a weakreference so that we don't
    # create a reference cycle
        weakself = weakref.ref(self)

    # Set up callbacks to mark pool as invalid when parents
    # are destroyed
        self._weakparent = weakref.ref(self._parent_pool._is_valid,
          lambda x: _mark_weakpool_invalid(weakself))

    # Mark pool as valid
      self._is_valid = lambda: 1

    def _wrap(self, obj):
      """Mark a SWIG object as owned by this pool"""
      self.assert_valid()

      fn = getattr(obj, 'set_parent_pool', None)

      if fn is not None:
        fn(self)
        return obj
      elif obj is None:
        return None
      else:
        return GenericSWIGWrapper(obj, self)



# Register apr_pool_t in _core:
_core.apr_pool_t_swigregister(apr_pool_t)

# Initialize a global pool
svn_pool_create()


def svn_swig_mergeinfo_merge(*args):
    r"""svn_swig_mergeinfo_merge(apr_hash_t ** mergeinfo_inout, apr_hash_t changes, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_swig_mergeinfo_merge(*args)

def svn_swig_mergeinfo_sort(*args):
    r"""svn_swig_mergeinfo_sort(apr_hash_t ** mergeinfo_inout, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_swig_mergeinfo_sort(*args)

def svn_swig_rangelist_merge(*args):
    r"""svn_swig_rangelist_merge(svn_rangelist_t ** rangelist_inout, apr_array_header_t changes, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_swig_rangelist_merge(*args)

def svn_swig_rangelist_reverse(*args):
    r"""svn_swig_rangelist_reverse(svn_rangelist_t ** rangelist_inout, apr_pool_t pool) -> svn_error_t"""
    return _core.svn_swig_rangelist_reverse(*args)


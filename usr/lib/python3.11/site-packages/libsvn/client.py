# This file was automatically generated by SWIG (https://www.swig.org).
# Version 4.1.1
#
# Do not make changes to this file unless you know what you are doing - modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info

def _dll_paths():
    import os
    if hasattr(os, 'add_dll_directory'):  # Python 3.8+ on Windows
        cookies = []
        for path in os.environ.get('PATH', '').split(os.pathsep):
            if path and os.path.isabs(path):
                try:
                    cookie = os.add_dll_directory(path)
                except OSError:
                    continue
                else:
                    cookies.append(cookie)
        return cookies
    else:
        return ()

_dll_paths = _dll_paths()
try:
    from . import _client
finally:
    _dll_path = None
    for _dll_path in _dll_paths:
        _dll_path.close()
    del _dll_paths, _dll_path


try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "this":
            set(self, name, value)
        elif name == "thisown":
            self.this.own(value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)



def _copy_metadata_deep(value, old_value):
  """Copy all attributes of old_value into value, recursively traversing
  lists and dicts if needed."""
  if value is None or old_value is None or value is old_value: return

  if isinstance(value, dict):
    for k in value:
      _copy_metadata_deep(value[k], old_value[k])
  elif isinstance(value, list):
    for v, old_v in zip(value, old_value):
      _copy_metadata_deep(v, old_v)
  else:
    try:
      value.__dict__.update(old_value.__dict__)
    except AttributeError:
      pass

def _assert_valid_deep(value):
  """Assert value's validity, recursively traversing lists and dicts."""
  if isinstance(value, dict):
    for k in value:
      _assert_valid_deep(value[k])
  elif isinstance(value, list):
    for v in value:
      _assert_valid_deep(v)
# Ensure that the passed in value isn't a type, which could have an
# assert_valid attribute, but it can not be called without an instance.
  elif type(value) != type:
    try:
      fn = value.assert_valid
    except AttributeError:
      pass
    else:
      fn()



  # SWIG classes generated with -classic do not define this variable,
  # so set it to 0 when it doesn't exist
try:
  _newclass
except NameError:
  _newclass = 0

if _newclass:
  def _get_instance_attr(self, name):
    try:
      return object.__getattribute__(self, name)
    except AttributeError:
      return _swig_getattr(self, object.__getattribute__(self, '__class__'),
                           name)
else:
  def _get_instance_attr(self, name):
    return _swig_getattr(self, self.__class__, name)

def _set_instance_attr(self, name, value):
  return _swig_setattr(self, self.__class__, name, value)


import libsvn.core
import libsvn.delta
import libsvn.wc
import libsvn.ra

def svn_client_version():
    r"""svn_client_version() -> svn_version_t"""
    return _client.svn_client_version()

def svn_client_get_simple_prompt_provider(*args):
    r"""svn_client_get_simple_prompt_provider(svn_auth_simple_prompt_func_t prompt_func, int retry_limit, apr_pool_t pool)"""
    return _client.svn_client_get_simple_prompt_provider(*args)

def svn_client_get_username_prompt_provider(*args):
    r"""svn_client_get_username_prompt_provider(svn_auth_username_prompt_func_t prompt_func, int retry_limit, apr_pool_t pool)"""
    return _client.svn_client_get_username_prompt_provider(*args)

def svn_client_get_simple_provider(*args):
    r"""svn_client_get_simple_provider(apr_pool_t pool)"""
    return _client.svn_client_get_simple_provider(*args)

def svn_client_get_username_provider(*args):
    r"""svn_client_get_username_provider(apr_pool_t pool)"""
    return _client.svn_client_get_username_provider(*args)

def svn_client_get_ssl_server_trust_file_provider(*args):
    r"""svn_client_get_ssl_server_trust_file_provider(apr_pool_t pool)"""
    return _client.svn_client_get_ssl_server_trust_file_provider(*args)

def svn_client_get_ssl_client_cert_file_provider(*args):
    r"""svn_client_get_ssl_client_cert_file_provider(apr_pool_t pool)"""
    return _client.svn_client_get_ssl_client_cert_file_provider(*args)

def svn_client_get_ssl_client_cert_pw_file_provider(*args):
    r"""svn_client_get_ssl_client_cert_pw_file_provider(apr_pool_t pool)"""
    return _client.svn_client_get_ssl_client_cert_pw_file_provider(*args)

def svn_client_get_ssl_server_trust_prompt_provider(*args):
    r"""svn_client_get_ssl_server_trust_prompt_provider(svn_auth_ssl_server_trust_prompt_func_t prompt_func, apr_pool_t pool)"""
    return _client.svn_client_get_ssl_server_trust_prompt_provider(*args)

def svn_client_get_ssl_client_cert_prompt_provider(*args):
    r"""svn_client_get_ssl_client_cert_prompt_provider(svn_auth_ssl_client_cert_prompt_func_t prompt_func, int retry_limit, apr_pool_t pool)"""
    return _client.svn_client_get_ssl_client_cert_prompt_provider(*args)

def svn_client_get_ssl_client_cert_pw_prompt_provider(*args):
    r"""svn_client_get_ssl_client_cert_pw_prompt_provider(svn_auth_ssl_client_cert_pw_prompt_func_t prompt_func, int retry_limit, apr_pool_t pool)"""
    return _client.svn_client_get_ssl_client_cert_pw_prompt_provider(*args)

def svn_client_proplist_item_dup(*args):
    r"""svn_client_proplist_item_dup(svn_client_proplist_item_t const * item, apr_pool_t pool) -> svn_client_proplist_item_t *"""
    return _client.svn_client_proplist_item_dup(*args)
class svn_client_commit_info_t(object):
    r"""Proxy of C svn_client_commit_info_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    revision = property(_client.svn_client_commit_info_t_revision_get, _client.svn_client_commit_info_t_revision_set, doc=r"""revision : svn_revnum_t""")
    date = property(_client.svn_client_commit_info_t_date_get, _client.svn_client_commit_info_t_date_set, doc=r"""date : p.q(const).char""")
    author = property(_client.svn_client_commit_info_t_author_get, _client.svn_client_commit_info_t_author_set, doc=r"""author : p.q(const).char""")
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __init__(self):
        r"""__init__(svn_client_commit_info_t self) -> svn_client_commit_info_t"""
        _client.svn_client_commit_info_t_swiginit(self, _client.new_svn_client_commit_info_t())
    __swig_destroy__ = _client.delete_svn_client_commit_info_t

# Register svn_client_commit_info_t in _client:
_client.svn_client_commit_info_t_swigregister(svn_client_commit_info_t)
SVN_CLIENT_COMMIT_ITEM_ADD = _client.SVN_CLIENT_COMMIT_ITEM_ADD

SVN_CLIENT_COMMIT_ITEM_DELETE = _client.SVN_CLIENT_COMMIT_ITEM_DELETE

SVN_CLIENT_COMMIT_ITEM_TEXT_MODS = _client.SVN_CLIENT_COMMIT_ITEM_TEXT_MODS

SVN_CLIENT_COMMIT_ITEM_PROP_MODS = _client.SVN_CLIENT_COMMIT_ITEM_PROP_MODS

SVN_CLIENT_COMMIT_ITEM_IS_COPY = _client.SVN_CLIENT_COMMIT_ITEM_IS_COPY

SVN_CLIENT_COMMIT_ITEM_LOCK_TOKEN = _client.SVN_CLIENT_COMMIT_ITEM_LOCK_TOKEN

SVN_CLIENT_COMMIT_ITEM_MOVED_HERE = _client.SVN_CLIENT_COMMIT_ITEM_MOVED_HERE

class svn_client_commit_item3_t(object):
    r"""Proxy of C svn_client_commit_item3_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    path = property(_client.svn_client_commit_item3_t_path_get, _client.svn_client_commit_item3_t_path_set, doc=r"""path : p.q(const).char""")
    kind = property(_client.svn_client_commit_item3_t_kind_get, _client.svn_client_commit_item3_t_kind_set, doc=r"""kind : svn_node_kind_t""")
    url = property(_client.svn_client_commit_item3_t_url_get, _client.svn_client_commit_item3_t_url_set, doc=r"""url : p.q(const).char""")
    revision = property(_client.svn_client_commit_item3_t_revision_get, _client.svn_client_commit_item3_t_revision_set, doc=r"""revision : svn_revnum_t""")
    copyfrom_url = property(_client.svn_client_commit_item3_t_copyfrom_url_get, _client.svn_client_commit_item3_t_copyfrom_url_set, doc=r"""copyfrom_url : p.q(const).char""")
    copyfrom_rev = property(_client.svn_client_commit_item3_t_copyfrom_rev_get, _client.svn_client_commit_item3_t_copyfrom_rev_set, doc=r"""copyfrom_rev : svn_revnum_t""")
    state_flags = property(_client.svn_client_commit_item3_t_state_flags_get, _client.svn_client_commit_item3_t_state_flags_set, doc=r"""state_flags : apr_byte_t""")
    incoming_prop_changes = property(_client.svn_client_commit_item3_t_incoming_prop_changes_get, _client.svn_client_commit_item3_t_incoming_prop_changes_set, doc=r"""incoming_prop_changes : p.apr_array_header_t""")
    outgoing_prop_changes = property(_client.svn_client_commit_item3_t_outgoing_prop_changes_get, _client.svn_client_commit_item3_t_outgoing_prop_changes_set, doc=r"""outgoing_prop_changes : p.apr_array_header_t""")
    session_relpath = property(_client.svn_client_commit_item3_t_session_relpath_get, _client.svn_client_commit_item3_t_session_relpath_set, doc=r"""session_relpath : p.q(const).char""")
    moved_from_abspath = property(_client.svn_client_commit_item3_t_moved_from_abspath_get, _client.svn_client_commit_item3_t_moved_from_abspath_set, doc=r"""moved_from_abspath : p.q(const).char""")
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __init__(self):
        r"""__init__(svn_client_commit_item3_t self) -> svn_client_commit_item3_t"""
        _client.svn_client_commit_item3_t_swiginit(self, _client.new_svn_client_commit_item3_t())
    __swig_destroy__ = _client.delete_svn_client_commit_item3_t

# Register svn_client_commit_item3_t in _client:
_client.svn_client_commit_item3_t_swigregister(svn_client_commit_item3_t)
class svn_client_commit_item2_t(object):
    r"""Proxy of C svn_client_commit_item2_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    path = property(_client.svn_client_commit_item2_t_path_get, _client.svn_client_commit_item2_t_path_set, doc=r"""path : p.q(const).char""")
    kind = property(_client.svn_client_commit_item2_t_kind_get, _client.svn_client_commit_item2_t_kind_set, doc=r"""kind : svn_node_kind_t""")
    url = property(_client.svn_client_commit_item2_t_url_get, _client.svn_client_commit_item2_t_url_set, doc=r"""url : p.q(const).char""")
    revision = property(_client.svn_client_commit_item2_t_revision_get, _client.svn_client_commit_item2_t_revision_set, doc=r"""revision : svn_revnum_t""")
    copyfrom_url = property(_client.svn_client_commit_item2_t_copyfrom_url_get, _client.svn_client_commit_item2_t_copyfrom_url_set, doc=r"""copyfrom_url : p.q(const).char""")
    copyfrom_rev = property(_client.svn_client_commit_item2_t_copyfrom_rev_get, _client.svn_client_commit_item2_t_copyfrom_rev_set, doc=r"""copyfrom_rev : svn_revnum_t""")
    state_flags = property(_client.svn_client_commit_item2_t_state_flags_get, _client.svn_client_commit_item2_t_state_flags_set, doc=r"""state_flags : apr_byte_t""")
    wcprop_changes = property(_client.svn_client_commit_item2_t_wcprop_changes_get, _client.svn_client_commit_item2_t_wcprop_changes_set, doc=r"""wcprop_changes : p.apr_array_header_t""")
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __init__(self):
        r"""__init__(svn_client_commit_item2_t self) -> svn_client_commit_item2_t"""
        _client.svn_client_commit_item2_t_swiginit(self, _client.new_svn_client_commit_item2_t())
    __swig_destroy__ = _client.delete_svn_client_commit_item2_t

# Register svn_client_commit_item2_t in _client:
_client.svn_client_commit_item2_t_swigregister(svn_client_commit_item2_t)
class svn_client_commit_item_t(object):
    r"""Proxy of C svn_client_commit_item_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    path = property(_client.svn_client_commit_item_t_path_get, _client.svn_client_commit_item_t_path_set, doc=r"""path : p.q(const).char""")
    kind = property(_client.svn_client_commit_item_t_kind_get, _client.svn_client_commit_item_t_kind_set, doc=r"""kind : svn_node_kind_t""")
    url = property(_client.svn_client_commit_item_t_url_get, _client.svn_client_commit_item_t_url_set, doc=r"""url : p.q(const).char""")
    revision = property(_client.svn_client_commit_item_t_revision_get, _client.svn_client_commit_item_t_revision_set, doc=r"""revision : svn_revnum_t""")
    copyfrom_url = property(_client.svn_client_commit_item_t_copyfrom_url_get, _client.svn_client_commit_item_t_copyfrom_url_set, doc=r"""copyfrom_url : p.q(const).char""")
    state_flags = property(_client.svn_client_commit_item_t_state_flags_get, _client.svn_client_commit_item_t_state_flags_set, doc=r"""state_flags : apr_byte_t""")
    wcprop_changes = property(_client.svn_client_commit_item_t_wcprop_changes_get, _client.svn_client_commit_item_t_wcprop_changes_set, doc=r"""wcprop_changes : p.apr_array_header_t""")
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __init__(self):
        r"""__init__(svn_client_commit_item_t self) -> svn_client_commit_item_t"""
        _client.svn_client_commit_item_t_swiginit(self, _client.new_svn_client_commit_item_t())
    __swig_destroy__ = _client.delete_svn_client_commit_item_t

# Register svn_client_commit_item_t in _client:
_client.svn_client_commit_item_t_swigregister(svn_client_commit_item_t)

def svn_client_commit_item3_create(*args):
    r"""svn_client_commit_item3_create(apr_pool_t pool) -> svn_client_commit_item3_t"""
    return _client.svn_client_commit_item3_create(*args)

def svn_client_commit_item_create(*args):
    r"""svn_client_commit_item_create(apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_commit_item_create(*args)

def svn_client_commit_item3_dup(*args):
    r"""svn_client_commit_item3_dup(svn_client_commit_item3_t item, apr_pool_t pool) -> svn_client_commit_item3_t"""
    return _client.svn_client_commit_item3_dup(*args)

def svn_client_commit_item2_dup(*args):
    r"""svn_client_commit_item2_dup(svn_client_commit_item2_t item, apr_pool_t pool) -> svn_client_commit_item2_t"""
    return _client.svn_client_commit_item2_dup(*args)
svn_client_diff_summarize_kind_normal = _client.svn_client_diff_summarize_kind_normal

svn_client_diff_summarize_kind_added = _client.svn_client_diff_summarize_kind_added

svn_client_diff_summarize_kind_modified = _client.svn_client_diff_summarize_kind_modified

svn_client_diff_summarize_kind_deleted = _client.svn_client_diff_summarize_kind_deleted

class svn_client_diff_summarize_t(object):
    r"""Proxy of C svn_client_diff_summarize_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    path = property(_client.svn_client_diff_summarize_t_path_get, _client.svn_client_diff_summarize_t_path_set, doc=r"""path : p.q(const).char""")
    summarize_kind = property(_client.svn_client_diff_summarize_t_summarize_kind_get, _client.svn_client_diff_summarize_t_summarize_kind_set, doc=r"""summarize_kind : svn_client_diff_summarize_kind_t""")
    prop_changed = property(_client.svn_client_diff_summarize_t_prop_changed_get, _client.svn_client_diff_summarize_t_prop_changed_set, doc=r"""prop_changed : svn_boolean_t""")
    node_kind = property(_client.svn_client_diff_summarize_t_node_kind_get, _client.svn_client_diff_summarize_t_node_kind_set, doc=r"""node_kind : svn_node_kind_t""")
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __init__(self):
        r"""__init__(svn_client_diff_summarize_t self) -> svn_client_diff_summarize_t"""
        _client.svn_client_diff_summarize_t_swiginit(self, _client.new_svn_client_diff_summarize_t())
    __swig_destroy__ = _client.delete_svn_client_diff_summarize_t

# Register svn_client_diff_summarize_t in _client:
_client.svn_client_diff_summarize_t_swigregister(svn_client_diff_summarize_t)

def svn_client_diff_summarize_dup(*args):
    r"""svn_client_diff_summarize_dup(svn_client_diff_summarize_t diff, apr_pool_t pool) -> svn_client_diff_summarize_t"""
    return _client.svn_client_diff_summarize_dup(*args)
class svn_client_ctx_t(object):
    r"""Proxy of C svn_client_ctx_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    auth_baton = property(_client.svn_client_ctx_t_auth_baton_get, _client.svn_client_ctx_t_auth_baton_set, doc=r"""auth_baton : p.svn_auth_baton_t""")
    notify_func = property(_client.svn_client_ctx_t_notify_func_get, _client.svn_client_ctx_t_notify_func_set, doc=r"""notify_func : svn_wc_notify_func_t""")
    notify_baton = property(_client.svn_client_ctx_t_notify_baton_get, _client.svn_client_ctx_t_notify_baton_set, doc=r"""notify_baton : p.void""")
    log_msg_func = property(_client.svn_client_ctx_t_log_msg_func_get, _client.svn_client_ctx_t_log_msg_func_set, doc=r"""log_msg_func : svn_client_get_commit_log_t""")
    log_msg_baton = property(_client.svn_client_ctx_t_log_msg_baton_get, _client.svn_client_ctx_t_log_msg_baton_set, doc=r"""log_msg_baton : p.void""")
    config = property(_client.svn_client_ctx_t_config_get, _client.svn_client_ctx_t_config_set, doc=r"""config : p.apr_hash_t""")
    cancel_func = property(_client.svn_client_ctx_t_cancel_func_get, _client.svn_client_ctx_t_cancel_func_set, doc=r"""cancel_func : svn_cancel_func_t""")
    cancel_baton = property(_client.svn_client_ctx_t_cancel_baton_get, _client.svn_client_ctx_t_cancel_baton_set, doc=r"""cancel_baton : p.void""")
    notify_func2 = property(_client.svn_client_ctx_t_notify_func2_get, _client.svn_client_ctx_t_notify_func2_set, doc=r"""notify_func2 : svn_wc_notify_func2_t""")
    notify_baton2 = property(_client.svn_client_ctx_t_notify_baton2_get, _client.svn_client_ctx_t_notify_baton2_set, doc=r"""notify_baton2 : p.void""")
    log_msg_func2 = property(_client.svn_client_ctx_t_log_msg_func2_get, _client.svn_client_ctx_t_log_msg_func2_set, doc=r"""log_msg_func2 : svn_client_get_commit_log2_t""")
    log_msg_baton2 = property(_client.svn_client_ctx_t_log_msg_baton2_get, _client.svn_client_ctx_t_log_msg_baton2_set, doc=r"""log_msg_baton2 : p.void""")
    progress_func = property(_client.svn_client_ctx_t_progress_func_get, _client.svn_client_ctx_t_progress_func_set, doc=r"""progress_func : svn_ra_progress_notify_func_t""")
    progress_baton = property(_client.svn_client_ctx_t_progress_baton_get, _client.svn_client_ctx_t_progress_baton_set, doc=r"""progress_baton : p.void""")
    log_msg_func3 = property(_client.svn_client_ctx_t_log_msg_func3_get, _client.svn_client_ctx_t_log_msg_func3_set, doc=r"""log_msg_func3 : svn_client_get_commit_log3_t""")
    log_msg_baton3 = property(_client.svn_client_ctx_t_log_msg_baton3_get, _client.svn_client_ctx_t_log_msg_baton3_set, doc=r"""log_msg_baton3 : p.void""")
    mimetypes_map = property(_client.svn_client_ctx_t_mimetypes_map_get, _client.svn_client_ctx_t_mimetypes_map_set, doc=r"""mimetypes_map : p.apr_hash_t""")
    conflict_func = property(_client.svn_client_ctx_t_conflict_func_get, _client.svn_client_ctx_t_conflict_func_set, doc=r"""conflict_func : svn_wc_conflict_resolver_func_t""")
    conflict_baton = property(_client.svn_client_ctx_t_conflict_baton_get, _client.svn_client_ctx_t_conflict_baton_set, doc=r"""conflict_baton : p.void""")
    client_name = property(_client.svn_client_ctx_t_client_name_get, _client.svn_client_ctx_t_client_name_set, doc=r"""client_name : p.q(const).char""")
    conflict_func2 = property(_client.svn_client_ctx_t_conflict_func2_get, _client.svn_client_ctx_t_conflict_func2_set, doc=r"""conflict_func2 : svn_wc_conflict_resolver_func2_t""")
    conflict_baton2 = property(_client.svn_client_ctx_t_conflict_baton2_get, _client.svn_client_ctx_t_conflict_baton2_set, doc=r"""conflict_baton2 : p.void""")
    wc_ctx = property(_client.svn_client_ctx_t_wc_ctx_get, _client.svn_client_ctx_t_wc_ctx_set, doc=r"""wc_ctx : p.svn_wc_context_t""")
    check_tunnel_func = property(_client.svn_client_ctx_t_check_tunnel_func_get, _client.svn_client_ctx_t_check_tunnel_func_set, doc=r"""check_tunnel_func : svn_ra_check_tunnel_func_t""")
    open_tunnel_func = property(_client.svn_client_ctx_t_open_tunnel_func_get, _client.svn_client_ctx_t_open_tunnel_func_set, doc=r"""open_tunnel_func : svn_ra_open_tunnel_func_t""")
    tunnel_baton = property(_client.svn_client_ctx_t_tunnel_baton_get, _client.svn_client_ctx_t_tunnel_baton_set, doc=r"""tunnel_baton : p.void""")
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __init__(self):
        r"""__init__(svn_client_ctx_t self) -> svn_client_ctx_t"""
        _client.svn_client_ctx_t_swiginit(self, _client.new_svn_client_ctx_t())
    __swig_destroy__ = _client.delete_svn_client_ctx_t

# Register svn_client_ctx_t in _client:
_client.svn_client_ctx_t_swigregister(svn_client_ctx_t)

def svn_client_create_context2(*args):
    r"""svn_client_create_context2(apr_hash_t cfg_hash, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_create_context2(*args)

def svn_client_create_context(*args):
    r"""svn_client_create_context(apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_create_context(*args)
SVN_CLIENT_AUTH_USERNAME = _client.SVN_CLIENT_AUTH_USERNAME

SVN_CLIENT_AUTH_PASSWORD = _client.SVN_CLIENT_AUTH_PASSWORD


def svn_client_args_to_target_array2(*args):
    r"""svn_client_args_to_target_array2(apr_getopt_t * os, apr_array_header_t known_targets, svn_client_ctx_t ctx, svn_boolean_t keep_last_origpath_on_truepath_collision, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_args_to_target_array2(*args)

def svn_client_args_to_target_array(*args):
    r"""svn_client_args_to_target_array(apr_getopt_t * os, apr_array_header_t known_targets, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_args_to_target_array(*args)

def svn_client_checkout3(*args):
    r"""svn_client_checkout3(char const * URL, char const * path, svn_opt_revision_t peg_revision, svn_opt_revision_t revision, svn_depth_t depth, svn_boolean_t ignore_externals, svn_boolean_t allow_unver_obstructions, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_checkout3(*args)

def svn_client_checkout2(*args):
    r"""svn_client_checkout2(char const * URL, char const * path, svn_opt_revision_t peg_revision, svn_opt_revision_t revision, svn_boolean_t recurse, svn_boolean_t ignore_externals, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_checkout2(*args)

def svn_client_checkout(*args):
    r"""svn_client_checkout(char const * URL, char const * path, svn_opt_revision_t revision, svn_boolean_t recurse, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_checkout(*args)

def svn_client_update4(*args):
    r"""svn_client_update4(apr_array_header_t paths, svn_opt_revision_t revision, svn_depth_t depth, svn_boolean_t depth_is_sticky, svn_boolean_t ignore_externals, svn_boolean_t allow_unver_obstructions, svn_boolean_t adds_as_modification, svn_boolean_t make_parents, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_update4(*args)

def svn_client_update3(*args):
    r"""svn_client_update3(apr_array_header_t paths, svn_opt_revision_t revision, svn_depth_t depth, svn_boolean_t depth_is_sticky, svn_boolean_t ignore_externals, svn_boolean_t allow_unver_obstructions, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_update3(*args)

def svn_client_update2(*args):
    r"""svn_client_update2(apr_array_header_t paths, svn_opt_revision_t revision, svn_boolean_t recurse, svn_boolean_t ignore_externals, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_update2(*args)

def svn_client_update(*args):
    r"""svn_client_update(char const * path, svn_opt_revision_t revision, svn_boolean_t recurse, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_update(*args)

def svn_client_switch3(*args):
    r"""svn_client_switch3(char const * path, char const * url, svn_opt_revision_t peg_revision, svn_opt_revision_t revision, svn_depth_t depth, svn_boolean_t depth_is_sticky, svn_boolean_t ignore_externals, svn_boolean_t allow_unver_obstructions, svn_boolean_t ignore_ancestry, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_switch3(*args)

def svn_client_switch2(*args):
    r"""svn_client_switch2(char const * path, char const * url, svn_opt_revision_t peg_revision, svn_opt_revision_t revision, svn_depth_t depth, svn_boolean_t depth_is_sticky, svn_boolean_t ignore_externals, svn_boolean_t allow_unver_obstructions, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_switch2(*args)

def svn_client_switch(*args):
    r"""svn_client_switch(char const * path, char const * url, svn_opt_revision_t revision, svn_boolean_t recurse, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_switch(*args)

def svn_client__layout_list(*args):
    r"""svn_client__layout_list(char const * local_abspath, svn_client__layout_func_t layout, void * layout_baton, svn_client_ctx_t ctx, apr_pool_t scratch_pool) -> svn_error_t"""
    return _client.svn_client__layout_list(*args)

def svn_client_add5(*args):
    r"""svn_client_add5(char const * path, svn_depth_t depth, svn_boolean_t force, svn_boolean_t no_ignore, svn_boolean_t no_autoprops, svn_boolean_t add_parents, svn_client_ctx_t ctx, apr_pool_t scratch_pool) -> svn_error_t"""
    return _client.svn_client_add5(*args)

def svn_client_add4(*args):
    r"""svn_client_add4(char const * path, svn_depth_t depth, svn_boolean_t force, svn_boolean_t no_ignore, svn_boolean_t add_parents, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_add4(*args)

def svn_client_add3(*args):
    r"""svn_client_add3(char const * path, svn_boolean_t recursive, svn_boolean_t force, svn_boolean_t no_ignore, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_add3(*args)

def svn_client_add2(*args):
    r"""svn_client_add2(char const * path, svn_boolean_t recursive, svn_boolean_t force, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_add2(*args)

def svn_client_add(*args):
    r"""svn_client_add(char const * path, svn_boolean_t recursive, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_add(*args)

def svn_client_mkdir4(*args):
    r"""svn_client_mkdir4(apr_array_header_t paths, svn_boolean_t make_parents, apr_hash_t revprop_table, svn_commit_callback2_t commit_callback, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_mkdir4(*args)

def svn_client_mkdir3(*args):
    r"""svn_client_mkdir3(apr_array_header_t paths, svn_boolean_t make_parents, apr_hash_t revprop_table, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_mkdir3(*args)

def svn_client_mkdir2(*args):
    r"""svn_client_mkdir2(apr_array_header_t paths, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_mkdir2(*args)

def svn_client_mkdir(*args):
    r"""svn_client_mkdir(apr_array_header_t paths, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_mkdir(*args)

def svn_client_delete4(*args):
    r"""svn_client_delete4(apr_array_header_t paths, svn_boolean_t force, svn_boolean_t keep_local, apr_hash_t revprop_table, svn_commit_callback2_t commit_callback, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_delete4(*args)

def svn_client_delete3(*args):
    r"""svn_client_delete3(apr_array_header_t paths, svn_boolean_t force, svn_boolean_t keep_local, apr_hash_t revprop_table, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_delete3(*args)

def svn_client_delete2(*args):
    r"""svn_client_delete2(apr_array_header_t paths, svn_boolean_t force, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_delete2(*args)

def svn_client_delete(*args):
    r"""svn_client_delete(apr_array_header_t paths, svn_boolean_t force, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_delete(*args)

def svn_client_import5(*args):
    r"""svn_client_import5(char const * path, char const * url, svn_depth_t depth, svn_boolean_t no_ignore, svn_boolean_t no_autoprops, svn_boolean_t ignore_unknown_node_types, apr_hash_t revprop_table, svn_client_import_filter_func_t filter_callback, void * filter_baton, svn_commit_callback2_t commit_callback, svn_client_ctx_t ctx, apr_pool_t scratch_pool) -> svn_error_t"""
    return _client.svn_client_import5(*args)

def svn_client_import4(*args):
    r"""svn_client_import4(char const * path, char const * url, svn_depth_t depth, svn_boolean_t no_ignore, svn_boolean_t ignore_unknown_node_types, apr_hash_t revprop_table, svn_commit_callback2_t commit_callback, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_import4(*args)

def svn_client_import3(*args):
    r"""svn_client_import3(char const * path, char const * url, svn_depth_t depth, svn_boolean_t no_ignore, svn_boolean_t ignore_unknown_node_types, apr_hash_t revprop_table, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_import3(*args)

def svn_client_import2(*args):
    r"""svn_client_import2(char const * path, char const * url, svn_boolean_t nonrecursive, svn_boolean_t no_ignore, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_import2(*args)

def svn_client_import(*args):
    r"""svn_client_import(char const * path, char const * url, svn_boolean_t nonrecursive, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_import(*args)

def svn_client_commit6(*args):
    r"""svn_client_commit6(apr_array_header_t targets, svn_depth_t depth, svn_boolean_t keep_locks, svn_boolean_t keep_changelists, svn_boolean_t commit_as_operations, svn_boolean_t include_file_externals, svn_boolean_t include_dir_externals, apr_array_header_t changelists, apr_hash_t revprop_table, svn_commit_callback2_t commit_callback, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_commit6(*args)

def svn_client_commit5(*args):
    r"""svn_client_commit5(apr_array_header_t targets, svn_depth_t depth, svn_boolean_t keep_locks, svn_boolean_t keep_changelists, svn_boolean_t commit_as_operations, apr_array_header_t changelists, apr_hash_t revprop_table, svn_commit_callback2_t commit_callback, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_commit5(*args)

def svn_client_commit4(*args):
    r"""svn_client_commit4(apr_array_header_t targets, svn_depth_t depth, svn_boolean_t keep_locks, svn_boolean_t keep_changelists, apr_array_header_t changelists, apr_hash_t revprop_table, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_commit4(*args)

def svn_client_commit3(*args):
    r"""svn_client_commit3(apr_array_header_t targets, svn_boolean_t recurse, svn_boolean_t keep_locks, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_commit3(*args)

def svn_client_commit2(*args):
    r"""svn_client_commit2(apr_array_header_t targets, svn_boolean_t recurse, svn_boolean_t keep_locks, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_commit2(*args)

def svn_client_commit(*args):
    r"""svn_client_commit(apr_array_header_t targets, svn_boolean_t nonrecursive, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_commit(*args)
class svn_client_status_t(object):
    r"""Proxy of C svn_client_status_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    kind = property(_client.svn_client_status_t_kind_get, _client.svn_client_status_t_kind_set, doc=r"""kind : svn_node_kind_t""")
    local_abspath = property(_client.svn_client_status_t_local_abspath_get, _client.svn_client_status_t_local_abspath_set, doc=r"""local_abspath : p.q(const).char""")
    filesize = property(_client.svn_client_status_t_filesize_get, _client.svn_client_status_t_filesize_set, doc=r"""filesize : svn_filesize_t""")
    versioned = property(_client.svn_client_status_t_versioned_get, _client.svn_client_status_t_versioned_set, doc=r"""versioned : svn_boolean_t""")
    conflicted = property(_client.svn_client_status_t_conflicted_get, _client.svn_client_status_t_conflicted_set, doc=r"""conflicted : svn_boolean_t""")
    node_status = property(_client.svn_client_status_t_node_status_get, _client.svn_client_status_t_node_status_set, doc=r"""node_status : enum svn_wc_status_kind""")
    text_status = property(_client.svn_client_status_t_text_status_get, _client.svn_client_status_t_text_status_set, doc=r"""text_status : enum svn_wc_status_kind""")
    prop_status = property(_client.svn_client_status_t_prop_status_get, _client.svn_client_status_t_prop_status_set, doc=r"""prop_status : enum svn_wc_status_kind""")
    wc_is_locked = property(_client.svn_client_status_t_wc_is_locked_get, _client.svn_client_status_t_wc_is_locked_set, doc=r"""wc_is_locked : svn_boolean_t""")
    copied = property(_client.svn_client_status_t_copied_get, _client.svn_client_status_t_copied_set, doc=r"""copied : svn_boolean_t""")
    repos_root_url = property(_client.svn_client_status_t_repos_root_url_get, _client.svn_client_status_t_repos_root_url_set, doc=r"""repos_root_url : p.q(const).char""")
    repos_uuid = property(_client.svn_client_status_t_repos_uuid_get, _client.svn_client_status_t_repos_uuid_set, doc=r"""repos_uuid : p.q(const).char""")
    repos_relpath = property(_client.svn_client_status_t_repos_relpath_get, _client.svn_client_status_t_repos_relpath_set, doc=r"""repos_relpath : p.q(const).char""")
    revision = property(_client.svn_client_status_t_revision_get, _client.svn_client_status_t_revision_set, doc=r"""revision : svn_revnum_t""")
    changed_rev = property(_client.svn_client_status_t_changed_rev_get, _client.svn_client_status_t_changed_rev_set, doc=r"""changed_rev : svn_revnum_t""")
    changed_date = property(_client.svn_client_status_t_changed_date_get, _client.svn_client_status_t_changed_date_set, doc=r"""changed_date : apr_time_t""")
    changed_author = property(_client.svn_client_status_t_changed_author_get, _client.svn_client_status_t_changed_author_set, doc=r"""changed_author : p.q(const).char""")
    switched = property(_client.svn_client_status_t_switched_get, _client.svn_client_status_t_switched_set, doc=r"""switched : svn_boolean_t""")
    file_external = property(_client.svn_client_status_t_file_external_get, _client.svn_client_status_t_file_external_set, doc=r"""file_external : svn_boolean_t""")
    lock = property(_client.svn_client_status_t_lock_get, _client.svn_client_status_t_lock_set, doc=r"""lock : p.q(const).svn_lock_t""")
    changelist = property(_client.svn_client_status_t_changelist_get, _client.svn_client_status_t_changelist_set, doc=r"""changelist : p.q(const).char""")
    depth = property(_client.svn_client_status_t_depth_get, _client.svn_client_status_t_depth_set, doc=r"""depth : svn_depth_t""")
    ood_kind = property(_client.svn_client_status_t_ood_kind_get, _client.svn_client_status_t_ood_kind_set, doc=r"""ood_kind : svn_node_kind_t""")
    repos_node_status = property(_client.svn_client_status_t_repos_node_status_get, _client.svn_client_status_t_repos_node_status_set, doc=r"""repos_node_status : enum svn_wc_status_kind""")
    repos_text_status = property(_client.svn_client_status_t_repos_text_status_get, _client.svn_client_status_t_repos_text_status_set, doc=r"""repos_text_status : enum svn_wc_status_kind""")
    repos_prop_status = property(_client.svn_client_status_t_repos_prop_status_get, _client.svn_client_status_t_repos_prop_status_set, doc=r"""repos_prop_status : enum svn_wc_status_kind""")
    repos_lock = property(_client.svn_client_status_t_repos_lock_get, _client.svn_client_status_t_repos_lock_set, doc=r"""repos_lock : p.q(const).svn_lock_t""")
    ood_changed_rev = property(_client.svn_client_status_t_ood_changed_rev_get, _client.svn_client_status_t_ood_changed_rev_set, doc=r"""ood_changed_rev : svn_revnum_t""")
    ood_changed_date = property(_client.svn_client_status_t_ood_changed_date_get, _client.svn_client_status_t_ood_changed_date_set, doc=r"""ood_changed_date : apr_time_t""")
    ood_changed_author = property(_client.svn_client_status_t_ood_changed_author_get, _client.svn_client_status_t_ood_changed_author_set, doc=r"""ood_changed_author : p.q(const).char""")
    backwards_compatibility_baton = property(_client.svn_client_status_t_backwards_compatibility_baton_get, _client.svn_client_status_t_backwards_compatibility_baton_set, doc=r"""backwards_compatibility_baton : p.q(const).void""")
    moved_from_abspath = property(_client.svn_client_status_t_moved_from_abspath_get, _client.svn_client_status_t_moved_from_abspath_set, doc=r"""moved_from_abspath : p.q(const).char""")
    moved_to_abspath = property(_client.svn_client_status_t_moved_to_abspath_get, _client.svn_client_status_t_moved_to_abspath_set, doc=r"""moved_to_abspath : p.q(const).char""")
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __init__(self):
        r"""__init__(svn_client_status_t self) -> svn_client_status_t"""
        _client.svn_client_status_t_swiginit(self, _client.new_svn_client_status_t())
    __swig_destroy__ = _client.delete_svn_client_status_t

# Register svn_client_status_t in _client:
_client.svn_client_status_t_swigregister(svn_client_status_t)

def svn_client_status_dup(*args):
    r"""svn_client_status_dup(svn_client_status_t status, apr_pool_t result_pool) -> svn_client_status_t"""
    return _client.svn_client_status_dup(*args)

def svn_client_status6(*args):
    r"""svn_client_status6(svn_client_ctx_t ctx, char const * path, svn_opt_revision_t revision, svn_depth_t depth, svn_boolean_t get_all, svn_boolean_t check_out_of_date, svn_boolean_t check_working_copy, svn_boolean_t no_ignore, svn_boolean_t ignore_externals, svn_boolean_t depth_as_sticky, apr_array_header_t changelists, svn_client_status_func_t status_func, apr_pool_t scratch_pool) -> svn_error_t"""
    return _client.svn_client_status6(*args)

def svn_client_status5(*args):
    r"""svn_client_status5(svn_client_ctx_t ctx, char const * path, svn_opt_revision_t revision, svn_depth_t depth, svn_boolean_t get_all, svn_boolean_t update, svn_boolean_t no_ignore, svn_boolean_t ignore_externals, svn_boolean_t depth_as_sticky, apr_array_header_t changelists, svn_client_status_func_t status_func, apr_pool_t scratch_pool) -> svn_error_t"""
    return _client.svn_client_status5(*args)

def svn_client_status4(*args):
    r"""svn_client_status4(char const * path, svn_opt_revision_t revision, svn_wc_status_func3_t status_func, void * status_baton, svn_depth_t depth, svn_boolean_t get_all, svn_boolean_t update, svn_boolean_t no_ignore, svn_boolean_t ignore_externals, apr_array_header_t changelists, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_status4(*args)

def svn_client_status3(*args):
    r"""svn_client_status3(char const * path, svn_opt_revision_t revision, svn_wc_status_func2_t status_func, svn_depth_t depth, svn_boolean_t get_all, svn_boolean_t update, svn_boolean_t no_ignore, svn_boolean_t ignore_externals, apr_array_header_t changelists, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_status3(*args)

def svn_client_status2(*args):
    r"""svn_client_status2(char const * path, svn_opt_revision_t revision, svn_wc_status_func2_t status_func, svn_boolean_t recurse, svn_boolean_t get_all, svn_boolean_t update, svn_boolean_t no_ignore, svn_boolean_t ignore_externals, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_status2(*args)

def svn_client_status(*args):
    r"""svn_client_status(char const * path, svn_opt_revision_t revision, svn_wc_status_func_t status_func, svn_boolean_t recurse, svn_boolean_t get_all, svn_boolean_t update, svn_boolean_t no_ignore, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_status(*args)

def svn_client_log5(*args):
    r"""svn_client_log5(apr_array_header_t targets, svn_opt_revision_t peg_revision, apr_array_header_t revision_ranges, int limit, svn_boolean_t discover_changed_paths, svn_boolean_t strict_node_history, svn_boolean_t include_merged_revisions, apr_array_header_t revprops, svn_log_entry_receiver_t receiver, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_log5(*args)

def svn_client_log4(*args):
    r"""svn_client_log4(apr_array_header_t targets, svn_opt_revision_t peg_revision, svn_opt_revision_t start, svn_opt_revision_t end, int limit, svn_boolean_t discover_changed_paths, svn_boolean_t strict_node_history, svn_boolean_t include_merged_revisions, apr_array_header_t revprops, svn_log_entry_receiver_t receiver, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_log4(*args)

def svn_client_log3(*args):
    r"""svn_client_log3(apr_array_header_t targets, svn_opt_revision_t peg_revision, svn_opt_revision_t start, svn_opt_revision_t end, int limit, svn_boolean_t discover_changed_paths, svn_boolean_t strict_node_history, svn_log_message_receiver_t receiver, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_log3(*args)

def svn_client_log2(*args):
    r"""svn_client_log2(apr_array_header_t targets, svn_opt_revision_t start, svn_opt_revision_t end, int limit, svn_boolean_t discover_changed_paths, svn_boolean_t strict_node_history, svn_log_message_receiver_t receiver, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_log2(*args)

def svn_client_log(*args):
    r"""svn_client_log(apr_array_header_t targets, svn_opt_revision_t start, svn_opt_revision_t end, svn_boolean_t discover_changed_paths, svn_boolean_t strict_node_history, svn_log_message_receiver_t receiver, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_log(*args)

def svn_client_blame6(*args):
    r"""svn_client_blame6(char const * path_or_url, svn_opt_revision_t peg_revision, svn_opt_revision_t start, svn_opt_revision_t end, svn_diff_file_options_t const * diff_options, svn_boolean_t ignore_mime_type, svn_boolean_t include_merged_revisions, svn_client_blame_receiver4_t receiver, void * receiver_baton, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_blame6(*args)

def svn_client_blame5(*args):
    r"""svn_client_blame5(char const * path_or_url, svn_opt_revision_t peg_revision, svn_opt_revision_t start, svn_opt_revision_t end, svn_diff_file_options_t const * diff_options, svn_boolean_t ignore_mime_type, svn_boolean_t include_merged_revisions, svn_client_blame_receiver3_t receiver, void * receiver_baton, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_blame5(*args)

def svn_client_blame4(*args):
    r"""svn_client_blame4(char const * path_or_url, svn_opt_revision_t peg_revision, svn_opt_revision_t start, svn_opt_revision_t end, svn_diff_file_options_t const * diff_options, svn_boolean_t ignore_mime_type, svn_boolean_t include_merged_revisions, svn_client_blame_receiver2_t receiver, void * receiver_baton, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_blame4(*args)

def svn_client_blame3(*args):
    r"""svn_client_blame3(char const * path_or_url, svn_opt_revision_t peg_revision, svn_opt_revision_t start, svn_opt_revision_t end, svn_diff_file_options_t const * diff_options, svn_boolean_t ignore_mime_type, svn_client_blame_receiver_t receiver, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_blame3(*args)

def svn_client_blame2(*args):
    r"""svn_client_blame2(char const * path_or_url, svn_opt_revision_t peg_revision, svn_opt_revision_t start, svn_opt_revision_t end, svn_client_blame_receiver_t receiver, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_blame2(*args)

def svn_client_blame(*args):
    r"""svn_client_blame(char const * path_or_url, svn_opt_revision_t start, svn_opt_revision_t end, svn_client_blame_receiver_t receiver, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_blame(*args)

def svn_client_diff7(*args):
    r"""svn_client_diff7(apr_array_header_t diff_options, char const * path_or_url1, svn_opt_revision_t revision1, char const * path_or_url2, svn_opt_revision_t revision2, char const * relative_to_dir, svn_depth_t depth, svn_boolean_t ignore_ancestry, svn_boolean_t no_diff_added, svn_boolean_t no_diff_deleted, svn_boolean_t show_copies_as_adds, svn_boolean_t ignore_content_type, svn_boolean_t ignore_properties, svn_boolean_t properties_only, svn_boolean_t use_git_diff_format, svn_boolean_t pretty_print_mergeinfo, char const * header_encoding, svn_stream_t outstream, svn_stream_t errstream, apr_array_header_t changelists, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_diff7(*args)

def svn_client_diff6(*args):
    r"""svn_client_diff6(apr_array_header_t diff_options, char const * path_or_url1, svn_opt_revision_t revision1, char const * path_or_url2, svn_opt_revision_t revision2, char const * relative_to_dir, svn_depth_t depth, svn_boolean_t ignore_ancestry, svn_boolean_t no_diff_added, svn_boolean_t no_diff_deleted, svn_boolean_t show_copies_as_adds, svn_boolean_t ignore_content_type, svn_boolean_t ignore_properties, svn_boolean_t properties_only, svn_boolean_t use_git_diff_format, char const * header_encoding, svn_stream_t outstream, svn_stream_t errstream, apr_array_header_t changelists, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_diff6(*args)

def svn_client_diff5(*args):
    r"""svn_client_diff5(apr_array_header_t diff_options, char const * path1, svn_opt_revision_t revision1, char const * path2, svn_opt_revision_t revision2, char const * relative_to_dir, svn_depth_t depth, svn_boolean_t ignore_ancestry, svn_boolean_t no_diff_deleted, svn_boolean_t show_copies_as_adds, svn_boolean_t ignore_content_type, svn_boolean_t use_git_diff_format, char const * header_encoding, apr_file_t outfile, apr_file_t errfile, apr_array_header_t changelists, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_diff5(*args)

def svn_client_diff4(*args):
    r"""svn_client_diff4(apr_array_header_t diff_options, char const * path1, svn_opt_revision_t revision1, char const * path2, svn_opt_revision_t revision2, char const * relative_to_dir, svn_depth_t depth, svn_boolean_t ignore_ancestry, svn_boolean_t no_diff_deleted, svn_boolean_t ignore_content_type, char const * header_encoding, apr_file_t outfile, apr_file_t errfile, apr_array_header_t changelists, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_diff4(*args)

def svn_client_diff3(*args):
    r"""svn_client_diff3(apr_array_header_t diff_options, char const * path1, svn_opt_revision_t revision1, char const * path2, svn_opt_revision_t revision2, svn_boolean_t recurse, svn_boolean_t ignore_ancestry, svn_boolean_t no_diff_deleted, svn_boolean_t ignore_content_type, char const * header_encoding, apr_file_t outfile, apr_file_t errfile, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_diff3(*args)

def svn_client_diff2(*args):
    r"""svn_client_diff2(apr_array_header_t diff_options, char const * path1, svn_opt_revision_t revision1, char const * path2, svn_opt_revision_t revision2, svn_boolean_t recurse, svn_boolean_t ignore_ancestry, svn_boolean_t no_diff_deleted, svn_boolean_t ignore_content_type, apr_file_t outfile, apr_file_t errfile, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_diff2(*args)

def svn_client_diff(*args):
    r"""svn_client_diff(apr_array_header_t diff_options, char const * path1, svn_opt_revision_t revision1, char const * path2, svn_opt_revision_t revision2, svn_boolean_t recurse, svn_boolean_t ignore_ancestry, svn_boolean_t no_diff_deleted, apr_file_t outfile, apr_file_t errfile, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_diff(*args)

def svn_client_diff_peg7(*args):
    r"""svn_client_diff_peg7(apr_array_header_t diff_options, char const * path_or_url, svn_opt_revision_t peg_revision, svn_opt_revision_t start_revision, svn_opt_revision_t end_revision, char const * relative_to_dir, svn_depth_t depth, svn_boolean_t ignore_ancestry, svn_boolean_t no_diff_added, svn_boolean_t no_diff_deleted, svn_boolean_t show_copies_as_adds, svn_boolean_t ignore_content_type, svn_boolean_t ignore_properties, svn_boolean_t properties_only, svn_boolean_t use_git_diff_format, svn_boolean_t pretty_print_mergeinfo, char const * header_encoding, svn_stream_t outstream, svn_stream_t errstream, apr_array_header_t changelists, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_diff_peg7(*args)

def svn_client_diff_peg6(*args):
    r"""svn_client_diff_peg6(apr_array_header_t diff_options, char const * path_or_url, svn_opt_revision_t peg_revision, svn_opt_revision_t start_revision, svn_opt_revision_t end_revision, char const * relative_to_dir, svn_depth_t depth, svn_boolean_t ignore_ancestry, svn_boolean_t no_diff_added, svn_boolean_t no_diff_deleted, svn_boolean_t show_copies_as_adds, svn_boolean_t ignore_content_type, svn_boolean_t ignore_properties, svn_boolean_t properties_only, svn_boolean_t use_git_diff_format, char const * header_encoding, svn_stream_t outstream, svn_stream_t errstream, apr_array_header_t changelists, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_diff_peg6(*args)

def svn_client_diff_peg5(*args):
    r"""svn_client_diff_peg5(apr_array_header_t diff_options, char const * path, svn_opt_revision_t peg_revision, svn_opt_revision_t start_revision, svn_opt_revision_t end_revision, char const * relative_to_dir, svn_depth_t depth, svn_boolean_t ignore_ancestry, svn_boolean_t no_diff_deleted, svn_boolean_t show_copies_as_adds, svn_boolean_t ignore_content_type, svn_boolean_t use_git_diff_format, char const * header_encoding, apr_file_t outfile, apr_file_t errfile, apr_array_header_t changelists, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_diff_peg5(*args)

def svn_client_diff_peg4(*args):
    r"""svn_client_diff_peg4(apr_array_header_t diff_options, char const * path, svn_opt_revision_t peg_revision, svn_opt_revision_t start_revision, svn_opt_revision_t end_revision, char const * relative_to_dir, svn_depth_t depth, svn_boolean_t ignore_ancestry, svn_boolean_t no_diff_deleted, svn_boolean_t ignore_content_type, char const * header_encoding, apr_file_t outfile, apr_file_t errfile, apr_array_header_t changelists, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_diff_peg4(*args)

def svn_client_diff_peg3(*args):
    r"""svn_client_diff_peg3(apr_array_header_t diff_options, char const * path, svn_opt_revision_t peg_revision, svn_opt_revision_t start_revision, svn_opt_revision_t end_revision, svn_boolean_t recurse, svn_boolean_t ignore_ancestry, svn_boolean_t no_diff_deleted, svn_boolean_t ignore_content_type, char const * header_encoding, apr_file_t outfile, apr_file_t errfile, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_diff_peg3(*args)

def svn_client_diff_peg2(*args):
    r"""svn_client_diff_peg2(apr_array_header_t diff_options, char const * path, svn_opt_revision_t peg_revision, svn_opt_revision_t start_revision, svn_opt_revision_t end_revision, svn_boolean_t recurse, svn_boolean_t ignore_ancestry, svn_boolean_t no_diff_deleted, svn_boolean_t ignore_content_type, apr_file_t outfile, apr_file_t errfile, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_diff_peg2(*args)

def svn_client_diff_peg(*args):
    r"""svn_client_diff_peg(apr_array_header_t diff_options, char const * path, svn_opt_revision_t peg_revision, svn_opt_revision_t start_revision, svn_opt_revision_t end_revision, svn_boolean_t recurse, svn_boolean_t ignore_ancestry, svn_boolean_t no_diff_deleted, apr_file_t outfile, apr_file_t errfile, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_diff_peg(*args)

def svn_client_diff_summarize2(*args):
    r"""svn_client_diff_summarize2(char const * path_or_url1, svn_opt_revision_t revision1, char const * path_or_url2, svn_opt_revision_t revision2, svn_depth_t depth, svn_boolean_t ignore_ancestry, apr_array_header_t changelists, svn_client_diff_summarize_func_t summarize_func, void * summarize_baton, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_diff_summarize2(*args)

def svn_client_diff_summarize(*args):
    r"""svn_client_diff_summarize(char const * path1, svn_opt_revision_t revision1, char const * path2, svn_opt_revision_t revision2, svn_boolean_t recurse, svn_boolean_t ignore_ancestry, svn_client_diff_summarize_func_t summarize_func, void * summarize_baton, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_diff_summarize(*args)

def svn_client_diff_summarize_peg2(*args):
    r"""svn_client_diff_summarize_peg2(char const * path_or_url, svn_opt_revision_t peg_revision, svn_opt_revision_t start_revision, svn_opt_revision_t end_revision, svn_depth_t depth, svn_boolean_t ignore_ancestry, apr_array_header_t changelists, svn_client_diff_summarize_func_t summarize_func, void * summarize_baton, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_diff_summarize_peg2(*args)

def svn_client_diff_summarize_peg(*args):
    r"""svn_client_diff_summarize_peg(char const * path, svn_opt_revision_t peg_revision, svn_opt_revision_t start_revision, svn_opt_revision_t end_revision, svn_boolean_t recurse, svn_boolean_t ignore_ancestry, svn_client_diff_summarize_func_t summarize_func, void * summarize_baton, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_diff_summarize_peg(*args)

def svn_client_get_merging_summary(*args):
    r"""svn_client_get_merging_summary(char const * source_path_or_url, svn_opt_revision_t source_revision, char const * target_path_or_url, svn_opt_revision_t target_revision, svn_client_ctx_t ctx, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _client.svn_client_get_merging_summary(*args)

def svn_client_merge5(*args):
    r"""svn_client_merge5(char const * source1, svn_opt_revision_t revision1, char const * source2, svn_opt_revision_t revision2, char const * target_wcpath, svn_depth_t depth, svn_boolean_t ignore_mergeinfo, svn_boolean_t diff_ignore_ancestry, svn_boolean_t force_delete, svn_boolean_t record_only, svn_boolean_t dry_run, svn_boolean_t allow_mixed_rev, apr_array_header_t merge_options, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_merge5(*args)

def svn_client_merge4(*args):
    r"""svn_client_merge4(char const * source1, svn_opt_revision_t revision1, char const * source2, svn_opt_revision_t revision2, char const * target_wcpath, svn_depth_t depth, svn_boolean_t ignore_ancestry, svn_boolean_t force_delete, svn_boolean_t record_only, svn_boolean_t dry_run, svn_boolean_t allow_mixed_rev, apr_array_header_t merge_options, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_merge4(*args)

def svn_client_merge3(*args):
    r"""svn_client_merge3(char const * source1, svn_opt_revision_t revision1, char const * source2, svn_opt_revision_t revision2, char const * target_wcpath, svn_depth_t depth, svn_boolean_t ignore_ancestry, svn_boolean_t force, svn_boolean_t record_only, svn_boolean_t dry_run, apr_array_header_t merge_options, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_merge3(*args)

def svn_client_merge2(*args):
    r"""svn_client_merge2(char const * source1, svn_opt_revision_t revision1, char const * source2, svn_opt_revision_t revision2, char const * target_wcpath, svn_boolean_t recurse, svn_boolean_t ignore_ancestry, svn_boolean_t force, svn_boolean_t dry_run, apr_array_header_t merge_options, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_merge2(*args)

def svn_client_merge(*args):
    r"""svn_client_merge(char const * source1, svn_opt_revision_t revision1, char const * source2, svn_opt_revision_t revision2, char const * target_wcpath, svn_boolean_t recurse, svn_boolean_t ignore_ancestry, svn_boolean_t force, svn_boolean_t dry_run, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_merge(*args)

def svn_client_merge_reintegrate(*args):
    r"""svn_client_merge_reintegrate(char const * source_path_or_url, svn_opt_revision_t source_peg_revision, char const * target_wcpath, svn_boolean_t dry_run, apr_array_header_t merge_options, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_merge_reintegrate(*args)

def svn_client_merge_peg5(*args):
    r"""svn_client_merge_peg5(char const * source_path_or_url, apr_array_header_t ranges_to_merge, svn_opt_revision_t source_peg_revision, char const * target_wcpath, svn_depth_t depth, svn_boolean_t ignore_mergeinfo, svn_boolean_t diff_ignore_ancestry, svn_boolean_t force_delete, svn_boolean_t record_only, svn_boolean_t dry_run, svn_boolean_t allow_mixed_rev, apr_array_header_t merge_options, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_merge_peg5(*args)

def svn_client_merge_peg4(*args):
    r"""svn_client_merge_peg4(char const * source_path_or_url, apr_array_header_t ranges_to_merge, svn_opt_revision_t source_peg_revision, char const * target_wcpath, svn_depth_t depth, svn_boolean_t ignore_ancestry, svn_boolean_t force_delete, svn_boolean_t record_only, svn_boolean_t dry_run, svn_boolean_t allow_mixed_rev, apr_array_header_t merge_options, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_merge_peg4(*args)

def svn_client_merge_peg3(*args):
    r"""svn_client_merge_peg3(char const * source, apr_array_header_t ranges_to_merge, svn_opt_revision_t peg_revision, char const * target_wcpath, svn_depth_t depth, svn_boolean_t ignore_ancestry, svn_boolean_t force, svn_boolean_t record_only, svn_boolean_t dry_run, apr_array_header_t merge_options, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_merge_peg3(*args)

def svn_client_merge_peg2(*args):
    r"""svn_client_merge_peg2(char const * source, svn_opt_revision_t revision1, svn_opt_revision_t revision2, svn_opt_revision_t peg_revision, char const * target_wcpath, svn_boolean_t recurse, svn_boolean_t ignore_ancestry, svn_boolean_t force, svn_boolean_t dry_run, apr_array_header_t merge_options, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_merge_peg2(*args)

def svn_client_merge_peg(*args):
    r"""svn_client_merge_peg(char const * source, svn_opt_revision_t revision1, svn_opt_revision_t revision2, svn_opt_revision_t peg_revision, char const * target_wcpath, svn_boolean_t recurse, svn_boolean_t ignore_ancestry, svn_boolean_t force, svn_boolean_t dry_run, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_merge_peg(*args)

def svn_client_suggest_merge_sources(*args):
    r"""svn_client_suggest_merge_sources(char const * path_or_url, svn_opt_revision_t peg_revision, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_suggest_merge_sources(*args)

def svn_client_mergeinfo_get_merged(*args):
    r"""svn_client_mergeinfo_get_merged(char const * path_or_url, svn_opt_revision_t peg_revision, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_mergeinfo_get_merged(*args)

def svn_client_mergeinfo_log2(*args):
    r"""svn_client_mergeinfo_log2(svn_boolean_t finding_merged, char const * target_path_or_url, svn_opt_revision_t target_peg_revision, char const * source_path_or_url, svn_opt_revision_t source_peg_revision, svn_opt_revision_t source_start_revision, svn_opt_revision_t source_end_revision, svn_log_entry_receiver_t receiver, svn_boolean_t discover_changed_paths, svn_depth_t depth, apr_array_header_t revprops, svn_client_ctx_t ctx, apr_pool_t scratch_pool) -> svn_error_t"""
    return _client.svn_client_mergeinfo_log2(*args)

def svn_client_mergeinfo_log(*args):
    r"""svn_client_mergeinfo_log(svn_boolean_t finding_merged, char const * target_path_or_url, svn_opt_revision_t target_peg_revision, char const * source_path_or_url, svn_opt_revision_t source_peg_revision, svn_log_entry_receiver_t receiver, svn_boolean_t discover_changed_paths, svn_depth_t depth, apr_array_header_t revprops, svn_client_ctx_t ctx, apr_pool_t scratch_pool) -> svn_error_t"""
    return _client.svn_client_mergeinfo_log(*args)

def svn_client_mergeinfo_log_merged(*args):
    r"""svn_client_mergeinfo_log_merged(char const * path_or_url, svn_opt_revision_t peg_revision, char const * merge_source_path_or_url, svn_opt_revision_t src_peg_revision, svn_log_entry_receiver_t receiver, svn_boolean_t discover_changed_paths, apr_array_header_t revprops, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_mergeinfo_log_merged(*args)

def svn_client_mergeinfo_log_eligible(*args):
    r"""svn_client_mergeinfo_log_eligible(char const * path_or_url, svn_opt_revision_t peg_revision, char const * merge_source_path_or_url, svn_opt_revision_t src_peg_revision, svn_log_entry_receiver_t receiver, svn_boolean_t discover_changed_paths, apr_array_header_t revprops, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_mergeinfo_log_eligible(*args)

def svn_client_vacuum(*args):
    r"""svn_client_vacuum(char const * dir_abspath, svn_boolean_t remove_unversioned_items, svn_boolean_t remove_ignored_items, svn_boolean_t fix_recorded_timestamps, svn_boolean_t vacuum_pristines, svn_boolean_t include_externals, svn_client_ctx_t ctx, apr_pool_t scratch_pool) -> svn_error_t"""
    return _client.svn_client_vacuum(*args)

def svn_client_cleanup2(*args):
    r"""svn_client_cleanup2(char const * dir_abspath, svn_boolean_t break_locks, svn_boolean_t fix_recorded_timestamps, svn_boolean_t clear_dav_cache, svn_boolean_t vacuum_pristines, svn_boolean_t include_externals, svn_client_ctx_t ctx, apr_pool_t scratch_pool) -> svn_error_t"""
    return _client.svn_client_cleanup2(*args)

def svn_client_cleanup(*args):
    r"""svn_client_cleanup(char const * dir, svn_client_ctx_t ctx, apr_pool_t scratch_pool) -> svn_error_t"""
    return _client.svn_client_cleanup(*args)

def svn_client_upgrade(*args):
    r"""svn_client_upgrade(char const * wcroot_dir, svn_client_ctx_t ctx, apr_pool_t scratch_pool) -> svn_error_t"""
    return _client.svn_client_upgrade(*args)

def svn_client_relocate2(*args):
    r"""svn_client_relocate2(char const * wcroot_dir, char const * from_prefix, char const * to_prefix, svn_boolean_t ignore_externals, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_relocate2(*args)

def svn_client_relocate(*args):
    r"""svn_client_relocate(char const * dir, char const * from_prefix, char const * to_prefix, svn_boolean_t recurse, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_relocate(*args)

def svn_client_revert4(*args):
    r"""svn_client_revert4(apr_array_header_t paths, svn_depth_t depth, apr_array_header_t changelists, svn_boolean_t clear_changelists, svn_boolean_t metadata_only, svn_boolean_t added_keep_local, svn_client_ctx_t ctx, apr_pool_t scratch_pool) -> svn_error_t"""
    return _client.svn_client_revert4(*args)

def svn_client_revert3(*args):
    r"""svn_client_revert3(apr_array_header_t paths, svn_depth_t depth, apr_array_header_t changelists, svn_boolean_t clear_changelists, svn_boolean_t metadata_only, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_revert3(*args)

def svn_client_revert2(*args):
    r"""svn_client_revert2(apr_array_header_t paths, svn_depth_t depth, apr_array_header_t changelists, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_revert2(*args)

def svn_client_revert(*args):
    r"""svn_client_revert(apr_array_header_t paths, svn_boolean_t recursive, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_revert(*args)
svn_client_conflict_option_undefined = _client.svn_client_conflict_option_undefined

svn_client_conflict_option_postpone = _client.svn_client_conflict_option_postpone

svn_client_conflict_option_base_text = _client.svn_client_conflict_option_base_text

svn_client_conflict_option_incoming_text = _client.svn_client_conflict_option_incoming_text

svn_client_conflict_option_working_text = _client.svn_client_conflict_option_working_text

svn_client_conflict_option_incoming_text_where_conflicted = _client.svn_client_conflict_option_incoming_text_where_conflicted

svn_client_conflict_option_working_text_where_conflicted = _client.svn_client_conflict_option_working_text_where_conflicted

svn_client_conflict_option_merged_text = _client.svn_client_conflict_option_merged_text

svn_client_conflict_option_unspecified = _client.svn_client_conflict_option_unspecified

svn_client_conflict_option_accept_current_wc_state = _client.svn_client_conflict_option_accept_current_wc_state

svn_client_conflict_option_update_move_destination = _client.svn_client_conflict_option_update_move_destination

svn_client_conflict_option_update_any_moved_away_children = _client.svn_client_conflict_option_update_any_moved_away_children

svn_client_conflict_option_incoming_add_ignore = _client.svn_client_conflict_option_incoming_add_ignore

svn_client_conflict_option_incoming_added_file_text_merge = _client.svn_client_conflict_option_incoming_added_file_text_merge

svn_client_conflict_option_incoming_added_file_replace_and_merge = _client.svn_client_conflict_option_incoming_added_file_replace_and_merge

svn_client_conflict_option_incoming_added_dir_merge = _client.svn_client_conflict_option_incoming_added_dir_merge

svn_client_conflict_option_incoming_added_dir_replace = _client.svn_client_conflict_option_incoming_added_dir_replace

svn_client_conflict_option_incoming_added_dir_replace_and_merge = _client.svn_client_conflict_option_incoming_added_dir_replace_and_merge

svn_client_conflict_option_incoming_delete_ignore = _client.svn_client_conflict_option_incoming_delete_ignore

svn_client_conflict_option_incoming_delete_accept = _client.svn_client_conflict_option_incoming_delete_accept

svn_client_conflict_option_incoming_move_file_text_merge = _client.svn_client_conflict_option_incoming_move_file_text_merge

svn_client_conflict_option_incoming_move_dir_merge = _client.svn_client_conflict_option_incoming_move_dir_merge

svn_client_conflict_option_local_move_file_text_merge = _client.svn_client_conflict_option_local_move_file_text_merge

svn_client_conflict_option_local_move_dir_merge = _client.svn_client_conflict_option_local_move_dir_merge

svn_client_conflict_option_sibling_move_file_text_merge = _client.svn_client_conflict_option_sibling_move_file_text_merge

svn_client_conflict_option_sibling_move_dir_merge = _client.svn_client_conflict_option_sibling_move_dir_merge

svn_client_conflict_option_both_moved_file_merge = _client.svn_client_conflict_option_both_moved_file_merge

svn_client_conflict_option_both_moved_file_move_merge = _client.svn_client_conflict_option_both_moved_file_move_merge

svn_client_conflict_option_both_moved_dir_merge = _client.svn_client_conflict_option_both_moved_dir_merge

svn_client_conflict_option_both_moved_dir_move_merge = _client.svn_client_conflict_option_both_moved_dir_move_merge


def svn_client_conflict_option_set_merged_propval(option, merged_propval):
    r"""svn_client_conflict_option_set_merged_propval(svn_client_conflict_option_t option, svn_string_t const * merged_propval)"""
    return _client.svn_client_conflict_option_set_merged_propval(option, merged_propval)

def svn_client_conflict_option_get_moved_to_repos_relpath_candidates2(*args):
    r"""svn_client_conflict_option_get_moved_to_repos_relpath_candidates2(svn_client_conflict_option_t option, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _client.svn_client_conflict_option_get_moved_to_repos_relpath_candidates2(*args)

def svn_client_conflict_option_get_moved_to_repos_relpath_candidates(*args):
    r"""svn_client_conflict_option_get_moved_to_repos_relpath_candidates(svn_client_conflict_option_t option, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _client.svn_client_conflict_option_get_moved_to_repos_relpath_candidates(*args)

def svn_client_conflict_option_set_moved_to_repos_relpath2(*args):
    r"""svn_client_conflict_option_set_moved_to_repos_relpath2(svn_client_conflict_option_t option, int preferred_move_target_idx, svn_client_ctx_t ctx, apr_pool_t scratch_pool) -> svn_error_t"""
    return _client.svn_client_conflict_option_set_moved_to_repos_relpath2(*args)

def svn_client_conflict_option_set_moved_to_repos_relpath(*args):
    r"""svn_client_conflict_option_set_moved_to_repos_relpath(svn_client_conflict_option_t option, int preferred_move_target_idx, svn_client_ctx_t ctx, apr_pool_t scratch_pool) -> svn_error_t"""
    return _client.svn_client_conflict_option_set_moved_to_repos_relpath(*args)

def svn_client_conflict_option_get_moved_to_abspath_candidates2(*args):
    r"""svn_client_conflict_option_get_moved_to_abspath_candidates2(svn_client_conflict_option_t option, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _client.svn_client_conflict_option_get_moved_to_abspath_candidates2(*args)

def svn_client_conflict_option_get_moved_to_abspath_candidates(*args):
    r"""svn_client_conflict_option_get_moved_to_abspath_candidates(svn_client_conflict_option_t option, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _client.svn_client_conflict_option_get_moved_to_abspath_candidates(*args)

def svn_client_conflict_option_set_moved_to_abspath2(*args):
    r"""svn_client_conflict_option_set_moved_to_abspath2(svn_client_conflict_option_t option, int preferred_move_target_idx, svn_client_ctx_t ctx, apr_pool_t scratch_pool) -> svn_error_t"""
    return _client.svn_client_conflict_option_set_moved_to_abspath2(*args)

def svn_client_conflict_option_set_moved_to_abspath(*args):
    r"""svn_client_conflict_option_set_moved_to_abspath(svn_client_conflict_option_t option, int preferred_move_target_idx, svn_client_ctx_t ctx, apr_pool_t scratch_pool) -> svn_error_t"""
    return _client.svn_client_conflict_option_set_moved_to_abspath(*args)

def svn_client_conflict_option_find_by_id(options, option_id):
    r"""svn_client_conflict_option_find_by_id(apr_array_header_t options, svn_client_conflict_option_id_t option_id) -> svn_client_conflict_option_t"""
    return _client.svn_client_conflict_option_find_by_id(options, option_id)

def svn_client_conflict_get(*args):
    r"""svn_client_conflict_get(char const * local_abspath, svn_client_ctx_t ctx, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _client.svn_client_conflict_get(*args)

def svn_client_conflict_walk(*args):
    r"""svn_client_conflict_walk(char const * local_abspath, svn_depth_t depth, svn_client_conflict_walk_func_t conflict_walk_func, void * conflict_walk_func_baton, svn_client_ctx_t ctx, apr_pool_t scratch_pool) -> svn_error_t"""
    return _client.svn_client_conflict_walk(*args)

def svn_client_conflict_get_conflicted(*args):
    r"""svn_client_conflict_get_conflicted(svn_client_conflict_t conflict, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _client.svn_client_conflict_get_conflicted(*args)

def svn_client_conflict_prop_get_description(*args):
    r"""svn_client_conflict_prop_get_description(svn_client_conflict_t conflict, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _client.svn_client_conflict_prop_get_description(*args)

def svn_client_conflict_tree_get_description(*args):
    r"""svn_client_conflict_tree_get_description(svn_client_conflict_t conflict, svn_client_ctx_t ctx, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _client.svn_client_conflict_tree_get_description(*args)

def svn_client_conflict_text_get_resolution_options(*args):
    r"""svn_client_conflict_text_get_resolution_options(svn_client_conflict_t conflict, svn_client_ctx_t ctx, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _client.svn_client_conflict_text_get_resolution_options(*args)

def svn_client_conflict_prop_get_resolution_options(*args):
    r"""svn_client_conflict_prop_get_resolution_options(svn_client_conflict_t conflict, svn_client_ctx_t ctx, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _client.svn_client_conflict_prop_get_resolution_options(*args)

def svn_client_conflict_tree_get_resolution_options(*args):
    r"""svn_client_conflict_tree_get_resolution_options(svn_client_conflict_t conflict, svn_client_ctx_t ctx, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _client.svn_client_conflict_tree_get_resolution_options(*args)

def svn_client_conflict_tree_get_details(*args):
    r"""svn_client_conflict_tree_get_details(svn_client_conflict_t conflict, svn_client_ctx_t ctx, apr_pool_t scratch_pool) -> svn_error_t"""
    return _client.svn_client_conflict_tree_get_details(*args)

def svn_client_conflict_option_get_id(option):
    r"""svn_client_conflict_option_get_id(svn_client_conflict_option_t option) -> svn_client_conflict_option_id_t"""
    return _client.svn_client_conflict_option_get_id(option)

def svn_client_conflict_option_get_label(*args):
    r"""svn_client_conflict_option_get_label(svn_client_conflict_option_t option, apr_pool_t result_pool) -> char const *"""
    return _client.svn_client_conflict_option_get_label(*args)

def svn_client_conflict_option_get_description(*args):
    r"""svn_client_conflict_option_get_description(svn_client_conflict_option_t option, apr_pool_t result_pool) -> char const *"""
    return _client.svn_client_conflict_option_get_description(*args)

def svn_client_conflict_get_recommended_option_id(conflict):
    r"""svn_client_conflict_get_recommended_option_id(svn_client_conflict_t conflict) -> svn_client_conflict_option_id_t"""
    return _client.svn_client_conflict_get_recommended_option_id(conflict)

def svn_client_conflict_get_local_abspath(conflict):
    r"""svn_client_conflict_get_local_abspath(svn_client_conflict_t conflict) -> char const *"""
    return _client.svn_client_conflict_get_local_abspath(conflict)

def svn_client_conflict_get_operation(conflict):
    r"""svn_client_conflict_get_operation(svn_client_conflict_t conflict) -> svn_wc_operation_t"""
    return _client.svn_client_conflict_get_operation(conflict)

def svn_client_conflict_get_incoming_change(conflict):
    r"""svn_client_conflict_get_incoming_change(svn_client_conflict_t conflict) -> svn_wc_conflict_action_t"""
    return _client.svn_client_conflict_get_incoming_change(conflict)

def svn_client_conflict_get_local_change(conflict):
    r"""svn_client_conflict_get_local_change(svn_client_conflict_t conflict) -> svn_wc_conflict_reason_t"""
    return _client.svn_client_conflict_get_local_change(conflict)

def svn_client_conflict_get_repos_info(*args):
    r"""svn_client_conflict_get_repos_info(svn_client_conflict_t conflict, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _client.svn_client_conflict_get_repos_info(*args)

def svn_client_conflict_get_incoming_old_repos_location(*args):
    r"""svn_client_conflict_get_incoming_old_repos_location(svn_client_conflict_t conflict, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _client.svn_client_conflict_get_incoming_old_repos_location(*args)

def svn_client_conflict_get_incoming_new_repos_location(*args):
    r"""svn_client_conflict_get_incoming_new_repos_location(svn_client_conflict_t conflict, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _client.svn_client_conflict_get_incoming_new_repos_location(*args)

def svn_client_conflict_tree_get_victim_node_kind(conflict):
    r"""svn_client_conflict_tree_get_victim_node_kind(svn_client_conflict_t conflict) -> svn_node_kind_t"""
    return _client.svn_client_conflict_tree_get_victim_node_kind(conflict)

def svn_client_conflict_tree_resolve(*args):
    r"""svn_client_conflict_tree_resolve(svn_client_conflict_t conflict, svn_client_conflict_option_t option, svn_client_ctx_t ctx, apr_pool_t scratch_pool) -> svn_error_t"""
    return _client.svn_client_conflict_tree_resolve(*args)

def svn_client_conflict_tree_resolve_by_id(*args):
    r"""svn_client_conflict_tree_resolve_by_id(svn_client_conflict_t conflict, svn_client_conflict_option_id_t option_id, svn_client_ctx_t ctx, apr_pool_t scratch_pool) -> svn_error_t"""
    return _client.svn_client_conflict_tree_resolve_by_id(*args)

def svn_client_conflict_tree_get_resolution(conflict):
    r"""svn_client_conflict_tree_get_resolution(svn_client_conflict_t conflict) -> svn_client_conflict_option_id_t"""
    return _client.svn_client_conflict_tree_get_resolution(conflict)

def svn_client_conflict_prop_get_reject_abspath(conflict):
    r"""svn_client_conflict_prop_get_reject_abspath(svn_client_conflict_t conflict) -> char const *"""
    return _client.svn_client_conflict_prop_get_reject_abspath(conflict)

def svn_client_conflict_prop_get_propvals(*args):
    r"""svn_client_conflict_prop_get_propvals(svn_client_conflict_t conflict, char const * propname, apr_pool_t result_pool) -> svn_error_t"""
    return _client.svn_client_conflict_prop_get_propvals(*args)

def svn_client_conflict_prop_resolve(*args):
    r"""svn_client_conflict_prop_resolve(svn_client_conflict_t conflict, char const * propname, svn_client_conflict_option_t option, svn_client_ctx_t ctx, apr_pool_t scratch_pool) -> svn_error_t"""
    return _client.svn_client_conflict_prop_resolve(*args)

def svn_client_conflict_prop_resolve_by_id(*args):
    r"""svn_client_conflict_prop_resolve_by_id(svn_client_conflict_t conflict, char const * propname, svn_client_conflict_option_id_t option_id, svn_client_ctx_t ctx, apr_pool_t scratch_pool) -> svn_error_t"""
    return _client.svn_client_conflict_prop_resolve_by_id(*args)

def svn_client_conflict_prop_get_resolution(conflict, propname):
    r"""svn_client_conflict_prop_get_resolution(svn_client_conflict_t conflict, char const * propname) -> svn_client_conflict_option_id_t"""
    return _client.svn_client_conflict_prop_get_resolution(conflict, propname)

def svn_client_conflict_text_get_mime_type(conflict):
    r"""svn_client_conflict_text_get_mime_type(svn_client_conflict_t conflict) -> char const *"""
    return _client.svn_client_conflict_text_get_mime_type(conflict)

def svn_client_conflict_text_get_contents(*args):
    r"""svn_client_conflict_text_get_contents(svn_client_conflict_t conflict, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _client.svn_client_conflict_text_get_contents(*args)

def svn_client_conflict_text_resolve(*args):
    r"""svn_client_conflict_text_resolve(svn_client_conflict_t conflict, svn_client_conflict_option_t option, svn_client_ctx_t ctx, apr_pool_t scratch_pool) -> svn_error_t"""
    return _client.svn_client_conflict_text_resolve(*args)

def svn_client_conflict_text_resolve_by_id(*args):
    r"""svn_client_conflict_text_resolve_by_id(svn_client_conflict_t conflict, svn_client_conflict_option_id_t option_id, svn_client_ctx_t ctx, apr_pool_t scratch_pool) -> svn_error_t"""
    return _client.svn_client_conflict_text_resolve_by_id(*args)

def svn_client_conflict_text_get_resolution(conflict):
    r"""svn_client_conflict_text_get_resolution(svn_client_conflict_t conflict) -> svn_client_conflict_option_id_t"""
    return _client.svn_client_conflict_text_get_resolution(conflict)

def svn_client_resolved(*args):
    r"""svn_client_resolved(char const * path, svn_boolean_t recursive, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_resolved(*args)

def svn_client_resolve(*args):
    r"""svn_client_resolve(char const * path, svn_depth_t depth, svn_wc_conflict_choice_t conflict_choice, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_resolve(*args)
class svn_client_copy_source_t(object):
    r"""Proxy of C svn_client_copy_source_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    path = property(_client.svn_client_copy_source_t_path_get, _client.svn_client_copy_source_t_path_set, doc=r"""path : p.q(const).char""")
    revision = property(_client.svn_client_copy_source_t_revision_get, _client.svn_client_copy_source_t_revision_set, doc=r"""revision : p.q(const).svn_opt_revision_t""")
    peg_revision = property(_client.svn_client_copy_source_t_peg_revision_get, _client.svn_client_copy_source_t_peg_revision_set, doc=r"""peg_revision : p.q(const).svn_opt_revision_t""")
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __init__(self):
        r"""__init__(svn_client_copy_source_t self) -> svn_client_copy_source_t"""
        _client.svn_client_copy_source_t_swiginit(self, _client.new_svn_client_copy_source_t())
    __swig_destroy__ = _client.delete_svn_client_copy_source_t

# Register svn_client_copy_source_t in _client:
_client.svn_client_copy_source_t_swigregister(svn_client_copy_source_t)

def svn_client_copy7(*args):
    r"""svn_client_copy7(apr_array_header_t sources, char const * dst_path, svn_boolean_t copy_as_child, svn_boolean_t make_parents, svn_boolean_t ignore_externals, svn_boolean_t metadata_only, svn_boolean_t pin_externals, apr_hash_t externals_to_pin, apr_hash_t revprop_table, svn_commit_callback2_t commit_callback, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_copy7(*args)

def svn_client_copy6(*args):
    r"""svn_client_copy6(apr_array_header_t sources, char const * dst_path, svn_boolean_t copy_as_child, svn_boolean_t make_parents, svn_boolean_t ignore_externals, apr_hash_t revprop_table, svn_commit_callback2_t commit_callback, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_copy6(*args)

def svn_client_copy5(*args):
    r"""svn_client_copy5(apr_array_header_t sources, char const * dst_path, svn_boolean_t copy_as_child, svn_boolean_t make_parents, svn_boolean_t ignore_externals, apr_hash_t revprop_table, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_copy5(*args)

def svn_client_copy4(*args):
    r"""svn_client_copy4(apr_array_header_t sources, char const * dst_path, svn_boolean_t copy_as_child, svn_boolean_t make_parents, apr_hash_t revprop_table, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_copy4(*args)

def svn_client_copy3(*args):
    r"""svn_client_copy3(char const * src_path, svn_opt_revision_t src_revision, char const * dst_path, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_copy3(*args)

def svn_client_copy2(*args):
    r"""svn_client_copy2(char const * src_path, svn_opt_revision_t src_revision, char const * dst_path, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_copy2(*args)

def svn_client_copy(*args):
    r"""svn_client_copy(char const * src_path, svn_opt_revision_t src_revision, char const * dst_path, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_copy(*args)

def svn_client_move7(*args):
    r"""svn_client_move7(apr_array_header_t src_paths, char const * dst_path, svn_boolean_t move_as_child, svn_boolean_t make_parents, svn_boolean_t allow_mixed_revisions, svn_boolean_t metadata_only, apr_hash_t revprop_table, svn_commit_callback2_t commit_callback, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_move7(*args)

def svn_client_move6(*args):
    r"""svn_client_move6(apr_array_header_t src_paths, char const * dst_path, svn_boolean_t move_as_child, svn_boolean_t make_parents, apr_hash_t revprop_table, svn_commit_callback2_t commit_callback, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_move6(*args)

def svn_client_move5(*args):
    r"""svn_client_move5(apr_array_header_t src_paths, char const * dst_path, svn_boolean_t force, svn_boolean_t move_as_child, svn_boolean_t make_parents, apr_hash_t revprop_table, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_move5(*args)

def svn_client_move4(*args):
    r"""svn_client_move4(char const * src_path, char const * dst_path, svn_boolean_t force, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_move4(*args)

def svn_client_move3(*args):
    r"""svn_client_move3(char const * src_path, char const * dst_path, svn_boolean_t force, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_move3(*args)

def svn_client_move2(*args):
    r"""svn_client_move2(char const * src_path, char const * dst_path, svn_boolean_t force, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_move2(*args)

def svn_client_move(*args):
    r"""svn_client_move(char const * src_path, svn_opt_revision_t src_revision, char const * dst_path, svn_boolean_t force, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_move(*args)

def svn_client_propset_remote(*args):
    r"""svn_client_propset_remote(char const * propname, svn_string_t const * propval, char const * url, svn_boolean_t skip_checks, svn_revnum_t base_revision_for_url, apr_hash_t revprop_table, svn_commit_callback2_t commit_callback, svn_client_ctx_t ctx, apr_pool_t scratch_pool) -> svn_error_t"""
    return _client.svn_client_propset_remote(*args)

def svn_client_propset_local(*args):
    r"""svn_client_propset_local(char const * propname, svn_string_t const * propval, apr_array_header_t targets, svn_depth_t depth, svn_boolean_t skip_checks, apr_array_header_t changelists, svn_client_ctx_t ctx, apr_pool_t scratch_pool) -> svn_error_t"""
    return _client.svn_client_propset_local(*args)

def svn_client_propset3(*args):
    r"""svn_client_propset3(char const * propname, svn_string_t const * propval, char const * target, svn_depth_t depth, svn_boolean_t skip_checks, svn_revnum_t base_revision_for_url, apr_array_header_t changelists, apr_hash_t revprop_table, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_propset3(*args)

def svn_client_propset2(*args):
    r"""svn_client_propset2(char const * propname, svn_string_t const * propval, char const * target, svn_boolean_t recurse, svn_boolean_t skip_checks, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_propset2(*args)

def svn_client_propset(*args):
    r"""svn_client_propset(char const * propname, svn_string_t const * propval, char const * target, svn_boolean_t recurse, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_propset(*args)

def svn_client_revprop_set2(*args):
    r"""svn_client_revprop_set2(char const * propname, svn_string_t const * propval, svn_string_t const * original_propval, char const * URL, svn_opt_revision_t revision, svn_boolean_t force, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_revprop_set2(*args)

def svn_client_revprop_set(*args):
    r"""svn_client_revprop_set(char const * propname, svn_string_t const * propval, char const * URL, svn_opt_revision_t revision, svn_boolean_t force, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_revprop_set(*args)

def svn_client_propget5(*args):
    r"""svn_client_propget5(char const * propname, char const * target, svn_opt_revision_t peg_revision, svn_opt_revision_t revision, svn_depth_t depth, apr_array_header_t changelists, svn_client_ctx_t ctx, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _client.svn_client_propget5(*args)

def svn_client_propget4(*args):
    r"""svn_client_propget4(char const * propname, char const * target, svn_opt_revision_t peg_revision, svn_opt_revision_t revision, svn_depth_t depth, apr_array_header_t changelists, svn_client_ctx_t ctx, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _client.svn_client_propget4(*args)

def svn_client_propget3(*args):
    r"""svn_client_propget3(char const * propname, char const * target, svn_opt_revision_t peg_revision, svn_opt_revision_t revision, svn_depth_t depth, apr_array_header_t changelists, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_propget3(*args)

def svn_client_propget2(*args):
    r"""svn_client_propget2(char const * propname, char const * target, svn_opt_revision_t peg_revision, svn_opt_revision_t revision, svn_boolean_t recurse, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_propget2(*args)

def svn_client_propget(*args):
    r"""svn_client_propget(char const * propname, char const * target, svn_opt_revision_t revision, svn_boolean_t recurse, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_propget(*args)

def svn_client_revprop_get(*args):
    r"""svn_client_revprop_get(char const * propname, char const * URL, svn_opt_revision_t revision, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_revprop_get(*args)

def svn_client_proplist4(*args):
    r"""svn_client_proplist4(char const * target, svn_opt_revision_t peg_revision, svn_opt_revision_t revision, svn_depth_t depth, apr_array_header_t changelists, svn_boolean_t get_target_inherited_props, svn_proplist_receiver2_t receiver, svn_client_ctx_t ctx, apr_pool_t scratch_pool) -> svn_error_t"""
    return _client.svn_client_proplist4(*args)

def svn_client_proplist3(*args):
    r"""svn_client_proplist3(char const * target, svn_opt_revision_t peg_revision, svn_opt_revision_t revision, svn_depth_t depth, apr_array_header_t changelists, svn_proplist_receiver_t receiver, void * receiver_baton, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_proplist3(*args)

def svn_client_proplist2(*args):
    r"""svn_client_proplist2(char const * target, svn_opt_revision_t peg_revision, svn_opt_revision_t revision, svn_boolean_t recurse, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_proplist2(*args)

def svn_client_proplist(*args):
    r"""svn_client_proplist(char const * target, svn_opt_revision_t revision, svn_boolean_t recurse, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_proplist(*args)

def svn_client_revprop_list(*args):
    r"""svn_client_revprop_list(char const * URL, svn_opt_revision_t revision, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_revprop_list(*args)

def svn_client_export5(*args):
    r"""svn_client_export5(char const * from_path_or_url, char const * to_path, svn_opt_revision_t peg_revision, svn_opt_revision_t revision, svn_boolean_t overwrite, svn_boolean_t ignore_externals, svn_boolean_t ignore_keywords, svn_depth_t depth, char const * native_eol, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_export5(*args)

def svn_client_export4(*args):
    r"""svn_client_export4(char const * from_path_or_url, char const * to_path, svn_opt_revision_t peg_revision, svn_opt_revision_t revision, svn_boolean_t overwrite, svn_boolean_t ignore_externals, svn_depth_t depth, char const * native_eol, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_export4(*args)

def svn_client_export3(*args):
    r"""svn_client_export3(char const * from_path_or_url, char const * to_path, svn_opt_revision_t peg_revision, svn_opt_revision_t revision, svn_boolean_t overwrite, svn_boolean_t ignore_externals, svn_boolean_t recurse, char const * native_eol, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_export3(*args)

def svn_client_export2(*args):
    r"""svn_client_export2(char const * from_path_or_url, char const * to_path, svn_opt_revision_t revision, svn_boolean_t force, char const * native_eol, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_export2(*args)

def svn_client_export(*args):
    r"""svn_client_export(char const * from_path_or_url, char const * to_path, svn_opt_revision_t revision, svn_boolean_t force, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_export(*args)

def svn_client_list4(*args):
    r"""svn_client_list4(char const * path_or_url, svn_opt_revision_t peg_revision, svn_opt_revision_t revision, apr_array_header_t patterns, svn_depth_t depth, apr_uint32_t dirent_fields, svn_boolean_t fetch_locks, svn_boolean_t include_externals, svn_client_list_func2_t list_func, void * baton, svn_client_ctx_t ctx, apr_pool_t scratch_pool) -> svn_error_t"""
    return _client.svn_client_list4(*args)

def svn_client_list3(*args):
    r"""svn_client_list3(char const * path_or_url, svn_opt_revision_t peg_revision, svn_opt_revision_t revision, svn_depth_t depth, apr_uint32_t dirent_fields, svn_boolean_t fetch_locks, svn_boolean_t include_externals, svn_client_list_func2_t list_func, void * baton, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_list3(*args)

def svn_client_list2(*args):
    r"""svn_client_list2(char const * path_or_url, svn_opt_revision_t peg_revision, svn_opt_revision_t revision, svn_depth_t depth, apr_uint32_t dirent_fields, svn_boolean_t fetch_locks, svn_client_list_func_t list_func, void * baton, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_list2(*args)

def svn_client_list(*args):
    r"""svn_client_list(char const * path_or_url, svn_opt_revision_t peg_revision, svn_opt_revision_t revision, svn_boolean_t recurse, apr_uint32_t dirent_fields, svn_boolean_t fetch_locks, svn_client_list_func_t list_func, void * baton, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_list(*args)

def svn_client_ls3(*args):
    r"""svn_client_ls3(char const * path_or_url, svn_opt_revision_t peg_revision, svn_opt_revision_t revision, svn_boolean_t recurse, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_ls3(*args)

def svn_client_ls2(*args):
    r"""svn_client_ls2(char const * path_or_url, svn_opt_revision_t peg_revision, svn_opt_revision_t revision, svn_boolean_t recurse, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_ls2(*args)

def svn_client_ls(*args):
    r"""svn_client_ls(char const * path_or_url, svn_opt_revision_t revision, svn_boolean_t recurse, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_ls(*args)

def svn_client_cat3(*args):
    r"""svn_client_cat3(svn_stream_t out, char const * path_or_url, svn_opt_revision_t peg_revision, svn_opt_revision_t revision, svn_boolean_t expand_keywords, svn_client_ctx_t ctx, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _client.svn_client_cat3(*args)

def svn_client_cat2(*args):
    r"""svn_client_cat2(svn_stream_t out, char const * path_or_url, svn_opt_revision_t peg_revision, svn_opt_revision_t revision, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_cat2(*args)

def svn_client_cat(*args):
    r"""svn_client_cat(svn_stream_t out, char const * path_or_url, svn_opt_revision_t revision, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_cat(*args)

def svn_client_add_to_changelist(*args):
    r"""svn_client_add_to_changelist(apr_array_header_t paths, char const * changelist, svn_depth_t depth, apr_array_header_t changelists, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_add_to_changelist(*args)

def svn_client_remove_from_changelists(*args):
    r"""svn_client_remove_from_changelists(apr_array_header_t paths, svn_depth_t depth, apr_array_header_t changelists, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_remove_from_changelists(*args)

def svn_client_get_changelists(*args):
    r"""svn_client_get_changelists(char const * path, apr_array_header_t changelists, svn_depth_t depth, svn_changelist_receiver_t callback_func, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_get_changelists(*args)

def svn_client_lock(*args):
    r"""svn_client_lock(apr_array_header_t targets, char const * comment, svn_boolean_t steal_lock, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_lock(*args)

def svn_client_unlock(*args):
    r"""svn_client_unlock(apr_array_header_t targets, svn_boolean_t break_lock, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_unlock(*args)
class svn_info_t(object):
    r"""Proxy of C svn_info_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    URL = property(_client.svn_info_t_URL_get, _client.svn_info_t_URL_set, doc=r"""URL : p.q(const).char""")
    rev = property(_client.svn_info_t_rev_get, _client.svn_info_t_rev_set, doc=r"""rev : svn_revnum_t""")
    kind = property(_client.svn_info_t_kind_get, _client.svn_info_t_kind_set, doc=r"""kind : svn_node_kind_t""")
    repos_root_URL = property(_client.svn_info_t_repos_root_URL_get, _client.svn_info_t_repos_root_URL_set, doc=r"""repos_root_URL : p.q(const).char""")
    repos_UUID = property(_client.svn_info_t_repos_UUID_get, _client.svn_info_t_repos_UUID_set, doc=r"""repos_UUID : p.q(const).char""")
    last_changed_rev = property(_client.svn_info_t_last_changed_rev_get, _client.svn_info_t_last_changed_rev_set, doc=r"""last_changed_rev : svn_revnum_t""")
    last_changed_date = property(_client.svn_info_t_last_changed_date_get, _client.svn_info_t_last_changed_date_set, doc=r"""last_changed_date : apr_time_t""")
    last_changed_author = property(_client.svn_info_t_last_changed_author_get, _client.svn_info_t_last_changed_author_set, doc=r"""last_changed_author : p.q(const).char""")
    lock = property(_client.svn_info_t_lock_get, _client.svn_info_t_lock_set, doc=r"""lock : p.svn_lock_t""")
    has_wc_info = property(_client.svn_info_t_has_wc_info_get, _client.svn_info_t_has_wc_info_set, doc=r"""has_wc_info : svn_boolean_t""")
    schedule = property(_client.svn_info_t_schedule_get, _client.svn_info_t_schedule_set, doc=r"""schedule : svn_wc_schedule_t""")
    copyfrom_url = property(_client.svn_info_t_copyfrom_url_get, _client.svn_info_t_copyfrom_url_set, doc=r"""copyfrom_url : p.q(const).char""")
    copyfrom_rev = property(_client.svn_info_t_copyfrom_rev_get, _client.svn_info_t_copyfrom_rev_set, doc=r"""copyfrom_rev : svn_revnum_t""")
    text_time = property(_client.svn_info_t_text_time_get, _client.svn_info_t_text_time_set, doc=r"""text_time : apr_time_t""")
    prop_time = property(_client.svn_info_t_prop_time_get, _client.svn_info_t_prop_time_set, doc=r"""prop_time : apr_time_t""")
    checksum = property(_client.svn_info_t_checksum_get, _client.svn_info_t_checksum_set, doc=r"""checksum : p.q(const).char""")
    conflict_old = property(_client.svn_info_t_conflict_old_get, _client.svn_info_t_conflict_old_set, doc=r"""conflict_old : p.q(const).char""")
    conflict_new = property(_client.svn_info_t_conflict_new_get, _client.svn_info_t_conflict_new_set, doc=r"""conflict_new : p.q(const).char""")
    conflict_wrk = property(_client.svn_info_t_conflict_wrk_get, _client.svn_info_t_conflict_wrk_set, doc=r"""conflict_wrk : p.q(const).char""")
    prejfile = property(_client.svn_info_t_prejfile_get, _client.svn_info_t_prejfile_set, doc=r"""prejfile : p.q(const).char""")
    changelist = property(_client.svn_info_t_changelist_get, _client.svn_info_t_changelist_set, doc=r"""changelist : p.q(const).char""")
    depth = property(_client.svn_info_t_depth_get, _client.svn_info_t_depth_set, doc=r"""depth : svn_depth_t""")
    working_size = property(_client.svn_info_t_working_size_get, _client.svn_info_t_working_size_set, doc=r"""working_size : apr_size_t""")
    size = property(_client.svn_info_t_size_get, _client.svn_info_t_size_set, doc=r"""size : apr_size_t""")
    size64 = property(_client.svn_info_t_size64_get, _client.svn_info_t_size64_set, doc=r"""size64 : svn_filesize_t""")
    working_size64 = property(_client.svn_info_t_working_size64_get, _client.svn_info_t_working_size64_set, doc=r"""working_size64 : svn_filesize_t""")
    tree_conflict = property(_client.svn_info_t_tree_conflict_get, _client.svn_info_t_tree_conflict_set, doc=r"""tree_conflict : p.svn_wc_conflict_description_t""")
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __init__(self):
        r"""__init__(svn_info_t self) -> svn_info_t"""
        _client.svn_info_t_swiginit(self, _client.new_svn_info_t())
    __swig_destroy__ = _client.delete_svn_info_t

# Register svn_info_t in _client:
_client.svn_info_t_swigregister(svn_info_t)

def svn_info_dup(*args):
    r"""svn_info_dup(svn_info_t info, apr_pool_t pool) -> svn_info_t"""
    return _client.svn_info_dup(*args)
class svn_client_info2_t(object):
    r"""Proxy of C svn_client_info2_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    URL = property(_client.svn_client_info2_t_URL_get, _client.svn_client_info2_t_URL_set, doc=r"""URL : p.q(const).char""")
    rev = property(_client.svn_client_info2_t_rev_get, _client.svn_client_info2_t_rev_set, doc=r"""rev : svn_revnum_t""")
    repos_root_URL = property(_client.svn_client_info2_t_repos_root_URL_get, _client.svn_client_info2_t_repos_root_URL_set, doc=r"""repos_root_URL : p.q(const).char""")
    repos_UUID = property(_client.svn_client_info2_t_repos_UUID_get, _client.svn_client_info2_t_repos_UUID_set, doc=r"""repos_UUID : p.q(const).char""")
    kind = property(_client.svn_client_info2_t_kind_get, _client.svn_client_info2_t_kind_set, doc=r"""kind : svn_node_kind_t""")
    size = property(_client.svn_client_info2_t_size_get, _client.svn_client_info2_t_size_set, doc=r"""size : svn_filesize_t""")
    last_changed_rev = property(_client.svn_client_info2_t_last_changed_rev_get, _client.svn_client_info2_t_last_changed_rev_set, doc=r"""last_changed_rev : svn_revnum_t""")
    last_changed_date = property(_client.svn_client_info2_t_last_changed_date_get, _client.svn_client_info2_t_last_changed_date_set, doc=r"""last_changed_date : apr_time_t""")
    last_changed_author = property(_client.svn_client_info2_t_last_changed_author_get, _client.svn_client_info2_t_last_changed_author_set, doc=r"""last_changed_author : p.q(const).char""")
    lock = property(_client.svn_client_info2_t_lock_get, _client.svn_client_info2_t_lock_set, doc=r"""lock : p.q(const).svn_lock_t""")
    wc_info = property(_client.svn_client_info2_t_wc_info_get, _client.svn_client_info2_t_wc_info_set, doc=r"""wc_info : p.q(const).svn_wc_info_t""")
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __init__(self):
        r"""__init__(svn_client_info2_t self) -> svn_client_info2_t"""
        _client.svn_client_info2_t_swiginit(self, _client.new_svn_client_info2_t())
    __swig_destroy__ = _client.delete_svn_client_info2_t

# Register svn_client_info2_t in _client:
_client.svn_client_info2_t_swigregister(svn_client_info2_t)

def svn_client_info2_dup(*args):
    r"""svn_client_info2_dup(svn_client_info2_t info, apr_pool_t pool) -> svn_client_info2_t"""
    return _client.svn_client_info2_dup(*args)

def svn_client_info4(*args):
    r"""svn_client_info4(char const * abspath_or_url, svn_opt_revision_t peg_revision, svn_opt_revision_t revision, svn_depth_t depth, svn_boolean_t fetch_excluded, svn_boolean_t fetch_actual_only, svn_boolean_t include_externals, apr_array_header_t changelists, svn_client_info_receiver2_t receiver, void * receiver_baton, svn_client_ctx_t ctx, apr_pool_t scratch_pool) -> svn_error_t"""
    return _client.svn_client_info4(*args)

def svn_client_info3(*args):
    r"""svn_client_info3(char const * abspath_or_url, svn_opt_revision_t peg_revision, svn_opt_revision_t revision, svn_depth_t depth, svn_boolean_t fetch_excluded, svn_boolean_t fetch_actual_only, apr_array_header_t changelists, svn_client_info_receiver2_t receiver, void * receiver_baton, svn_client_ctx_t ctx, apr_pool_t scratch_pool) -> svn_error_t"""
    return _client.svn_client_info3(*args)

def svn_client_info2(*args):
    r"""svn_client_info2(char const * path_or_url, svn_opt_revision_t peg_revision, svn_opt_revision_t revision, svn_info_receiver_t receiver, svn_depth_t depth, apr_array_header_t changelists, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_info2(*args)

def svn_client_info(*args):
    r"""svn_client_info(char const * path_or_url, svn_opt_revision_t peg_revision, svn_opt_revision_t revision, svn_info_receiver_t receiver, svn_boolean_t recurse, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_info(*args)

def svn_client_get_wc_root(*args):
    r"""svn_client_get_wc_root(char const * local_abspath, svn_client_ctx_t ctx, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _client.svn_client_get_wc_root(*args)

def svn_client_min_max_revisions(*args):
    r"""svn_client_min_max_revisions(char const * local_abspath, svn_boolean_t committed, svn_client_ctx_t ctx, apr_pool_t scratch_pool) -> svn_error_t"""
    return _client.svn_client_min_max_revisions(*args)

def svn_client_patch(*args):
    r"""svn_client_patch(char const * patch_abspath, char const * wc_dir_abspath, svn_boolean_t dry_run, int strip_count, svn_boolean_t reverse, svn_boolean_t ignore_whitespace, svn_boolean_t remove_tempfiles, svn_client_patch_func_t patch_func, void * patch_baton, svn_client_ctx_t ctx, apr_pool_t scratch_pool) -> svn_error_t"""
    return _client.svn_client_patch(*args)

def svn_client_url_from_path2(*args):
    r"""svn_client_url_from_path2(char const * path_or_url, svn_client_ctx_t ctx, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _client.svn_client_url_from_path2(*args)

def svn_client_url_from_path(*args):
    r"""svn_client_url_from_path(char const * path_or_url, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_url_from_path(*args)

def svn_client_get_repos_root(*args):
    r"""svn_client_get_repos_root(char const * abspath_or_url, svn_client_ctx_t ctx, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _client.svn_client_get_repos_root(*args)

def svn_client_root_url_from_path(*args):
    r"""svn_client_root_url_from_path(char const * path_or_url, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_root_url_from_path(*args)

def svn_client_uuid_from_url(*args):
    r"""svn_client_uuid_from_url(char const * url, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_uuid_from_url(*args)

def svn_client_uuid_from_path2(*args):
    r"""svn_client_uuid_from_path2(char const * local_abspath, svn_client_ctx_t ctx, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _client.svn_client_uuid_from_path2(*args)

def svn_client_uuid_from_path(*args):
    r"""svn_client_uuid_from_path(char const * path, svn_wc_adm_access_t adm_access, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_uuid_from_path(*args)

def svn_client_open_ra_session2(*args):
    r"""svn_client_open_ra_session2(char const * url, char const * wri_abspath, svn_client_ctx_t ctx, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _client.svn_client_open_ra_session2(*args)

def svn_client_open_ra_session(*args):
    r"""svn_client_open_ra_session(char const * url, svn_client_ctx_t ctx, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_open_ra_session(*args)
class svn_client_conflict_t(object):
    r"""Proxy of C svn_client_conflict_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


# Register svn_client_conflict_t in _client:
_client.svn_client_conflict_t_swigregister(svn_client_conflict_t)
class svn_client_conflict_option_t(object):
    r"""Proxy of C svn_client_conflict_option_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


# Register svn_client_conflict_option_t in _client:
_client.svn_client_conflict_option_t_swigregister(svn_client_conflict_option_t)

def svn_proplist_invoke_receiver2(*args):
    r"""svn_proplist_invoke_receiver2(svn_proplist_receiver2_t _obj, void * baton, char const * path, apr_hash_t prop_hash, apr_array_header_t inherited_props, apr_pool_t scratch_pool) -> svn_error_t"""
    return _client.svn_proplist_invoke_receiver2(*args)

def svn_proplist_invoke_receiver(*args):
    r"""svn_proplist_invoke_receiver(svn_proplist_receiver_t _obj, void * baton, char const * path, apr_hash_t prop_hash, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_proplist_invoke_receiver(*args)

def svn_client_invoke_get_commit_log3(*args):
    r"""svn_client_invoke_get_commit_log3(svn_client_get_commit_log3_t _obj, apr_array_header_t commit_items, void * baton, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_invoke_get_commit_log3(*args)

def svn_client_invoke_get_commit_log2(*args):
    r"""svn_client_invoke_get_commit_log2(svn_client_get_commit_log2_t _obj, apr_array_header_t commit_items, void * baton, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_invoke_get_commit_log2(*args)

def svn_client_invoke_get_commit_log(*args):
    r"""svn_client_invoke_get_commit_log(svn_client_get_commit_log_t _obj, apr_array_header_t commit_items, void * baton, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_invoke_get_commit_log(*args)

def svn_client_invoke_blame_receiver4(*args):
    r"""svn_client_invoke_blame_receiver4(svn_client_blame_receiver4_t _obj, void * baton, apr_int64_t line_no, svn_revnum_t revision, apr_hash_t rev_props, svn_revnum_t merged_revision, apr_hash_t merged_rev_props, char const * merged_path, svn_string_t const * line, svn_boolean_t local_change, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_invoke_blame_receiver4(*args)

def svn_client_invoke_blame_receiver3(*args):
    r"""svn_client_invoke_blame_receiver3(svn_client_blame_receiver3_t _obj, void * baton, svn_revnum_t start_revnum, svn_revnum_t end_revnum, apr_int64_t line_no, svn_revnum_t revision, apr_hash_t rev_props, svn_revnum_t merged_revision, apr_hash_t merged_rev_props, char const * merged_path, char const * line, svn_boolean_t local_change, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_invoke_blame_receiver3(*args)

def svn_client_invoke_blame_receiver2(*args):
    r"""svn_client_invoke_blame_receiver2(svn_client_blame_receiver2_t _obj, void * baton, apr_int64_t line_no, svn_revnum_t revision, char const * author, char const * date, svn_revnum_t merged_revision, char const * merged_author, char const * merged_date, char const * merged_path, char const * line, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_invoke_blame_receiver2(*args)

def svn_client_invoke_blame_receiver(*args):
    r"""svn_client_invoke_blame_receiver(svn_client_blame_receiver_t _obj, void * baton, apr_int64_t line_no, svn_revnum_t revision, char const * author, char const * date, char const * line, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_invoke_blame_receiver(*args)

def svn_client_invoke_diff_summarize_func(*args):
    r"""svn_client_invoke_diff_summarize_func(svn_client_diff_summarize_func_t _obj, svn_client_diff_summarize_t diff, void * baton, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_invoke_diff_summarize_func(*args)

def svn_client_invoke__layout_func(*args):
    r"""svn_client_invoke__layout_func(svn_client__layout_func_t _obj, void * layout_baton, char const * local_abspath, char const * repos_root_url, svn_boolean_t not_present, svn_boolean_t url_changed, char const * url, svn_boolean_t revision_changed, svn_revnum_t revision, svn_boolean_t depth_changed, svn_depth_t depth, apr_pool_t scratch_pool) -> svn_error_t"""
    return _client.svn_client_invoke__layout_func(*args)

def svn_client_invoke_import_filter_func(*args):
    r"""svn_client_invoke_import_filter_func(svn_client_import_filter_func_t _obj, void * baton, char const * local_abspath, svn_io_dirent2_t dirent, apr_pool_t scratch_pool) -> svn_error_t"""
    return _client.svn_client_invoke_import_filter_func(*args)

def svn_client_invoke_status_func(*args):
    r"""svn_client_invoke_status_func(svn_client_status_func_t _obj, void * baton, char const * path, svn_client_status_t status, apr_pool_t scratch_pool) -> svn_error_t"""
    return _client.svn_client_invoke_status_func(*args)

def svn_client_invoke_conflict_walk_func(*args):
    r"""svn_client_invoke_conflict_walk_func(svn_client_conflict_walk_func_t _obj, void * baton, svn_client_conflict_t conflict, apr_pool_t scratch_pool) -> svn_error_t"""
    return _client.svn_client_invoke_conflict_walk_func(*args)

def svn_client_invoke_list_func2(*args):
    r"""svn_client_invoke_list_func2(svn_client_list_func2_t _obj, void * baton, char const * path, svn_dirent_t dirent, svn_lock_t lock, char const * abs_path, char const * external_parent_url, char const * external_target, apr_pool_t scratch_pool) -> svn_error_t"""
    return _client.svn_client_invoke_list_func2(*args)

def svn_client_invoke_list_func(*args):
    r"""svn_client_invoke_list_func(svn_client_list_func_t _obj, void * baton, char const * path, svn_dirent_t dirent, svn_lock_t lock, char const * abs_path, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_client_invoke_list_func(*args)

def svn_info_invoke_receiver(*args):
    r"""svn_info_invoke_receiver(svn_info_receiver_t _obj, void * baton, char const * path, svn_info_t info, apr_pool_t pool) -> svn_error_t"""
    return _client.svn_info_invoke_receiver(*args)

def svn_client_invoke_info_receiver2(*args):
    r"""svn_client_invoke_info_receiver2(svn_client_info_receiver2_t _obj, void * baton, char const * abspath_or_url, svn_client_info2_t info, apr_pool_t scratch_pool) -> svn_error_t"""
    return _client.svn_client_invoke_info_receiver2(*args)

def svn_client_invoke_patch_func(*args):
    r"""svn_client_invoke_patch_func(svn_client_patch_func_t _obj, void * baton, char const * canon_path_from_patchfile, char const * patch_abspath, char const * reject_abspath, apr_pool_t scratch_pool) -> svn_error_t"""
    return _client.svn_client_invoke_patch_func(*args)
class svn_proplist_receiver2_t(object):
    r"""Proxy of C svn_proplist_receiver2_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_proplist_invoke_receiver2(self, *args)


# Register svn_proplist_receiver2_t in _client:
_client.svn_proplist_receiver2_t_swigregister(svn_proplist_receiver2_t)
class svn_proplist_receiver_t(object):
    r"""Proxy of C svn_proplist_receiver_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_proplist_invoke_receiver(self, *args)


# Register svn_proplist_receiver_t in _client:
_client.svn_proplist_receiver_t_swigregister(svn_proplist_receiver_t)
class svn_client_get_commit_log3_t(object):
    r"""Proxy of C svn_client_get_commit_log3_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_client_invoke_get_commit_log3(self, *args)


# Register svn_client_get_commit_log3_t in _client:
_client.svn_client_get_commit_log3_t_swigregister(svn_client_get_commit_log3_t)
class svn_client_get_commit_log2_t(object):
    r"""Proxy of C svn_client_get_commit_log2_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_client_invoke_get_commit_log2(self, *args)


# Register svn_client_get_commit_log2_t in _client:
_client.svn_client_get_commit_log2_t_swigregister(svn_client_get_commit_log2_t)
class svn_client_get_commit_log_t(object):
    r"""Proxy of C svn_client_get_commit_log_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_client_invoke_get_commit_log(self, *args)


# Register svn_client_get_commit_log_t in _client:
_client.svn_client_get_commit_log_t_swigregister(svn_client_get_commit_log_t)
class svn_client_blame_receiver4_t(object):
    r"""Proxy of C svn_client_blame_receiver4_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_client_invoke_blame_receiver4(self, *args)


# Register svn_client_blame_receiver4_t in _client:
_client.svn_client_blame_receiver4_t_swigregister(svn_client_blame_receiver4_t)
class svn_client_blame_receiver3_t(object):
    r"""Proxy of C svn_client_blame_receiver3_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_client_invoke_blame_receiver3(self, *args)


# Register svn_client_blame_receiver3_t in _client:
_client.svn_client_blame_receiver3_t_swigregister(svn_client_blame_receiver3_t)
class svn_client_blame_receiver2_t(object):
    r"""Proxy of C svn_client_blame_receiver2_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_client_invoke_blame_receiver2(self, *args)


# Register svn_client_blame_receiver2_t in _client:
_client.svn_client_blame_receiver2_t_swigregister(svn_client_blame_receiver2_t)
class svn_client_blame_receiver_t(object):
    r"""Proxy of C svn_client_blame_receiver_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_client_invoke_blame_receiver(self, *args)


# Register svn_client_blame_receiver_t in _client:
_client.svn_client_blame_receiver_t_swigregister(svn_client_blame_receiver_t)
class svn_client_diff_summarize_func_t(object):
    r"""Proxy of C svn_client_diff_summarize_func_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_client_invoke_diff_summarize_func(self, *args)


# Register svn_client_diff_summarize_func_t in _client:
_client.svn_client_diff_summarize_func_t_swigregister(svn_client_diff_summarize_func_t)
class svn_client__layout_func_t(object):
    r"""Proxy of C svn_client__layout_func_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_client_invoke__layout_func(self, *args)


# Register svn_client__layout_func_t in _client:
_client.svn_client__layout_func_t_swigregister(svn_client__layout_func_t)
class svn_client_import_filter_func_t(object):
    r"""Proxy of C svn_client_import_filter_func_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_client_invoke_import_filter_func(self, *args)


# Register svn_client_import_filter_func_t in _client:
_client.svn_client_import_filter_func_t_swigregister(svn_client_import_filter_func_t)
class svn_client_status_func_t(object):
    r"""Proxy of C svn_client_status_func_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_client_invoke_status_func(self, *args)


# Register svn_client_status_func_t in _client:
_client.svn_client_status_func_t_swigregister(svn_client_status_func_t)
class svn_client_conflict_walk_func_t(object):
    r"""Proxy of C svn_client_conflict_walk_func_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_client_invoke_conflict_walk_func(self, *args)


# Register svn_client_conflict_walk_func_t in _client:
_client.svn_client_conflict_walk_func_t_swigregister(svn_client_conflict_walk_func_t)
class svn_client_list_func2_t(object):
    r"""Proxy of C svn_client_list_func2_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_client_invoke_list_func2(self, *args)


# Register svn_client_list_func2_t in _client:
_client.svn_client_list_func2_t_swigregister(svn_client_list_func2_t)
class svn_client_list_func_t(object):
    r"""Proxy of C svn_client_list_func_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_client_invoke_list_func(self, *args)


# Register svn_client_list_func_t in _client:
_client.svn_client_list_func_t_swigregister(svn_client_list_func_t)
class svn_info_receiver_t(object):
    r"""Proxy of C svn_info_receiver_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_info_invoke_receiver(self, *args)


# Register svn_info_receiver_t in _client:
_client.svn_info_receiver_t_swigregister(svn_info_receiver_t)
class svn_client_info_receiver2_t(object):
    r"""Proxy of C svn_client_info_receiver2_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_client_invoke_info_receiver2(self, *args)


# Register svn_client_info_receiver2_t in _client:
_client.svn_client_info_receiver2_t_swigregister(svn_client_info_receiver2_t)
class svn_client_patch_func_t(object):
    r"""Proxy of C svn_client_patch_func_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_client_invoke_patch_func(self, *args)


# Register svn_client_patch_func_t in _client:
_client.svn_client_patch_func_t_swigregister(svn_client_patch_func_t)
SWIG_SVN_INFO_SIZE_UNKNOWN = _client.SWIG_SVN_INFO_SIZE_UNKNOWN

svn_swig_py_cancel_func = _client.svn_swig_py_cancel_func

svn_swig_py_get_commit_log_func = _client.svn_swig_py_get_commit_log_func

svn_swig_py_notify_func = _client.svn_swig_py_notify_func

svn_swig_py_notify_func2 = _client.svn_swig_py_notify_func2



# This file was automatically generated by SWIG (https://www.swig.org).
# Version 4.1.1
#
# Do not make changes to this file unless you know what you are doing - modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info

def _dll_paths():
    import os
    if hasattr(os, 'add_dll_directory'):  # Python 3.8+ on Windows
        cookies = []
        for path in os.environ.get('PATH', '').split(os.pathsep):
            if path and os.path.isabs(path):
                try:
                    cookie = os.add_dll_directory(path)
                except OSError:
                    continue
                else:
                    cookies.append(cookie)
        return cookies
    else:
        return ()

_dll_paths = _dll_paths()
try:
    from . import _wc
finally:
    _dll_path = None
    for _dll_path in _dll_paths:
        _dll_path.close()
    del _dll_paths, _dll_path


try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "this":
            set(self, name, value)
        elif name == "thisown":
            self.this.own(value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)



def _copy_metadata_deep(value, old_value):
  """Copy all attributes of old_value into value, recursively traversing
  lists and dicts if needed."""
  if value is None or old_value is None or value is old_value: return

  if isinstance(value, dict):
    for k in value:
      _copy_metadata_deep(value[k], old_value[k])
  elif isinstance(value, list):
    for v, old_v in zip(value, old_value):
      _copy_metadata_deep(v, old_v)
  else:
    try:
      value.__dict__.update(old_value.__dict__)
    except AttributeError:
      pass

def _assert_valid_deep(value):
  """Assert value's validity, recursively traversing lists and dicts."""
  if isinstance(value, dict):
    for k in value:
      _assert_valid_deep(value[k])
  elif isinstance(value, list):
    for v in value:
      _assert_valid_deep(v)
# Ensure that the passed in value isn't a type, which could have an
# assert_valid attribute, but it can not be called without an instance.
  elif type(value) != type:
    try:
      fn = value.assert_valid
    except AttributeError:
      pass
    else:
      fn()



  # SWIG classes generated with -classic do not define this variable,
  # so set it to 0 when it doesn't exist
try:
  _newclass
except NameError:
  _newclass = 0

if _newclass:
  def _get_instance_attr(self, name):
    try:
      return object.__getattribute__(self, name)
    except AttributeError:
      return _swig_getattr(self, object.__getattribute__(self, '__class__'),
                           name)
else:
  def _get_instance_attr(self, name):
    return _swig_getattr(self, self.__class__, name)

def _set_instance_attr(self, name, value):
  return _swig_setattr(self, self.__class__, name, value)


import libsvn.core
import libsvn.delta
import libsvn.ra

def svn_wc_version():
    r"""svn_wc_version() -> svn_version_t"""
    return _wc.svn_wc_version()
SVN_WC_TRANSLATE_FROM_NF = _wc.SVN_WC_TRANSLATE_FROM_NF

SVN_WC_TRANSLATE_TO_NF = _wc.SVN_WC_TRANSLATE_TO_NF

SVN_WC_TRANSLATE_FORCE_EOL_REPAIR = _wc.SVN_WC_TRANSLATE_FORCE_EOL_REPAIR

SVN_WC_TRANSLATE_NO_OUTPUT_CLEANUP = _wc.SVN_WC_TRANSLATE_NO_OUTPUT_CLEANUP

SVN_WC_TRANSLATE_FORCE_COPY = _wc.SVN_WC_TRANSLATE_FORCE_COPY

SVN_WC_TRANSLATE_USE_GLOBAL_TMP = _wc.SVN_WC_TRANSLATE_USE_GLOBAL_TMP


def svn_wc_context_create(*args):
    r"""svn_wc_context_create(svn_config_t config, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _wc.svn_wc_context_create(*args)

def svn_wc_context_destroy(wc_ctx):
    r"""svn_wc_context_destroy(svn_wc_context_t wc_ctx) -> svn_error_t"""
    return _wc.svn_wc_context_destroy(wc_ctx)

def svn_wc_adm_open3(*args):
    r"""svn_wc_adm_open3(svn_wc_adm_access_t associated, char const * path, svn_boolean_t write_lock, int levels_to_lock, svn_cancel_func_t cancel_func, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_adm_open3(*args)

def svn_wc_adm_open2(*args):
    r"""svn_wc_adm_open2(svn_wc_adm_access_t associated, char const * path, svn_boolean_t write_lock, int levels_to_lock, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_adm_open2(*args)

def svn_wc_adm_open(*args):
    r"""svn_wc_adm_open(svn_wc_adm_access_t associated, char const * path, svn_boolean_t write_lock, svn_boolean_t tree_lock, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_adm_open(*args)

def svn_wc_adm_probe_open3(*args):
    r"""svn_wc_adm_probe_open3(svn_wc_adm_access_t associated, char const * path, svn_boolean_t write_lock, int levels_to_lock, svn_cancel_func_t cancel_func, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_adm_probe_open3(*args)

def svn_wc_adm_probe_open2(*args):
    r"""svn_wc_adm_probe_open2(svn_wc_adm_access_t associated, char const * path, svn_boolean_t write_lock, int levels_to_lock, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_adm_probe_open2(*args)

def svn_wc_adm_probe_open(*args):
    r"""svn_wc_adm_probe_open(svn_wc_adm_access_t associated, char const * path, svn_boolean_t write_lock, svn_boolean_t tree_lock, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_adm_probe_open(*args)

def svn_wc_adm_open_anchor(*args):
    r"""svn_wc_adm_open_anchor(char const * path, svn_boolean_t write_lock, int levels_to_lock, svn_cancel_func_t cancel_func, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_adm_open_anchor(*args)

def svn_wc_adm_retrieve(*args):
    r"""svn_wc_adm_retrieve(svn_wc_adm_access_t associated, char const * path, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_adm_retrieve(*args)

def svn_wc_adm_probe_retrieve(*args):
    r"""svn_wc_adm_probe_retrieve(svn_wc_adm_access_t associated, char const * path, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_adm_probe_retrieve(*args)

def svn_wc_adm_probe_try3(*args):
    r"""svn_wc_adm_probe_try3(svn_wc_adm_access_t associated, char const * path, svn_boolean_t write_lock, int levels_to_lock, svn_cancel_func_t cancel_func, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_adm_probe_try3(*args)

def svn_wc_adm_probe_try2(*args):
    r"""svn_wc_adm_probe_try2(svn_wc_adm_access_t associated, char const * path, svn_boolean_t write_lock, int levels_to_lock, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_adm_probe_try2(*args)

def svn_wc_adm_probe_try(*args):
    r"""svn_wc_adm_probe_try(svn_wc_adm_access_t associated, char const * path, svn_boolean_t write_lock, svn_boolean_t tree_lock, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_adm_probe_try(*args)

def svn_wc_adm_close2(*args):
    r"""svn_wc_adm_close2(svn_wc_adm_access_t adm_access, apr_pool_t scratch_pool) -> svn_error_t"""
    return _wc.svn_wc_adm_close2(*args)

def svn_wc_adm_close(adm_access):
    r"""svn_wc_adm_close(svn_wc_adm_access_t adm_access) -> svn_error_t"""
    return _wc.svn_wc_adm_close(adm_access)

def svn_wc_adm_access_path(adm_access):
    r"""svn_wc_adm_access_path(svn_wc_adm_access_t adm_access) -> char const *"""
    return _wc.svn_wc_adm_access_path(adm_access)

def svn_wc_adm_access_pool(adm_access):
    r"""svn_wc_adm_access_pool(svn_wc_adm_access_t adm_access) -> apr_pool_t"""
    return _wc.svn_wc_adm_access_pool(adm_access)

def svn_wc_adm_locked(adm_access):
    r"""svn_wc_adm_locked(svn_wc_adm_access_t adm_access) -> svn_boolean_t"""
    return _wc.svn_wc_adm_locked(adm_access)

def svn_wc_locked2(*args):
    r"""svn_wc_locked2(svn_wc_context_t wc_ctx, char const * local_abspath, apr_pool_t scratch_pool) -> svn_error_t"""
    return _wc.svn_wc_locked2(*args)

def svn_wc_locked(*args):
    r"""svn_wc_locked(char const * path, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_locked(*args)
SVN_WC_ADM_DIR_NAME = _wc.SVN_WC_ADM_DIR_NAME


def svn_wc_is_adm_dir(*args):
    r"""svn_wc_is_adm_dir(char const * name, apr_pool_t pool) -> svn_boolean_t"""
    return _wc.svn_wc_is_adm_dir(*args)

def svn_wc_get_adm_dir(*args):
    r"""svn_wc_get_adm_dir(apr_pool_t pool) -> char const *"""
    return _wc.svn_wc_get_adm_dir(*args)

def svn_wc_set_adm_dir(*args):
    r"""svn_wc_set_adm_dir(char const * name, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_set_adm_dir(*args)

def svn_wc_init_traversal_info(*args):
    r"""svn_wc_init_traversal_info(apr_pool_t pool) -> svn_wc_traversal_info_t"""
    return _wc.svn_wc_init_traversal_info(*args)

def svn_wc_edited_externals(traversal_info):
    r"""svn_wc_edited_externals(svn_wc_traversal_info_t traversal_info)"""
    return _wc.svn_wc_edited_externals(traversal_info)

def svn_wc_traversed_depths(traversal_info):
    r"""svn_wc_traversed_depths(svn_wc_traversal_info_t traversal_info)"""
    return _wc.svn_wc_traversed_depths(traversal_info)
class svn_wc_external_item2_t(object):
    r"""Proxy of C svn_wc_external_item2_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    target_dir = property(_wc.svn_wc_external_item2_t_target_dir_get, _wc.svn_wc_external_item2_t_target_dir_set, doc=r"""target_dir : p.q(const).char""")
    url = property(_wc.svn_wc_external_item2_t_url_get, _wc.svn_wc_external_item2_t_url_set, doc=r"""url : p.q(const).char""")
    revision = property(_wc.svn_wc_external_item2_t_revision_get, _wc.svn_wc_external_item2_t_revision_set, doc=r"""revision : svn_opt_revision_t""")
    peg_revision = property(_wc.svn_wc_external_item2_t_peg_revision_get, _wc.svn_wc_external_item2_t_peg_revision_set, doc=r"""peg_revision : svn_opt_revision_t""")
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __init__(self):
        r"""__init__(svn_wc_external_item2_t self) -> svn_wc_external_item2_t"""
        _wc.svn_wc_external_item2_t_swiginit(self, _wc.new_svn_wc_external_item2_t())
    __swig_destroy__ = _wc.delete_svn_wc_external_item2_t

# Register svn_wc_external_item2_t in _wc:
_wc.svn_wc_external_item2_t_swigregister(svn_wc_external_item2_t)

def svn_wc_external_item2_create(*args):
    r"""svn_wc_external_item2_create(apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_external_item2_create(*args)

def svn_wc_external_item_create(*args):
    r"""svn_wc_external_item_create(apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_external_item_create(*args)

def svn_wc_external_item2_dup(*args):
    r"""svn_wc_external_item2_dup(svn_wc_external_item2_t item, apr_pool_t pool) -> svn_wc_external_item2_t"""
    return _wc.svn_wc_external_item2_dup(*args)
class svn_wc_external_item_t(object):
    r"""Proxy of C svn_wc_external_item_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    target_dir = property(_wc.svn_wc_external_item_t_target_dir_get, _wc.svn_wc_external_item_t_target_dir_set, doc=r"""target_dir : p.q(const).char""")
    url = property(_wc.svn_wc_external_item_t_url_get, _wc.svn_wc_external_item_t_url_set, doc=r"""url : p.q(const).char""")
    revision = property(_wc.svn_wc_external_item_t_revision_get, _wc.svn_wc_external_item_t_revision_set, doc=r"""revision : svn_opt_revision_t""")
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __init__(self):
        r"""__init__(svn_wc_external_item_t self) -> svn_wc_external_item_t"""
        _wc.svn_wc_external_item_t_swiginit(self, _wc.new_svn_wc_external_item_t())
    __swig_destroy__ = _wc.delete_svn_wc_external_item_t

# Register svn_wc_external_item_t in _wc:
_wc.svn_wc_external_item_t_swigregister(svn_wc_external_item_t)

def svn_wc_external_item_dup(*args):
    r"""svn_wc_external_item_dup(svn_wc_external_item_t item, apr_pool_t pool) -> svn_wc_external_item_t"""
    return _wc.svn_wc_external_item_dup(*args)

def svn_wc_parse_externals_description3(*args):
    r"""svn_wc_parse_externals_description3(char const * defining_directory, char const * desc, svn_boolean_t canonicalize_url, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_parse_externals_description3(*args)

def svn_wc_parse_externals_description2(*args):
    r"""svn_wc_parse_externals_description2(char const * parent_directory, char const * desc, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_parse_externals_description2(*args)

def svn_wc_parse_externals_description(*args):
    r"""svn_wc_parse_externals_description(char const * parent_directory, char const * desc, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_parse_externals_description(*args)
svn_wc_notify_add = _wc.svn_wc_notify_add

svn_wc_notify_copy = _wc.svn_wc_notify_copy

svn_wc_notify_delete = _wc.svn_wc_notify_delete

svn_wc_notify_restore = _wc.svn_wc_notify_restore

svn_wc_notify_revert = _wc.svn_wc_notify_revert

svn_wc_notify_failed_revert = _wc.svn_wc_notify_failed_revert

svn_wc_notify_resolved = _wc.svn_wc_notify_resolved

svn_wc_notify_skip = _wc.svn_wc_notify_skip

svn_wc_notify_update_delete = _wc.svn_wc_notify_update_delete

svn_wc_notify_update_add = _wc.svn_wc_notify_update_add

svn_wc_notify_update_update = _wc.svn_wc_notify_update_update

svn_wc_notify_update_completed = _wc.svn_wc_notify_update_completed

svn_wc_notify_update_external = _wc.svn_wc_notify_update_external

svn_wc_notify_status_completed = _wc.svn_wc_notify_status_completed

svn_wc_notify_status_external = _wc.svn_wc_notify_status_external

svn_wc_notify_commit_modified = _wc.svn_wc_notify_commit_modified

svn_wc_notify_commit_added = _wc.svn_wc_notify_commit_added

svn_wc_notify_commit_deleted = _wc.svn_wc_notify_commit_deleted

svn_wc_notify_commit_replaced = _wc.svn_wc_notify_commit_replaced

svn_wc_notify_commit_postfix_txdelta = _wc.svn_wc_notify_commit_postfix_txdelta

svn_wc_notify_blame_revision = _wc.svn_wc_notify_blame_revision

svn_wc_notify_locked = _wc.svn_wc_notify_locked

svn_wc_notify_unlocked = _wc.svn_wc_notify_unlocked

svn_wc_notify_failed_lock = _wc.svn_wc_notify_failed_lock

svn_wc_notify_failed_unlock = _wc.svn_wc_notify_failed_unlock

svn_wc_notify_exists = _wc.svn_wc_notify_exists

svn_wc_notify_changelist_set = _wc.svn_wc_notify_changelist_set

svn_wc_notify_changelist_clear = _wc.svn_wc_notify_changelist_clear

svn_wc_notify_changelist_moved = _wc.svn_wc_notify_changelist_moved

svn_wc_notify_merge_begin = _wc.svn_wc_notify_merge_begin

svn_wc_notify_foreign_merge_begin = _wc.svn_wc_notify_foreign_merge_begin

svn_wc_notify_update_replace = _wc.svn_wc_notify_update_replace

svn_wc_notify_property_added = _wc.svn_wc_notify_property_added

svn_wc_notify_property_modified = _wc.svn_wc_notify_property_modified

svn_wc_notify_property_deleted = _wc.svn_wc_notify_property_deleted

svn_wc_notify_property_deleted_nonexistent = _wc.svn_wc_notify_property_deleted_nonexistent

svn_wc_notify_revprop_set = _wc.svn_wc_notify_revprop_set

svn_wc_notify_revprop_deleted = _wc.svn_wc_notify_revprop_deleted

svn_wc_notify_merge_completed = _wc.svn_wc_notify_merge_completed

svn_wc_notify_tree_conflict = _wc.svn_wc_notify_tree_conflict

svn_wc_notify_failed_external = _wc.svn_wc_notify_failed_external

svn_wc_notify_update_started = _wc.svn_wc_notify_update_started

svn_wc_notify_update_skip_obstruction = _wc.svn_wc_notify_update_skip_obstruction

svn_wc_notify_update_skip_working_only = _wc.svn_wc_notify_update_skip_working_only

svn_wc_notify_update_skip_access_denied = _wc.svn_wc_notify_update_skip_access_denied

svn_wc_notify_update_external_removed = _wc.svn_wc_notify_update_external_removed

svn_wc_notify_update_shadowed_add = _wc.svn_wc_notify_update_shadowed_add

svn_wc_notify_update_shadowed_update = _wc.svn_wc_notify_update_shadowed_update

svn_wc_notify_update_shadowed_delete = _wc.svn_wc_notify_update_shadowed_delete

svn_wc_notify_merge_record_info = _wc.svn_wc_notify_merge_record_info

svn_wc_notify_upgraded_path = _wc.svn_wc_notify_upgraded_path

svn_wc_notify_merge_record_info_begin = _wc.svn_wc_notify_merge_record_info_begin

svn_wc_notify_merge_elide_info = _wc.svn_wc_notify_merge_elide_info

svn_wc_notify_patch = _wc.svn_wc_notify_patch

svn_wc_notify_patch_applied_hunk = _wc.svn_wc_notify_patch_applied_hunk

svn_wc_notify_patch_rejected_hunk = _wc.svn_wc_notify_patch_rejected_hunk

svn_wc_notify_patch_hunk_already_applied = _wc.svn_wc_notify_patch_hunk_already_applied

svn_wc_notify_commit_copied = _wc.svn_wc_notify_commit_copied

svn_wc_notify_commit_copied_replaced = _wc.svn_wc_notify_commit_copied_replaced

svn_wc_notify_url_redirect = _wc.svn_wc_notify_url_redirect

svn_wc_notify_path_nonexistent = _wc.svn_wc_notify_path_nonexistent

svn_wc_notify_exclude = _wc.svn_wc_notify_exclude

svn_wc_notify_failed_conflict = _wc.svn_wc_notify_failed_conflict

svn_wc_notify_failed_missing = _wc.svn_wc_notify_failed_missing

svn_wc_notify_failed_out_of_date = _wc.svn_wc_notify_failed_out_of_date

svn_wc_notify_failed_no_parent = _wc.svn_wc_notify_failed_no_parent

svn_wc_notify_failed_locked = _wc.svn_wc_notify_failed_locked

svn_wc_notify_failed_forbidden_by_server = _wc.svn_wc_notify_failed_forbidden_by_server

svn_wc_notify_skip_conflicted = _wc.svn_wc_notify_skip_conflicted

svn_wc_notify_update_broken_lock = _wc.svn_wc_notify_update_broken_lock

svn_wc_notify_failed_obstruction = _wc.svn_wc_notify_failed_obstruction

svn_wc_notify_conflict_resolver_starting = _wc.svn_wc_notify_conflict_resolver_starting

svn_wc_notify_conflict_resolver_done = _wc.svn_wc_notify_conflict_resolver_done

svn_wc_notify_left_local_modifications = _wc.svn_wc_notify_left_local_modifications

svn_wc_notify_foreign_copy_begin = _wc.svn_wc_notify_foreign_copy_begin

svn_wc_notify_move_broken = _wc.svn_wc_notify_move_broken

svn_wc_notify_cleanup_external = _wc.svn_wc_notify_cleanup_external

svn_wc_notify_failed_requires_target = _wc.svn_wc_notify_failed_requires_target

svn_wc_notify_info_external = _wc.svn_wc_notify_info_external

svn_wc_notify_commit_finalizing = _wc.svn_wc_notify_commit_finalizing

svn_wc_notify_resolved_text = _wc.svn_wc_notify_resolved_text

svn_wc_notify_resolved_prop = _wc.svn_wc_notify_resolved_prop

svn_wc_notify_resolved_tree = _wc.svn_wc_notify_resolved_tree

svn_wc_notify_begin_search_tree_conflict_details = _wc.svn_wc_notify_begin_search_tree_conflict_details

svn_wc_notify_tree_conflict_details_progress = _wc.svn_wc_notify_tree_conflict_details_progress

svn_wc_notify_end_search_tree_conflict_details = _wc.svn_wc_notify_end_search_tree_conflict_details

svn_wc_notify_state_inapplicable = _wc.svn_wc_notify_state_inapplicable

svn_wc_notify_state_unknown = _wc.svn_wc_notify_state_unknown

svn_wc_notify_state_unchanged = _wc.svn_wc_notify_state_unchanged

svn_wc_notify_state_missing = _wc.svn_wc_notify_state_missing

svn_wc_notify_state_obstructed = _wc.svn_wc_notify_state_obstructed

svn_wc_notify_state_changed = _wc.svn_wc_notify_state_changed

svn_wc_notify_state_merged = _wc.svn_wc_notify_state_merged

svn_wc_notify_state_conflicted = _wc.svn_wc_notify_state_conflicted

svn_wc_notify_state_source_missing = _wc.svn_wc_notify_state_source_missing

svn_wc_notify_lock_state_inapplicable = _wc.svn_wc_notify_lock_state_inapplicable

svn_wc_notify_lock_state_unknown = _wc.svn_wc_notify_lock_state_unknown

svn_wc_notify_lock_state_unchanged = _wc.svn_wc_notify_lock_state_unchanged

svn_wc_notify_lock_state_locked = _wc.svn_wc_notify_lock_state_locked

svn_wc_notify_lock_state_unlocked = _wc.svn_wc_notify_lock_state_unlocked

class svn_wc_notify_t(object):
    r"""Proxy of C svn_wc_notify_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    path = property(_wc.svn_wc_notify_t_path_get, _wc.svn_wc_notify_t_path_set, doc=r"""path : p.q(const).char""")
    action = property(_wc.svn_wc_notify_t_action_get, _wc.svn_wc_notify_t_action_set, doc=r"""action : svn_wc_notify_action_t""")
    kind = property(_wc.svn_wc_notify_t_kind_get, _wc.svn_wc_notify_t_kind_set, doc=r"""kind : svn_node_kind_t""")
    mime_type = property(_wc.svn_wc_notify_t_mime_type_get, _wc.svn_wc_notify_t_mime_type_set, doc=r"""mime_type : p.q(const).char""")
    lock = property(_wc.svn_wc_notify_t_lock_get, _wc.svn_wc_notify_t_lock_set, doc=r"""lock : p.q(const).svn_lock_t""")
    err = property(_wc.svn_wc_notify_t_err_get, _wc.svn_wc_notify_t_err_set, doc=r"""err : p.svn_error_t""")
    content_state = property(_wc.svn_wc_notify_t_content_state_get, _wc.svn_wc_notify_t_content_state_set, doc=r"""content_state : svn_wc_notify_state_t""")
    prop_state = property(_wc.svn_wc_notify_t_prop_state_get, _wc.svn_wc_notify_t_prop_state_set, doc=r"""prop_state : svn_wc_notify_state_t""")
    lock_state = property(_wc.svn_wc_notify_t_lock_state_get, _wc.svn_wc_notify_t_lock_state_set, doc=r"""lock_state : svn_wc_notify_lock_state_t""")
    revision = property(_wc.svn_wc_notify_t_revision_get, _wc.svn_wc_notify_t_revision_set, doc=r"""revision : svn_revnum_t""")
    changelist_name = property(_wc.svn_wc_notify_t_changelist_name_get, _wc.svn_wc_notify_t_changelist_name_set, doc=r"""changelist_name : p.q(const).char""")
    merge_range = property(_wc.svn_wc_notify_t_merge_range_get, _wc.svn_wc_notify_t_merge_range_set, doc=r"""merge_range : p.svn_merge_range_t""")
    url = property(_wc.svn_wc_notify_t_url_get, _wc.svn_wc_notify_t_url_set, doc=r"""url : p.q(const).char""")
    path_prefix = property(_wc.svn_wc_notify_t_path_prefix_get, _wc.svn_wc_notify_t_path_prefix_set, doc=r"""path_prefix : p.q(const).char""")
    prop_name = property(_wc.svn_wc_notify_t_prop_name_get, _wc.svn_wc_notify_t_prop_name_set, doc=r"""prop_name : p.q(const).char""")
    rev_props = property(_wc.svn_wc_notify_t_rev_props_get, _wc.svn_wc_notify_t_rev_props_set, doc=r"""rev_props : p.apr_hash_t""")
    old_revision = property(_wc.svn_wc_notify_t_old_revision_get, _wc.svn_wc_notify_t_old_revision_set, doc=r"""old_revision : svn_revnum_t""")
    hunk_original_start = property(_wc.svn_wc_notify_t_hunk_original_start_get, _wc.svn_wc_notify_t_hunk_original_start_set, doc=r"""hunk_original_start : svn_linenum_t""")
    hunk_original_length = property(_wc.svn_wc_notify_t_hunk_original_length_get, _wc.svn_wc_notify_t_hunk_original_length_set, doc=r"""hunk_original_length : svn_linenum_t""")
    hunk_modified_start = property(_wc.svn_wc_notify_t_hunk_modified_start_get, _wc.svn_wc_notify_t_hunk_modified_start_set, doc=r"""hunk_modified_start : svn_linenum_t""")
    hunk_modified_length = property(_wc.svn_wc_notify_t_hunk_modified_length_get, _wc.svn_wc_notify_t_hunk_modified_length_set, doc=r"""hunk_modified_length : svn_linenum_t""")
    hunk_matched_line = property(_wc.svn_wc_notify_t_hunk_matched_line_get, _wc.svn_wc_notify_t_hunk_matched_line_set, doc=r"""hunk_matched_line : svn_linenum_t""")
    hunk_fuzz = property(_wc.svn_wc_notify_t_hunk_fuzz_get, _wc.svn_wc_notify_t_hunk_fuzz_set, doc=r"""hunk_fuzz : svn_linenum_t""")
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __init__(self):
        r"""__init__(svn_wc_notify_t self) -> svn_wc_notify_t"""
        _wc.svn_wc_notify_t_swiginit(self, _wc.new_svn_wc_notify_t())
    __swig_destroy__ = _wc.delete_svn_wc_notify_t

# Register svn_wc_notify_t in _wc:
_wc.svn_wc_notify_t_swigregister(svn_wc_notify_t)

def svn_wc_create_notify(*args):
    r"""svn_wc_create_notify(char const * path, svn_wc_notify_action_t action, apr_pool_t pool) -> svn_wc_notify_t"""
    return _wc.svn_wc_create_notify(*args)

def svn_wc_create_notify_url(*args):
    r"""svn_wc_create_notify_url(char const * url, svn_wc_notify_action_t action, apr_pool_t pool) -> svn_wc_notify_t"""
    return _wc.svn_wc_create_notify_url(*args)

def svn_wc_dup_notify(*args):
    r"""svn_wc_dup_notify(svn_wc_notify_t notify, apr_pool_t pool) -> svn_wc_notify_t"""
    return _wc.svn_wc_dup_notify(*args)
svn_wc_conflict_action_edit = _wc.svn_wc_conflict_action_edit

svn_wc_conflict_action_add = _wc.svn_wc_conflict_action_add

svn_wc_conflict_action_delete = _wc.svn_wc_conflict_action_delete

svn_wc_conflict_action_replace = _wc.svn_wc_conflict_action_replace

svn_wc_conflict_reason_edited = _wc.svn_wc_conflict_reason_edited

svn_wc_conflict_reason_obstructed = _wc.svn_wc_conflict_reason_obstructed

svn_wc_conflict_reason_deleted = _wc.svn_wc_conflict_reason_deleted

svn_wc_conflict_reason_missing = _wc.svn_wc_conflict_reason_missing

svn_wc_conflict_reason_unversioned = _wc.svn_wc_conflict_reason_unversioned

svn_wc_conflict_reason_added = _wc.svn_wc_conflict_reason_added

svn_wc_conflict_reason_replaced = _wc.svn_wc_conflict_reason_replaced

svn_wc_conflict_reason_moved_away = _wc.svn_wc_conflict_reason_moved_away

svn_wc_conflict_reason_moved_here = _wc.svn_wc_conflict_reason_moved_here

svn_wc_conflict_kind_text = _wc.svn_wc_conflict_kind_text

svn_wc_conflict_kind_property = _wc.svn_wc_conflict_kind_property

svn_wc_conflict_kind_tree = _wc.svn_wc_conflict_kind_tree

svn_wc_operation_none = _wc.svn_wc_operation_none

svn_wc_operation_update = _wc.svn_wc_operation_update

svn_wc_operation_switch = _wc.svn_wc_operation_switch

svn_wc_operation_merge = _wc.svn_wc_operation_merge

class svn_wc_conflict_version_t(object):
    r"""Proxy of C svn_wc_conflict_version_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    repos_url = property(_wc.svn_wc_conflict_version_t_repos_url_get, _wc.svn_wc_conflict_version_t_repos_url_set, doc=r"""repos_url : p.q(const).char""")
    peg_rev = property(_wc.svn_wc_conflict_version_t_peg_rev_get, _wc.svn_wc_conflict_version_t_peg_rev_set, doc=r"""peg_rev : svn_revnum_t""")
    path_in_repos = property(_wc.svn_wc_conflict_version_t_path_in_repos_get, _wc.svn_wc_conflict_version_t_path_in_repos_set, doc=r"""path_in_repos : p.q(const).char""")
    node_kind = property(_wc.svn_wc_conflict_version_t_node_kind_get, _wc.svn_wc_conflict_version_t_node_kind_set, doc=r"""node_kind : svn_node_kind_t""")
    repos_uuid = property(_wc.svn_wc_conflict_version_t_repos_uuid_get, _wc.svn_wc_conflict_version_t_repos_uuid_set, doc=r"""repos_uuid : p.q(const).char""")
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __init__(self):
        r"""__init__(svn_wc_conflict_version_t self) -> svn_wc_conflict_version_t"""
        _wc.svn_wc_conflict_version_t_swiginit(self, _wc.new_svn_wc_conflict_version_t())
    __swig_destroy__ = _wc.delete_svn_wc_conflict_version_t

# Register svn_wc_conflict_version_t in _wc:
_wc.svn_wc_conflict_version_t_swigregister(svn_wc_conflict_version_t)

def svn_wc_conflict_version_create2(*args):
    r"""svn_wc_conflict_version_create2(char const * repos_root_url, char const * repos_uuid, char const * repos_relpath, svn_revnum_t revision, svn_node_kind_t kind, apr_pool_t result_pool) -> svn_wc_conflict_version_t"""
    return _wc.svn_wc_conflict_version_create2(*args)

def svn_wc_conflict_version_create(*args):
    r"""svn_wc_conflict_version_create(char const * repos_url, char const * path_in_repos, svn_revnum_t peg_rev, svn_node_kind_t node_kind, apr_pool_t pool) -> svn_wc_conflict_version_t"""
    return _wc.svn_wc_conflict_version_create(*args)

def svn_wc_conflict_version_dup(*args):
    r"""svn_wc_conflict_version_dup(svn_wc_conflict_version_t version, apr_pool_t pool) -> svn_wc_conflict_version_t"""
    return _wc.svn_wc_conflict_version_dup(*args)
class svn_wc_conflict_description_t(object):
    r"""Proxy of C svn_wc_conflict_description_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    path = property(_wc.svn_wc_conflict_description_t_path_get, _wc.svn_wc_conflict_description_t_path_set, doc=r"""path : p.q(const).char""")
    node_kind = property(_wc.svn_wc_conflict_description_t_node_kind_get, _wc.svn_wc_conflict_description_t_node_kind_set, doc=r"""node_kind : svn_node_kind_t""")
    kind = property(_wc.svn_wc_conflict_description_t_kind_get, _wc.svn_wc_conflict_description_t_kind_set, doc=r"""kind : svn_wc_conflict_kind_t""")
    property_name = property(_wc.svn_wc_conflict_description_t_property_name_get, _wc.svn_wc_conflict_description_t_property_name_set, doc=r"""property_name : p.q(const).char""")
    is_binary = property(_wc.svn_wc_conflict_description_t_is_binary_get, _wc.svn_wc_conflict_description_t_is_binary_set, doc=r"""is_binary : svn_boolean_t""")
    mime_type = property(_wc.svn_wc_conflict_description_t_mime_type_get, _wc.svn_wc_conflict_description_t_mime_type_set, doc=r"""mime_type : p.q(const).char""")
    access = property(_wc.svn_wc_conflict_description_t_access_get, _wc.svn_wc_conflict_description_t_access_set, doc=r"""access : p.svn_wc_adm_access_t""")
    action = property(_wc.svn_wc_conflict_description_t_action_get, _wc.svn_wc_conflict_description_t_action_set, doc=r"""action : svn_wc_conflict_action_t""")
    reason = property(_wc.svn_wc_conflict_description_t_reason_get, _wc.svn_wc_conflict_description_t_reason_set, doc=r"""reason : svn_wc_conflict_reason_t""")
    base_file = property(_wc.svn_wc_conflict_description_t_base_file_get, _wc.svn_wc_conflict_description_t_base_file_set, doc=r"""base_file : p.q(const).char""")
    their_file = property(_wc.svn_wc_conflict_description_t_their_file_get, _wc.svn_wc_conflict_description_t_their_file_set, doc=r"""their_file : p.q(const).char""")
    my_file = property(_wc.svn_wc_conflict_description_t_my_file_get, _wc.svn_wc_conflict_description_t_my_file_set, doc=r"""my_file : p.q(const).char""")
    merged_file = property(_wc.svn_wc_conflict_description_t_merged_file_get, _wc.svn_wc_conflict_description_t_merged_file_set, doc=r"""merged_file : p.q(const).char""")
    operation = property(_wc.svn_wc_conflict_description_t_operation_get, _wc.svn_wc_conflict_description_t_operation_set, doc=r"""operation : svn_wc_operation_t""")
    src_left_version = property(_wc.svn_wc_conflict_description_t_src_left_version_get, _wc.svn_wc_conflict_description_t_src_left_version_set, doc=r"""src_left_version : p.svn_wc_conflict_version_t""")
    src_right_version = property(_wc.svn_wc_conflict_description_t_src_right_version_get, _wc.svn_wc_conflict_description_t_src_right_version_set, doc=r"""src_right_version : p.svn_wc_conflict_version_t""")
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __init__(self):
        r"""__init__(svn_wc_conflict_description_t self) -> svn_wc_conflict_description_t"""
        _wc.svn_wc_conflict_description_t_swiginit(self, _wc.new_svn_wc_conflict_description_t())
    __swig_destroy__ = _wc.delete_svn_wc_conflict_description_t

# Register svn_wc_conflict_description_t in _wc:
_wc.svn_wc_conflict_description_t_swigregister(svn_wc_conflict_description_t)

def svn_wc_conflict_description_create_text2(*args):
    r"""svn_wc_conflict_description_create_text2(char const * local_abspath, apr_pool_t result_pool) -> svn_wc_conflict_description2_t *"""
    return _wc.svn_wc_conflict_description_create_text2(*args)

def svn_wc_conflict_description_create_text(*args):
    r"""svn_wc_conflict_description_create_text(char const * path, svn_wc_adm_access_t adm_access, apr_pool_t pool) -> svn_wc_conflict_description_t"""
    return _wc.svn_wc_conflict_description_create_text(*args)

def svn_wc_conflict_description_create_prop2(*args):
    r"""svn_wc_conflict_description_create_prop2(char const * local_abspath, svn_node_kind_t node_kind, char const * property_name, apr_pool_t result_pool) -> svn_wc_conflict_description2_t *"""
    return _wc.svn_wc_conflict_description_create_prop2(*args)

def svn_wc_conflict_description_create_prop(*args):
    r"""svn_wc_conflict_description_create_prop(char const * path, svn_wc_adm_access_t adm_access, svn_node_kind_t node_kind, char const * property_name, apr_pool_t pool) -> svn_wc_conflict_description_t"""
    return _wc.svn_wc_conflict_description_create_prop(*args)

def svn_wc_conflict_description_create_tree2(*args):
    r"""svn_wc_conflict_description_create_tree2(char const * local_abspath, svn_node_kind_t node_kind, svn_wc_operation_t operation, svn_wc_conflict_version_t src_left_version, svn_wc_conflict_version_t src_right_version, apr_pool_t result_pool) -> svn_wc_conflict_description2_t *"""
    return _wc.svn_wc_conflict_description_create_tree2(*args)

def svn_wc_conflict_description_create_tree(*args):
    r"""svn_wc_conflict_description_create_tree(char const * path, svn_wc_adm_access_t adm_access, svn_node_kind_t node_kind, svn_wc_operation_t operation, svn_wc_conflict_version_t src_left_version, svn_wc_conflict_version_t src_right_version, apr_pool_t pool) -> svn_wc_conflict_description_t"""
    return _wc.svn_wc_conflict_description_create_tree(*args)

def svn_wc_conflict_description2_dup(*args):
    r"""svn_wc_conflict_description2_dup(svn_wc_conflict_description2_t const * conflict, apr_pool_t result_pool) -> svn_wc_conflict_description2_t *"""
    return _wc.svn_wc_conflict_description2_dup(*args)

def svn_wc__conflict_description2_dup(*args):
    r"""svn_wc__conflict_description2_dup(svn_wc_conflict_description2_t const * conflict, apr_pool_t result_pool) -> svn_wc_conflict_description2_t *"""
    return _wc.svn_wc__conflict_description2_dup(*args)
svn_wc_conflict_choose_undefined = _wc.svn_wc_conflict_choose_undefined

svn_wc_conflict_choose_postpone = _wc.svn_wc_conflict_choose_postpone

svn_wc_conflict_choose_base = _wc.svn_wc_conflict_choose_base

svn_wc_conflict_choose_theirs_full = _wc.svn_wc_conflict_choose_theirs_full

svn_wc_conflict_choose_mine_full = _wc.svn_wc_conflict_choose_mine_full

svn_wc_conflict_choose_theirs_conflict = _wc.svn_wc_conflict_choose_theirs_conflict

svn_wc_conflict_choose_mine_conflict = _wc.svn_wc_conflict_choose_mine_conflict

svn_wc_conflict_choose_merged = _wc.svn_wc_conflict_choose_merged

svn_wc_conflict_choose_unspecified = _wc.svn_wc_conflict_choose_unspecified


def svn_wc_create_conflict_result(*args):
    r"""svn_wc_create_conflict_result(svn_wc_conflict_choice_t choice, char const * merged_file, apr_pool_t pool) -> svn_wc_conflict_result_t *"""
    return _wc.svn_wc_create_conflict_result(*args)
class svn_wc_diff_callbacks4_t(object):
    r"""Proxy of C svn_wc_diff_callbacks4_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    file_opened = property(_wc.svn_wc_diff_callbacks4_t_file_opened_get, _wc.svn_wc_diff_callbacks4_t_file_opened_set, doc=r"""file_opened : p.f(p.svn_boolean_t,p.svn_boolean_t,p.q(const).char,svn_revnum_t,p.void,p.apr_pool_t).p.svn_error_t""")
    file_changed = property(_wc.svn_wc_diff_callbacks4_t_file_changed_get, _wc.svn_wc_diff_callbacks4_t_file_changed_set, doc=r"""file_changed : p.f(p.svn_wc_notify_state_t,p.svn_wc_notify_state_t,p.svn_boolean_t,p.q(const).char,p.q(const).char,p.q(const).char,svn_revnum_t,svn_revnum_t,p.q(const).char,p.q(const).char,p.q(const).apr_array_header_t,p.apr_hash_t,p.void,p.apr_pool_t).p.svn_error_t""")
    file_added = property(_wc.svn_wc_diff_callbacks4_t_file_added_get, _wc.svn_wc_diff_callbacks4_t_file_added_set, doc=r"""file_added : p.f(p.svn_wc_notify_state_t,p.svn_wc_notify_state_t,p.svn_boolean_t,p.q(const).char,p.q(const).char,p.q(const).char,svn_revnum_t,svn_revnum_t,p.q(const).char,p.q(const).char,p.q(const).char,svn_revnum_t,p.q(const).apr_array_header_t,p.apr_hash_t,p.void,p.apr_pool_t).p.svn_error_t""")
    file_deleted = property(_wc.svn_wc_diff_callbacks4_t_file_deleted_get, _wc.svn_wc_diff_callbacks4_t_file_deleted_set, doc=r"""file_deleted : p.f(p.svn_wc_notify_state_t,p.svn_boolean_t,p.q(const).char,p.q(const).char,p.q(const).char,p.q(const).char,p.q(const).char,p.apr_hash_t,p.void,p.apr_pool_t).p.svn_error_t""")
    dir_deleted = property(_wc.svn_wc_diff_callbacks4_t_dir_deleted_get, _wc.svn_wc_diff_callbacks4_t_dir_deleted_set, doc=r"""dir_deleted : p.f(p.svn_wc_notify_state_t,p.svn_boolean_t,p.q(const).char,p.void,p.apr_pool_t).p.svn_error_t""")
    dir_opened = property(_wc.svn_wc_diff_callbacks4_t_dir_opened_get, _wc.svn_wc_diff_callbacks4_t_dir_opened_set, doc=r"""dir_opened : p.f(p.svn_boolean_t,p.svn_boolean_t,p.svn_boolean_t,p.q(const).char,svn_revnum_t,p.void,p.apr_pool_t).p.svn_error_t""")
    dir_added = property(_wc.svn_wc_diff_callbacks4_t_dir_added_get, _wc.svn_wc_diff_callbacks4_t_dir_added_set, doc=r"""dir_added : p.f(p.svn_wc_notify_state_t,p.svn_boolean_t,p.svn_boolean_t,p.svn_boolean_t,p.q(const).char,svn_revnum_t,p.q(const).char,svn_revnum_t,p.void,p.apr_pool_t).p.svn_error_t""")
    dir_props_changed = property(_wc.svn_wc_diff_callbacks4_t_dir_props_changed_get, _wc.svn_wc_diff_callbacks4_t_dir_props_changed_set, doc=r"""dir_props_changed : p.f(p.svn_wc_notify_state_t,p.svn_boolean_t,p.q(const).char,svn_boolean_t,p.q(const).apr_array_header_t,p.apr_hash_t,p.void,p.apr_pool_t).p.svn_error_t""")
    dir_closed = property(_wc.svn_wc_diff_callbacks4_t_dir_closed_get, _wc.svn_wc_diff_callbacks4_t_dir_closed_set, doc=r"""dir_closed : p.f(p.svn_wc_notify_state_t,p.svn_wc_notify_state_t,p.svn_boolean_t,p.q(const).char,svn_boolean_t,p.void,p.apr_pool_t).p.svn_error_t""")
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def file_opened(self, *args):
      return svn_wc_diff_callbacks4_invoke_file_opened(self, *args)


    def file_changed(self, *args):
      return svn_wc_diff_callbacks4_invoke_file_changed(self, *args)


    def file_added(self, *args):
      return svn_wc_diff_callbacks4_invoke_file_added(self, *args)


    def file_deleted(self, *args):
      return svn_wc_diff_callbacks4_invoke_file_deleted(self, *args)


    def dir_deleted(self, *args):
      return svn_wc_diff_callbacks4_invoke_dir_deleted(self, *args)


    def dir_opened(self, *args):
      return svn_wc_diff_callbacks4_invoke_dir_opened(self, *args)


    def dir_added(self, *args):
      return svn_wc_diff_callbacks4_invoke_dir_added(self, *args)


    def dir_props_changed(self, *args):
      return svn_wc_diff_callbacks4_invoke_dir_props_changed(self, *args)


    def dir_closed(self, *args):
      return svn_wc_diff_callbacks4_invoke_dir_closed(self, *args)


    def __init__(self):
        r"""__init__(svn_wc_diff_callbacks4_t self) -> svn_wc_diff_callbacks4_t"""
        _wc.svn_wc_diff_callbacks4_t_swiginit(self, _wc.new_svn_wc_diff_callbacks4_t())
    __swig_destroy__ = _wc.delete_svn_wc_diff_callbacks4_t

# Register svn_wc_diff_callbacks4_t in _wc:
_wc.svn_wc_diff_callbacks4_t_swigregister(svn_wc_diff_callbacks4_t)
class svn_wc_diff_callbacks3_t(object):
    r"""Proxy of C svn_wc_diff_callbacks3_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    file_changed = property(_wc.svn_wc_diff_callbacks3_t_file_changed_get, _wc.svn_wc_diff_callbacks3_t_file_changed_set, doc=r"""file_changed : p.f(p.svn_wc_adm_access_t,p.svn_wc_notify_state_t,p.svn_wc_notify_state_t,p.svn_boolean_t,p.q(const).char,p.q(const).char,p.q(const).char,svn_revnum_t,svn_revnum_t,p.q(const).char,p.q(const).char,p.q(const).apr_array_header_t,p.apr_hash_t,p.void).p.svn_error_t""")
    file_added = property(_wc.svn_wc_diff_callbacks3_t_file_added_get, _wc.svn_wc_diff_callbacks3_t_file_added_set, doc=r"""file_added : p.f(p.svn_wc_adm_access_t,p.svn_wc_notify_state_t,p.svn_wc_notify_state_t,p.svn_boolean_t,p.q(const).char,p.q(const).char,p.q(const).char,svn_revnum_t,svn_revnum_t,p.q(const).char,p.q(const).char,p.q(const).apr_array_header_t,p.apr_hash_t,p.void).p.svn_error_t""")
    file_deleted = property(_wc.svn_wc_diff_callbacks3_t_file_deleted_get, _wc.svn_wc_diff_callbacks3_t_file_deleted_set, doc=r"""file_deleted : p.f(p.svn_wc_adm_access_t,p.svn_wc_notify_state_t,p.svn_boolean_t,p.q(const).char,p.q(const).char,p.q(const).char,p.q(const).char,p.q(const).char,p.apr_hash_t,p.void).p.svn_error_t""")
    dir_added = property(_wc.svn_wc_diff_callbacks3_t_dir_added_get, _wc.svn_wc_diff_callbacks3_t_dir_added_set, doc=r"""dir_added : p.f(p.svn_wc_adm_access_t,p.svn_wc_notify_state_t,p.svn_boolean_t,p.q(const).char,svn_revnum_t,p.void).p.svn_error_t""")
    dir_deleted = property(_wc.svn_wc_diff_callbacks3_t_dir_deleted_get, _wc.svn_wc_diff_callbacks3_t_dir_deleted_set, doc=r"""dir_deleted : p.f(p.svn_wc_adm_access_t,p.svn_wc_notify_state_t,p.svn_boolean_t,p.q(const).char,p.void).p.svn_error_t""")
    dir_props_changed = property(_wc.svn_wc_diff_callbacks3_t_dir_props_changed_get, _wc.svn_wc_diff_callbacks3_t_dir_props_changed_set, doc=r"""dir_props_changed : p.f(p.svn_wc_adm_access_t,p.svn_wc_notify_state_t,p.svn_boolean_t,p.q(const).char,p.q(const).apr_array_header_t,p.apr_hash_t,p.void).p.svn_error_t""")
    dir_opened = property(_wc.svn_wc_diff_callbacks3_t_dir_opened_get, _wc.svn_wc_diff_callbacks3_t_dir_opened_set, doc=r"""dir_opened : p.f(p.svn_wc_adm_access_t,p.svn_boolean_t,p.q(const).char,svn_revnum_t,p.void).p.svn_error_t""")
    dir_closed = property(_wc.svn_wc_diff_callbacks3_t_dir_closed_get, _wc.svn_wc_diff_callbacks3_t_dir_closed_set, doc=r"""dir_closed : p.f(p.svn_wc_adm_access_t,p.svn_wc_notify_state_t,p.svn_wc_notify_state_t,p.svn_boolean_t,p.q(const).char,p.void).p.svn_error_t""")
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def file_changed(self, *args):
      return svn_wc_diff_callbacks3_invoke_file_changed(self, *args)


    def file_added(self, *args):
      return svn_wc_diff_callbacks3_invoke_file_added(self, *args)


    def file_deleted(self, *args):
      return svn_wc_diff_callbacks3_invoke_file_deleted(self, *args)


    def dir_added(self, *args):
      return svn_wc_diff_callbacks3_invoke_dir_added(self, *args)


    def dir_deleted(self, *args):
      return svn_wc_diff_callbacks3_invoke_dir_deleted(self, *args)


    def dir_props_changed(self, *args):
      return svn_wc_diff_callbacks3_invoke_dir_props_changed(self, *args)


    def dir_opened(self, *args):
      return svn_wc_diff_callbacks3_invoke_dir_opened(self, *args)


    def dir_closed(self, *args):
      return svn_wc_diff_callbacks3_invoke_dir_closed(self, *args)


    def __init__(self):
        r"""__init__(svn_wc_diff_callbacks3_t self) -> svn_wc_diff_callbacks3_t"""
        _wc.svn_wc_diff_callbacks3_t_swiginit(self, _wc.new_svn_wc_diff_callbacks3_t())
    __swig_destroy__ = _wc.delete_svn_wc_diff_callbacks3_t

# Register svn_wc_diff_callbacks3_t in _wc:
_wc.svn_wc_diff_callbacks3_t_swigregister(svn_wc_diff_callbacks3_t)
class svn_wc_diff_callbacks2_t(object):
    r"""Proxy of C svn_wc_diff_callbacks2_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    file_changed = property(_wc.svn_wc_diff_callbacks2_t_file_changed_get, _wc.svn_wc_diff_callbacks2_t_file_changed_set, doc=r"""file_changed : p.f(p.svn_wc_adm_access_t,p.svn_wc_notify_state_t,p.svn_wc_notify_state_t,p.q(const).char,p.q(const).char,p.q(const).char,svn_revnum_t,svn_revnum_t,p.q(const).char,p.q(const).char,p.q(const).apr_array_header_t,p.apr_hash_t,p.void).p.svn_error_t""")
    file_added = property(_wc.svn_wc_diff_callbacks2_t_file_added_get, _wc.svn_wc_diff_callbacks2_t_file_added_set, doc=r"""file_added : p.f(p.svn_wc_adm_access_t,p.svn_wc_notify_state_t,p.svn_wc_notify_state_t,p.q(const).char,p.q(const).char,p.q(const).char,svn_revnum_t,svn_revnum_t,p.q(const).char,p.q(const).char,p.q(const).apr_array_header_t,p.apr_hash_t,p.void).p.svn_error_t""")
    file_deleted = property(_wc.svn_wc_diff_callbacks2_t_file_deleted_get, _wc.svn_wc_diff_callbacks2_t_file_deleted_set, doc=r"""file_deleted : p.f(p.svn_wc_adm_access_t,p.svn_wc_notify_state_t,p.q(const).char,p.q(const).char,p.q(const).char,p.q(const).char,p.q(const).char,p.apr_hash_t,p.void).p.svn_error_t""")
    dir_added = property(_wc.svn_wc_diff_callbacks2_t_dir_added_get, _wc.svn_wc_diff_callbacks2_t_dir_added_set, doc=r"""dir_added : p.f(p.svn_wc_adm_access_t,p.svn_wc_notify_state_t,p.q(const).char,svn_revnum_t,p.void).p.svn_error_t""")
    dir_deleted = property(_wc.svn_wc_diff_callbacks2_t_dir_deleted_get, _wc.svn_wc_diff_callbacks2_t_dir_deleted_set, doc=r"""dir_deleted : p.f(p.svn_wc_adm_access_t,p.svn_wc_notify_state_t,p.q(const).char,p.void).p.svn_error_t""")
    dir_props_changed = property(_wc.svn_wc_diff_callbacks2_t_dir_props_changed_get, _wc.svn_wc_diff_callbacks2_t_dir_props_changed_set, doc=r"""dir_props_changed : p.f(p.svn_wc_adm_access_t,p.svn_wc_notify_state_t,p.q(const).char,p.q(const).apr_array_header_t,p.apr_hash_t,p.void).p.svn_error_t""")
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def file_changed(self, *args):
      return svn_wc_diff_callbacks2_invoke_file_changed(self, *args)


    def file_added(self, *args):
      return svn_wc_diff_callbacks2_invoke_file_added(self, *args)


    def file_deleted(self, *args):
      return svn_wc_diff_callbacks2_invoke_file_deleted(self, *args)


    def dir_added(self, *args):
      return svn_wc_diff_callbacks2_invoke_dir_added(self, *args)


    def dir_deleted(self, *args):
      return svn_wc_diff_callbacks2_invoke_dir_deleted(self, *args)


    def dir_props_changed(self, *args):
      return svn_wc_diff_callbacks2_invoke_dir_props_changed(self, *args)


    def __init__(self):
        r"""__init__(svn_wc_diff_callbacks2_t self) -> svn_wc_diff_callbacks2_t"""
        _wc.svn_wc_diff_callbacks2_t_swiginit(self, _wc.new_svn_wc_diff_callbacks2_t())
    __swig_destroy__ = _wc.delete_svn_wc_diff_callbacks2_t

# Register svn_wc_diff_callbacks2_t in _wc:
_wc.svn_wc_diff_callbacks2_t_swigregister(svn_wc_diff_callbacks2_t)
class svn_wc_diff_callbacks_t(object):
    r"""Proxy of C svn_wc_diff_callbacks_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    file_changed = property(_wc.svn_wc_diff_callbacks_t_file_changed_get, _wc.svn_wc_diff_callbacks_t_file_changed_set, doc=r"""file_changed : p.f(p.svn_wc_adm_access_t,p.svn_wc_notify_state_t,p.q(const).char,p.q(const).char,p.q(const).char,svn_revnum_t,svn_revnum_t,p.q(const).char,p.q(const).char,p.void).p.svn_error_t""")
    file_added = property(_wc.svn_wc_diff_callbacks_t_file_added_get, _wc.svn_wc_diff_callbacks_t_file_added_set, doc=r"""file_added : p.f(p.svn_wc_adm_access_t,p.svn_wc_notify_state_t,p.q(const).char,p.q(const).char,p.q(const).char,svn_revnum_t,svn_revnum_t,p.q(const).char,p.q(const).char,p.void).p.svn_error_t""")
    file_deleted = property(_wc.svn_wc_diff_callbacks_t_file_deleted_get, _wc.svn_wc_diff_callbacks_t_file_deleted_set, doc=r"""file_deleted : p.f(p.svn_wc_adm_access_t,p.svn_wc_notify_state_t,p.q(const).char,p.q(const).char,p.q(const).char,p.q(const).char,p.q(const).char,p.void).p.svn_error_t""")
    dir_added = property(_wc.svn_wc_diff_callbacks_t_dir_added_get, _wc.svn_wc_diff_callbacks_t_dir_added_set, doc=r"""dir_added : p.f(p.svn_wc_adm_access_t,p.svn_wc_notify_state_t,p.q(const).char,svn_revnum_t,p.void).p.svn_error_t""")
    dir_deleted = property(_wc.svn_wc_diff_callbacks_t_dir_deleted_get, _wc.svn_wc_diff_callbacks_t_dir_deleted_set, doc=r"""dir_deleted : p.f(p.svn_wc_adm_access_t,p.svn_wc_notify_state_t,p.q(const).char,p.void).p.svn_error_t""")
    props_changed = property(_wc.svn_wc_diff_callbacks_t_props_changed_get, _wc.svn_wc_diff_callbacks_t_props_changed_set, doc=r"""props_changed : p.f(p.svn_wc_adm_access_t,p.svn_wc_notify_state_t,p.q(const).char,p.q(const).apr_array_header_t,p.apr_hash_t,p.void).p.svn_error_t""")
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def file_changed(self, *args):
      return svn_wc_diff_callbacks_invoke_file_changed(self, *args)


    def file_added(self, *args):
      return svn_wc_diff_callbacks_invoke_file_added(self, *args)


    def file_deleted(self, *args):
      return svn_wc_diff_callbacks_invoke_file_deleted(self, *args)


    def dir_added(self, *args):
      return svn_wc_diff_callbacks_invoke_dir_added(self, *args)


    def dir_deleted(self, *args):
      return svn_wc_diff_callbacks_invoke_dir_deleted(self, *args)


    def props_changed(self, *args):
      return svn_wc_diff_callbacks_invoke_props_changed(self, *args)


    def __init__(self):
        r"""__init__(svn_wc_diff_callbacks_t self) -> svn_wc_diff_callbacks_t"""
        _wc.svn_wc_diff_callbacks_t_swiginit(self, _wc.new_svn_wc_diff_callbacks_t())
    __swig_destroy__ = _wc.delete_svn_wc_diff_callbacks_t

# Register svn_wc_diff_callbacks_t in _wc:
_wc.svn_wc_diff_callbacks_t_swigregister(svn_wc_diff_callbacks_t)

def svn_wc_check_wc2(*args):
    r"""svn_wc_check_wc2(svn_wc_context_t wc_ctx, char const * local_abspath, apr_pool_t scratch_pool) -> svn_error_t"""
    return _wc.svn_wc_check_wc2(*args)

def svn_wc_check_wc(*args):
    r"""svn_wc_check_wc(char const * path, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_check_wc(*args)

def svn_wc_has_binary_prop(*args):
    r"""svn_wc_has_binary_prop(char const * path, svn_wc_adm_access_t adm_access, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_has_binary_prop(*args)

def svn_wc_text_modified_p2(*args):
    r"""svn_wc_text_modified_p2(svn_wc_context_t wc_ctx, char const * local_abspath, svn_boolean_t unused, apr_pool_t scratch_pool) -> svn_error_t"""
    return _wc.svn_wc_text_modified_p2(*args)

def svn_wc_text_modified_p(*args):
    r"""svn_wc_text_modified_p(char const * filename, svn_boolean_t force_comparison, svn_wc_adm_access_t adm_access, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_text_modified_p(*args)

def svn_wc_props_modified_p2(*args):
    r"""svn_wc_props_modified_p2(svn_wc_context_t wc_ctx, char const * local_abspath, apr_pool_t scratch_pool) -> svn_error_t"""
    return _wc.svn_wc_props_modified_p2(*args)

def svn_wc_props_modified_p(*args):
    r"""svn_wc_props_modified_p(char const * path, svn_wc_adm_access_t adm_access, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_props_modified_p(*args)
svn_wc_schedule_normal = _wc.svn_wc_schedule_normal

svn_wc_schedule_add = _wc.svn_wc_schedule_add

svn_wc_schedule_delete = _wc.svn_wc_schedule_delete

svn_wc_schedule_replace = _wc.svn_wc_schedule_replace

SVN_WC_ENTRY_WORKING_SIZE_UNKNOWN = _wc.SVN_WC_ENTRY_WORKING_SIZE_UNKNOWN

class svn_wc_entry_t(object):
    r"""Proxy of C svn_wc_entry_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    name = property(_wc.svn_wc_entry_t_name_get, _wc.svn_wc_entry_t_name_set, doc=r"""name : p.q(const).char""")
    revision = property(_wc.svn_wc_entry_t_revision_get, _wc.svn_wc_entry_t_revision_set, doc=r"""revision : svn_revnum_t""")
    url = property(_wc.svn_wc_entry_t_url_get, _wc.svn_wc_entry_t_url_set, doc=r"""url : p.q(const).char""")
    repos = property(_wc.svn_wc_entry_t_repos_get, _wc.svn_wc_entry_t_repos_set, doc=r"""repos : p.q(const).char""")
    uuid = property(_wc.svn_wc_entry_t_uuid_get, _wc.svn_wc_entry_t_uuid_set, doc=r"""uuid : p.q(const).char""")
    kind = property(_wc.svn_wc_entry_t_kind_get, _wc.svn_wc_entry_t_kind_set, doc=r"""kind : svn_node_kind_t""")
    schedule = property(_wc.svn_wc_entry_t_schedule_get, _wc.svn_wc_entry_t_schedule_set, doc=r"""schedule : svn_wc_schedule_t""")
    copied = property(_wc.svn_wc_entry_t_copied_get, _wc.svn_wc_entry_t_copied_set, doc=r"""copied : svn_boolean_t""")
    deleted = property(_wc.svn_wc_entry_t_deleted_get, _wc.svn_wc_entry_t_deleted_set, doc=r"""deleted : svn_boolean_t""")
    absent = property(_wc.svn_wc_entry_t_absent_get, _wc.svn_wc_entry_t_absent_set, doc=r"""absent : svn_boolean_t""")
    incomplete = property(_wc.svn_wc_entry_t_incomplete_get, _wc.svn_wc_entry_t_incomplete_set, doc=r"""incomplete : svn_boolean_t""")
    copyfrom_url = property(_wc.svn_wc_entry_t_copyfrom_url_get, _wc.svn_wc_entry_t_copyfrom_url_set, doc=r"""copyfrom_url : p.q(const).char""")
    copyfrom_rev = property(_wc.svn_wc_entry_t_copyfrom_rev_get, _wc.svn_wc_entry_t_copyfrom_rev_set, doc=r"""copyfrom_rev : svn_revnum_t""")
    conflict_old = property(_wc.svn_wc_entry_t_conflict_old_get, _wc.svn_wc_entry_t_conflict_old_set, doc=r"""conflict_old : p.q(const).char""")
    conflict_new = property(_wc.svn_wc_entry_t_conflict_new_get, _wc.svn_wc_entry_t_conflict_new_set, doc=r"""conflict_new : p.q(const).char""")
    conflict_wrk = property(_wc.svn_wc_entry_t_conflict_wrk_get, _wc.svn_wc_entry_t_conflict_wrk_set, doc=r"""conflict_wrk : p.q(const).char""")
    prejfile = property(_wc.svn_wc_entry_t_prejfile_get, _wc.svn_wc_entry_t_prejfile_set, doc=r"""prejfile : p.q(const).char""")
    text_time = property(_wc.svn_wc_entry_t_text_time_get, _wc.svn_wc_entry_t_text_time_set, doc=r"""text_time : apr_time_t""")
    prop_time = property(_wc.svn_wc_entry_t_prop_time_get, _wc.svn_wc_entry_t_prop_time_set, doc=r"""prop_time : apr_time_t""")
    checksum = property(_wc.svn_wc_entry_t_checksum_get, _wc.svn_wc_entry_t_checksum_set, doc=r"""checksum : p.q(const).char""")
    cmt_rev = property(_wc.svn_wc_entry_t_cmt_rev_get, _wc.svn_wc_entry_t_cmt_rev_set, doc=r"""cmt_rev : svn_revnum_t""")
    cmt_date = property(_wc.svn_wc_entry_t_cmt_date_get, _wc.svn_wc_entry_t_cmt_date_set, doc=r"""cmt_date : apr_time_t""")
    cmt_author = property(_wc.svn_wc_entry_t_cmt_author_get, _wc.svn_wc_entry_t_cmt_author_set, doc=r"""cmt_author : p.q(const).char""")
    lock_token = property(_wc.svn_wc_entry_t_lock_token_get, _wc.svn_wc_entry_t_lock_token_set, doc=r"""lock_token : p.q(const).char""")
    lock_owner = property(_wc.svn_wc_entry_t_lock_owner_get, _wc.svn_wc_entry_t_lock_owner_set, doc=r"""lock_owner : p.q(const).char""")
    lock_comment = property(_wc.svn_wc_entry_t_lock_comment_get, _wc.svn_wc_entry_t_lock_comment_set, doc=r"""lock_comment : p.q(const).char""")
    lock_creation_date = property(_wc.svn_wc_entry_t_lock_creation_date_get, _wc.svn_wc_entry_t_lock_creation_date_set, doc=r"""lock_creation_date : apr_time_t""")
    has_props = property(_wc.svn_wc_entry_t_has_props_get, _wc.svn_wc_entry_t_has_props_set, doc=r"""has_props : svn_boolean_t""")
    has_prop_mods = property(_wc.svn_wc_entry_t_has_prop_mods_get, _wc.svn_wc_entry_t_has_prop_mods_set, doc=r"""has_prop_mods : svn_boolean_t""")
    cachable_props = property(_wc.svn_wc_entry_t_cachable_props_get, _wc.svn_wc_entry_t_cachable_props_set, doc=r"""cachable_props : p.q(const).char""")
    present_props = property(_wc.svn_wc_entry_t_present_props_get, _wc.svn_wc_entry_t_present_props_set, doc=r"""present_props : p.q(const).char""")
    changelist = property(_wc.svn_wc_entry_t_changelist_get, _wc.svn_wc_entry_t_changelist_set, doc=r"""changelist : p.q(const).char""")
    working_size = property(_wc.svn_wc_entry_t_working_size_get, _wc.svn_wc_entry_t_working_size_set, doc=r"""working_size : apr_off_t""")
    keep_local = property(_wc.svn_wc_entry_t_keep_local_get, _wc.svn_wc_entry_t_keep_local_set, doc=r"""keep_local : svn_boolean_t""")
    depth = property(_wc.svn_wc_entry_t_depth_get, _wc.svn_wc_entry_t_depth_set, doc=r"""depth : svn_depth_t""")
    tree_conflict_data = property(_wc.svn_wc_entry_t_tree_conflict_data_get, _wc.svn_wc_entry_t_tree_conflict_data_set, doc=r"""tree_conflict_data : p.q(const).char""")
    file_external_path = property(_wc.svn_wc_entry_t_file_external_path_get, _wc.svn_wc_entry_t_file_external_path_set, doc=r"""file_external_path : p.q(const).char""")
    file_external_peg_rev = property(_wc.svn_wc_entry_t_file_external_peg_rev_get, _wc.svn_wc_entry_t_file_external_peg_rev_set, doc=r"""file_external_peg_rev : svn_opt_revision_t""")
    file_external_rev = property(_wc.svn_wc_entry_t_file_external_rev_get, _wc.svn_wc_entry_t_file_external_rev_set, doc=r"""file_external_rev : svn_opt_revision_t""")
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __init__(self):
        r"""__init__(svn_wc_entry_t self) -> svn_wc_entry_t"""
        _wc.svn_wc_entry_t_swiginit(self, _wc.new_svn_wc_entry_t())
    __swig_destroy__ = _wc.delete_svn_wc_entry_t

# Register svn_wc_entry_t in _wc:
_wc.svn_wc_entry_t_swigregister(svn_wc_entry_t)
SVN_WC_ENTRY_THIS_DIR = _wc.SVN_WC_ENTRY_THIS_DIR


def svn_wc_entry(*args):
    r"""svn_wc_entry(char const * path, svn_wc_adm_access_t adm_access, svn_boolean_t show_hidden, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_entry(*args)

def svn_wc_entries_read(*args):
    r"""svn_wc_entries_read(svn_wc_adm_access_t adm_access, svn_boolean_t show_hidden, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_entries_read(*args)

def svn_wc_entry_dup(*args):
    r"""svn_wc_entry_dup(svn_wc_entry_t entry, apr_pool_t pool) -> svn_wc_entry_t"""
    return _wc.svn_wc_entry_dup(*args)
class svn_wc_info_t(object):
    r"""Proxy of C svn_wc_info_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    schedule = property(_wc.svn_wc_info_t_schedule_get, _wc.svn_wc_info_t_schedule_set, doc=r"""schedule : svn_wc_schedule_t""")
    copyfrom_url = property(_wc.svn_wc_info_t_copyfrom_url_get, _wc.svn_wc_info_t_copyfrom_url_set, doc=r"""copyfrom_url : p.q(const).char""")
    copyfrom_rev = property(_wc.svn_wc_info_t_copyfrom_rev_get, _wc.svn_wc_info_t_copyfrom_rev_set, doc=r"""copyfrom_rev : svn_revnum_t""")
    checksum = property(_wc.svn_wc_info_t_checksum_get, _wc.svn_wc_info_t_checksum_set, doc=r"""checksum : p.q(const).svn_checksum_t""")
    changelist = property(_wc.svn_wc_info_t_changelist_get, _wc.svn_wc_info_t_changelist_set, doc=r"""changelist : p.q(const).char""")
    depth = property(_wc.svn_wc_info_t_depth_get, _wc.svn_wc_info_t_depth_set, doc=r"""depth : svn_depth_t""")
    recorded_size = property(_wc.svn_wc_info_t_recorded_size_get, _wc.svn_wc_info_t_recorded_size_set, doc=r"""recorded_size : svn_filesize_t""")
    recorded_time = property(_wc.svn_wc_info_t_recorded_time_get, _wc.svn_wc_info_t_recorded_time_set, doc=r"""recorded_time : apr_time_t""")
    conflicts = property(_wc.svn_wc_info_t_conflicts_get, _wc.svn_wc_info_t_conflicts_set, doc=r"""conflicts : p.q(const).apr_array_header_t""")
    wcroot_abspath = property(_wc.svn_wc_info_t_wcroot_abspath_get, _wc.svn_wc_info_t_wcroot_abspath_set, doc=r"""wcroot_abspath : p.q(const).char""")
    moved_from_abspath = property(_wc.svn_wc_info_t_moved_from_abspath_get, _wc.svn_wc_info_t_moved_from_abspath_set, doc=r"""moved_from_abspath : p.q(const).char""")
    moved_to_abspath = property(_wc.svn_wc_info_t_moved_to_abspath_get, _wc.svn_wc_info_t_moved_to_abspath_set, doc=r"""moved_to_abspath : p.q(const).char""")
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __init__(self):
        r"""__init__(svn_wc_info_t self) -> svn_wc_info_t"""
        _wc.svn_wc_info_t_swiginit(self, _wc.new_svn_wc_info_t())
    __swig_destroy__ = _wc.delete_svn_wc_info_t

# Register svn_wc_info_t in _wc:
_wc.svn_wc_info_t_swigregister(svn_wc_info_t)

def svn_wc_info_dup(*args):
    r"""svn_wc_info_dup(svn_wc_info_t info, apr_pool_t pool) -> svn_wc_info_t"""
    return _wc.svn_wc_info_dup(*args)

def svn_wc_conflicted_p3(*args):
    r"""svn_wc_conflicted_p3(svn_wc_context_t wc_ctx, char const * local_abspath, apr_pool_t scratch_pool) -> svn_error_t"""
    return _wc.svn_wc_conflicted_p3(*args)

def svn_wc_conflicted_p2(*args):
    r"""svn_wc_conflicted_p2(char const * path, svn_wc_adm_access_t adm_access, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_conflicted_p2(*args)

def svn_wc_conflicted_p(*args):
    r"""svn_wc_conflicted_p(char const * dir_path, svn_wc_entry_t entry, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_conflicted_p(*args)

def svn_wc_get_ancestry(*args):
    r"""svn_wc_get_ancestry(char const * path, svn_wc_adm_access_t adm_access, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_get_ancestry(*args)
class svn_wc_entry_callbacks2_t(object):
    r"""Proxy of C svn_wc_entry_callbacks2_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    found_entry = property(_wc.svn_wc_entry_callbacks2_t_found_entry_get, _wc.svn_wc_entry_callbacks2_t_found_entry_set, doc=r"""found_entry : p.f(p.q(const).char,p.q(const).svn_wc_entry_t,p.void,p.apr_pool_t).p.svn_error_t""")
    handle_error = property(_wc.svn_wc_entry_callbacks2_t_handle_error_get, _wc.svn_wc_entry_callbacks2_t_handle_error_set, doc=r"""handle_error : p.f(p.q(const).char,p.svn_error_t,p.void,p.apr_pool_t).p.svn_error_t""")
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def found_entry(self, *args):
      return svn_wc_entry_callbacks2_invoke_found_entry(self, *args)


    def handle_error(self, *args):
      return svn_wc_entry_callbacks2_invoke_handle_error(self, *args)


    def __init__(self):
        r"""__init__(svn_wc_entry_callbacks2_t self) -> svn_wc_entry_callbacks2_t"""
        _wc.svn_wc_entry_callbacks2_t_swiginit(self, _wc.new_svn_wc_entry_callbacks2_t())
    __swig_destroy__ = _wc.delete_svn_wc_entry_callbacks2_t

# Register svn_wc_entry_callbacks2_t in _wc:
_wc.svn_wc_entry_callbacks2_t_swigregister(svn_wc_entry_callbacks2_t)
class svn_wc_entry_callbacks_t(object):
    r"""Proxy of C svn_wc_entry_callbacks_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    found_entry = property(_wc.svn_wc_entry_callbacks_t_found_entry_get, _wc.svn_wc_entry_callbacks_t_found_entry_set, doc=r"""found_entry : p.f(p.q(const).char,p.q(const).svn_wc_entry_t,p.void,p.apr_pool_t).p.svn_error_t""")
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def found_entry(self, *args):
      return svn_wc_entry_callbacks_invoke_found_entry(self, *args)


    def __init__(self):
        r"""__init__(svn_wc_entry_callbacks_t self) -> svn_wc_entry_callbacks_t"""
        _wc.svn_wc_entry_callbacks_t_swiginit(self, _wc.new_svn_wc_entry_callbacks_t())
    __swig_destroy__ = _wc.delete_svn_wc_entry_callbacks_t

# Register svn_wc_entry_callbacks_t in _wc:
_wc.svn_wc_entry_callbacks_t_swigregister(svn_wc_entry_callbacks_t)

def svn_wc_walk_entries3(*args):
    r"""svn_wc_walk_entries3(char const * path, svn_wc_adm_access_t adm_access, svn_wc_entry_callbacks2_t walk_callbacks, void * walk_baton, svn_depth_t depth, svn_boolean_t show_hidden, svn_cancel_func_t cancel_func, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_walk_entries3(*args)

def svn_wc_walk_entries2(*args):
    r"""svn_wc_walk_entries2(char const * path, svn_wc_adm_access_t adm_access, svn_wc_entry_callbacks_t walk_callbacks, void * walk_baton, svn_boolean_t show_hidden, svn_cancel_func_t cancel_func, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_walk_entries2(*args)

def svn_wc_walk_entries(*args):
    r"""svn_wc_walk_entries(char const * path, svn_wc_adm_access_t adm_access, svn_wc_entry_callbacks_t walk_callbacks, void * walk_baton, svn_boolean_t show_hidden, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_walk_entries(*args)

def svn_wc_mark_missing_deleted(*args):
    r"""svn_wc_mark_missing_deleted(char const * path, svn_wc_adm_access_t parent, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_mark_missing_deleted(*args)

def svn_wc_ensure_adm4(*args):
    r"""svn_wc_ensure_adm4(svn_wc_context_t wc_ctx, char const * local_abspath, char const * url, char const * repos_root_url, char const * repos_uuid, svn_revnum_t revision, svn_depth_t depth, apr_pool_t scratch_pool) -> svn_error_t"""
    return _wc.svn_wc_ensure_adm4(*args)

def svn_wc_ensure_adm3(*args):
    r"""svn_wc_ensure_adm3(char const * path, char const * uuid, char const * url, char const * repos, svn_revnum_t revision, svn_depth_t depth, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_ensure_adm3(*args)

def svn_wc_ensure_adm2(*args):
    r"""svn_wc_ensure_adm2(char const * path, char const * uuid, char const * url, char const * repos, svn_revnum_t revision, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_ensure_adm2(*args)

def svn_wc_ensure_adm(*args):
    r"""svn_wc_ensure_adm(char const * path, char const * uuid, char const * url, svn_revnum_t revision, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_ensure_adm(*args)

def svn_wc_maybe_set_repos_root(*args):
    r"""svn_wc_maybe_set_repos_root(svn_wc_adm_access_t adm_access, char const * path, char const * repos, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_maybe_set_repos_root(*args)
svn_wc_status_none = _wc.svn_wc_status_none

svn_wc_status_unversioned = _wc.svn_wc_status_unversioned

svn_wc_status_normal = _wc.svn_wc_status_normal

svn_wc_status_added = _wc.svn_wc_status_added

svn_wc_status_missing = _wc.svn_wc_status_missing

svn_wc_status_deleted = _wc.svn_wc_status_deleted

svn_wc_status_replaced = _wc.svn_wc_status_replaced

svn_wc_status_modified = _wc.svn_wc_status_modified

svn_wc_status_merged = _wc.svn_wc_status_merged

svn_wc_status_conflicted = _wc.svn_wc_status_conflicted

svn_wc_status_ignored = _wc.svn_wc_status_ignored

svn_wc_status_obstructed = _wc.svn_wc_status_obstructed

svn_wc_status_external = _wc.svn_wc_status_external

svn_wc_status_incomplete = _wc.svn_wc_status_incomplete

class svn_wc_status3_t(object):
    r"""Proxy of C svn_wc_status3_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    kind = property(_wc.svn_wc_status3_t_kind_get, _wc.svn_wc_status3_t_kind_set, doc=r"""kind : svn_node_kind_t""")
    depth = property(_wc.svn_wc_status3_t_depth_get, _wc.svn_wc_status3_t_depth_set, doc=r"""depth : svn_depth_t""")
    filesize = property(_wc.svn_wc_status3_t_filesize_get, _wc.svn_wc_status3_t_filesize_set, doc=r"""filesize : svn_filesize_t""")
    versioned = property(_wc.svn_wc_status3_t_versioned_get, _wc.svn_wc_status3_t_versioned_set, doc=r"""versioned : svn_boolean_t""")
    conflicted = property(_wc.svn_wc_status3_t_conflicted_get, _wc.svn_wc_status3_t_conflicted_set, doc=r"""conflicted : svn_boolean_t""")
    node_status = property(_wc.svn_wc_status3_t_node_status_get, _wc.svn_wc_status3_t_node_status_set, doc=r"""node_status : enum svn_wc_status_kind""")
    text_status = property(_wc.svn_wc_status3_t_text_status_get, _wc.svn_wc_status3_t_text_status_set, doc=r"""text_status : enum svn_wc_status_kind""")
    prop_status = property(_wc.svn_wc_status3_t_prop_status_get, _wc.svn_wc_status3_t_prop_status_set, doc=r"""prop_status : enum svn_wc_status_kind""")
    copied = property(_wc.svn_wc_status3_t_copied_get, _wc.svn_wc_status3_t_copied_set, doc=r"""copied : svn_boolean_t""")
    revision = property(_wc.svn_wc_status3_t_revision_get, _wc.svn_wc_status3_t_revision_set, doc=r"""revision : svn_revnum_t""")
    changed_rev = property(_wc.svn_wc_status3_t_changed_rev_get, _wc.svn_wc_status3_t_changed_rev_set, doc=r"""changed_rev : svn_revnum_t""")
    changed_date = property(_wc.svn_wc_status3_t_changed_date_get, _wc.svn_wc_status3_t_changed_date_set, doc=r"""changed_date : apr_time_t""")
    changed_author = property(_wc.svn_wc_status3_t_changed_author_get, _wc.svn_wc_status3_t_changed_author_set, doc=r"""changed_author : p.q(const).char""")
    repos_root_url = property(_wc.svn_wc_status3_t_repos_root_url_get, _wc.svn_wc_status3_t_repos_root_url_set, doc=r"""repos_root_url : p.q(const).char""")
    repos_uuid = property(_wc.svn_wc_status3_t_repos_uuid_get, _wc.svn_wc_status3_t_repos_uuid_set, doc=r"""repos_uuid : p.q(const).char""")
    repos_relpath = property(_wc.svn_wc_status3_t_repos_relpath_get, _wc.svn_wc_status3_t_repos_relpath_set, doc=r"""repos_relpath : p.q(const).char""")
    switched = property(_wc.svn_wc_status3_t_switched_get, _wc.svn_wc_status3_t_switched_set, doc=r"""switched : svn_boolean_t""")
    locked = property(_wc.svn_wc_status3_t_locked_get, _wc.svn_wc_status3_t_locked_set, doc=r"""locked : svn_boolean_t""")
    lock = property(_wc.svn_wc_status3_t_lock_get, _wc.svn_wc_status3_t_lock_set, doc=r"""lock : p.q(const).svn_lock_t""")
    changelist = property(_wc.svn_wc_status3_t_changelist_get, _wc.svn_wc_status3_t_changelist_set, doc=r"""changelist : p.q(const).char""")
    ood_kind = property(_wc.svn_wc_status3_t_ood_kind_get, _wc.svn_wc_status3_t_ood_kind_set, doc=r"""ood_kind : svn_node_kind_t""")
    repos_node_status = property(_wc.svn_wc_status3_t_repos_node_status_get, _wc.svn_wc_status3_t_repos_node_status_set, doc=r"""repos_node_status : enum svn_wc_status_kind""")
    repos_text_status = property(_wc.svn_wc_status3_t_repos_text_status_get, _wc.svn_wc_status3_t_repos_text_status_set, doc=r"""repos_text_status : enum svn_wc_status_kind""")
    repos_prop_status = property(_wc.svn_wc_status3_t_repos_prop_status_get, _wc.svn_wc_status3_t_repos_prop_status_set, doc=r"""repos_prop_status : enum svn_wc_status_kind""")
    repos_lock = property(_wc.svn_wc_status3_t_repos_lock_get, _wc.svn_wc_status3_t_repos_lock_set, doc=r"""repos_lock : p.q(const).svn_lock_t""")
    ood_changed_rev = property(_wc.svn_wc_status3_t_ood_changed_rev_get, _wc.svn_wc_status3_t_ood_changed_rev_set, doc=r"""ood_changed_rev : svn_revnum_t""")
    ood_changed_date = property(_wc.svn_wc_status3_t_ood_changed_date_get, _wc.svn_wc_status3_t_ood_changed_date_set, doc=r"""ood_changed_date : apr_time_t""")
    ood_changed_author = property(_wc.svn_wc_status3_t_ood_changed_author_get, _wc.svn_wc_status3_t_ood_changed_author_set, doc=r"""ood_changed_author : p.q(const).char""")
    moved_from_abspath = property(_wc.svn_wc_status3_t_moved_from_abspath_get, _wc.svn_wc_status3_t_moved_from_abspath_set, doc=r"""moved_from_abspath : p.q(const).char""")
    moved_to_abspath = property(_wc.svn_wc_status3_t_moved_to_abspath_get, _wc.svn_wc_status3_t_moved_to_abspath_set, doc=r"""moved_to_abspath : p.q(const).char""")
    file_external = property(_wc.svn_wc_status3_t_file_external_get, _wc.svn_wc_status3_t_file_external_set, doc=r"""file_external : svn_boolean_t""")
    actual_kind = property(_wc.svn_wc_status3_t_actual_kind_get, _wc.svn_wc_status3_t_actual_kind_set, doc=r"""actual_kind : svn_node_kind_t""")
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __init__(self):
        r"""__init__(svn_wc_status3_t self) -> svn_wc_status3_t"""
        _wc.svn_wc_status3_t_swiginit(self, _wc.new_svn_wc_status3_t())
    __swig_destroy__ = _wc.delete_svn_wc_status3_t

# Register svn_wc_status3_t in _wc:
_wc.svn_wc_status3_t_swigregister(svn_wc_status3_t)
class svn_wc_status2_t(object):
    r"""Proxy of C svn_wc_status2_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    entry = property(_wc.svn_wc_status2_t_entry_get, _wc.svn_wc_status2_t_entry_set, doc=r"""entry : p.q(const).svn_wc_entry_t""")
    text_status = property(_wc.svn_wc_status2_t_text_status_get, _wc.svn_wc_status2_t_text_status_set, doc=r"""text_status : enum svn_wc_status_kind""")
    prop_status = property(_wc.svn_wc_status2_t_prop_status_get, _wc.svn_wc_status2_t_prop_status_set, doc=r"""prop_status : enum svn_wc_status_kind""")
    locked = property(_wc.svn_wc_status2_t_locked_get, _wc.svn_wc_status2_t_locked_set, doc=r"""locked : svn_boolean_t""")
    copied = property(_wc.svn_wc_status2_t_copied_get, _wc.svn_wc_status2_t_copied_set, doc=r"""copied : svn_boolean_t""")
    switched = property(_wc.svn_wc_status2_t_switched_get, _wc.svn_wc_status2_t_switched_set, doc=r"""switched : svn_boolean_t""")
    repos_text_status = property(_wc.svn_wc_status2_t_repos_text_status_get, _wc.svn_wc_status2_t_repos_text_status_set, doc=r"""repos_text_status : enum svn_wc_status_kind""")
    repos_prop_status = property(_wc.svn_wc_status2_t_repos_prop_status_get, _wc.svn_wc_status2_t_repos_prop_status_set, doc=r"""repos_prop_status : enum svn_wc_status_kind""")
    repos_lock = property(_wc.svn_wc_status2_t_repos_lock_get, _wc.svn_wc_status2_t_repos_lock_set, doc=r"""repos_lock : p.svn_lock_t""")
    url = property(_wc.svn_wc_status2_t_url_get, _wc.svn_wc_status2_t_url_set, doc=r"""url : p.q(const).char""")
    ood_last_cmt_rev = property(_wc.svn_wc_status2_t_ood_last_cmt_rev_get, _wc.svn_wc_status2_t_ood_last_cmt_rev_set, doc=r"""ood_last_cmt_rev : svn_revnum_t""")
    ood_last_cmt_date = property(_wc.svn_wc_status2_t_ood_last_cmt_date_get, _wc.svn_wc_status2_t_ood_last_cmt_date_set, doc=r"""ood_last_cmt_date : apr_time_t""")
    ood_kind = property(_wc.svn_wc_status2_t_ood_kind_get, _wc.svn_wc_status2_t_ood_kind_set, doc=r"""ood_kind : svn_node_kind_t""")
    ood_last_cmt_author = property(_wc.svn_wc_status2_t_ood_last_cmt_author_get, _wc.svn_wc_status2_t_ood_last_cmt_author_set, doc=r"""ood_last_cmt_author : p.q(const).char""")
    tree_conflict = property(_wc.svn_wc_status2_t_tree_conflict_get, _wc.svn_wc_status2_t_tree_conflict_set, doc=r"""tree_conflict : p.svn_wc_conflict_description_t""")
    file_external = property(_wc.svn_wc_status2_t_file_external_get, _wc.svn_wc_status2_t_file_external_set, doc=r"""file_external : svn_boolean_t""")
    pristine_text_status = property(_wc.svn_wc_status2_t_pristine_text_status_get, _wc.svn_wc_status2_t_pristine_text_status_set, doc=r"""pristine_text_status : enum svn_wc_status_kind""")
    pristine_prop_status = property(_wc.svn_wc_status2_t_pristine_prop_status_get, _wc.svn_wc_status2_t_pristine_prop_status_set, doc=r"""pristine_prop_status : enum svn_wc_status_kind""")
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __init__(self):
        r"""__init__(svn_wc_status2_t self) -> svn_wc_status2_t"""
        _wc.svn_wc_status2_t_swiginit(self, _wc.new_svn_wc_status2_t())
    __swig_destroy__ = _wc.delete_svn_wc_status2_t

# Register svn_wc_status2_t in _wc:
_wc.svn_wc_status2_t_swigregister(svn_wc_status2_t)
class svn_wc_status_t(object):
    r"""Proxy of C svn_wc_status_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    entry = property(_wc.svn_wc_status_t_entry_get, _wc.svn_wc_status_t_entry_set, doc=r"""entry : p.q(const).svn_wc_entry_t""")
    text_status = property(_wc.svn_wc_status_t_text_status_get, _wc.svn_wc_status_t_text_status_set, doc=r"""text_status : enum svn_wc_status_kind""")
    prop_status = property(_wc.svn_wc_status_t_prop_status_get, _wc.svn_wc_status_t_prop_status_set, doc=r"""prop_status : enum svn_wc_status_kind""")
    locked = property(_wc.svn_wc_status_t_locked_get, _wc.svn_wc_status_t_locked_set, doc=r"""locked : svn_boolean_t""")
    copied = property(_wc.svn_wc_status_t_copied_get, _wc.svn_wc_status_t_copied_set, doc=r"""copied : svn_boolean_t""")
    switched = property(_wc.svn_wc_status_t_switched_get, _wc.svn_wc_status_t_switched_set, doc=r"""switched : svn_boolean_t""")
    repos_text_status = property(_wc.svn_wc_status_t_repos_text_status_get, _wc.svn_wc_status_t_repos_text_status_set, doc=r"""repos_text_status : enum svn_wc_status_kind""")
    repos_prop_status = property(_wc.svn_wc_status_t_repos_prop_status_get, _wc.svn_wc_status_t_repos_prop_status_set, doc=r"""repos_prop_status : enum svn_wc_status_kind""")
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __init__(self):
        r"""__init__(svn_wc_status_t self) -> svn_wc_status_t"""
        _wc.svn_wc_status_t_swiginit(self, _wc.new_svn_wc_status_t())
    __swig_destroy__ = _wc.delete_svn_wc_status_t

# Register svn_wc_status_t in _wc:
_wc.svn_wc_status_t_swigregister(svn_wc_status_t)

def svn_wc_dup_status3(*args):
    r"""svn_wc_dup_status3(svn_wc_status3_t orig_stat, apr_pool_t pool) -> svn_wc_status3_t"""
    return _wc.svn_wc_dup_status3(*args)

def svn_wc_dup_status2(*args):
    r"""svn_wc_dup_status2(svn_wc_status2_t orig_stat, apr_pool_t pool) -> svn_wc_status2_t"""
    return _wc.svn_wc_dup_status2(*args)

def svn_wc_dup_status(*args):
    r"""svn_wc_dup_status(svn_wc_status_t orig_stat, apr_pool_t pool) -> svn_wc_status_t"""
    return _wc.svn_wc_dup_status(*args)

def svn_wc_status3(*args):
    r"""svn_wc_status3(svn_wc_context_t wc_ctx, char const * local_abspath, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _wc.svn_wc_status3(*args)

def svn_wc_status2(*args):
    r"""svn_wc_status2(char const * path, svn_wc_adm_access_t adm_access, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_status2(*args)

def svn_wc_status(*args):
    r"""svn_wc_status(char const * path, svn_wc_adm_access_t adm_access, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_status(*args)

def svn_wc_walk_status(*args):
    r"""svn_wc_walk_status(svn_wc_context_t wc_ctx, char const * local_abspath, svn_depth_t depth, svn_boolean_t get_all, svn_boolean_t no_ignore, svn_boolean_t ignore_text_mods, apr_array_header_t ignore_patterns, svn_wc_status_func4_t status_func, void * status_baton, svn_cancel_func_t cancel_func, apr_pool_t scratch_pool) -> svn_error_t"""
    return _wc.svn_wc_walk_status(*args)

def svn_wc_get_status_editor5(*args):
    r"""svn_wc_get_status_editor5(svn_wc_context_t wc_ctx, char const * anchor_abspath, char const * target_basename, svn_depth_t depth, svn_boolean_t get_all, svn_boolean_t no_ignore, svn_boolean_t depth_as_sticky, svn_boolean_t server_performs_filtering, apr_array_header_t ignore_patterns, svn_wc_status_func4_t status_func, void * status_baton, svn_cancel_func_t cancel_func, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _wc.svn_wc_get_status_editor5(*args)

def svn_wc_get_status_editor4(*args):
    r"""svn_wc_get_status_editor4(svn_wc_adm_access_t anchor, char const * target, svn_depth_t depth, svn_boolean_t get_all, svn_boolean_t no_ignore, apr_array_header_t ignore_patterns, svn_wc_status_func3_t status_func, void * status_baton, svn_cancel_func_t cancel_func, svn_wc_traversal_info_t traversal_info, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_get_status_editor4(*args)

def svn_wc_get_status_editor3(*args):
    r"""svn_wc_get_status_editor3(svn_wc_adm_access_t anchor, char const * target, svn_depth_t depth, svn_boolean_t get_all, svn_boolean_t no_ignore, apr_array_header_t ignore_patterns, svn_wc_status_func2_t status_func, svn_cancel_func_t cancel_func, svn_wc_traversal_info_t traversal_info, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_get_status_editor3(*args)

def svn_wc_get_status_editor2(*args):
    r"""svn_wc_get_status_editor2(svn_wc_adm_access_t anchor, char const * target, apr_hash_t config, svn_boolean_t recurse, svn_boolean_t get_all, svn_boolean_t no_ignore, svn_wc_status_func2_t status_func, svn_cancel_func_t cancel_func, svn_wc_traversal_info_t traversal_info, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_get_status_editor2(*args)

def svn_wc_get_status_editor(*args):
    r"""svn_wc_get_status_editor(svn_wc_adm_access_t anchor, char const * target, apr_hash_t config, svn_boolean_t recurse, svn_boolean_t get_all, svn_boolean_t no_ignore, svn_wc_status_func_t status_func, svn_cancel_func_t cancel_func, svn_wc_traversal_info_t traversal_info, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_get_status_editor(*args)

def svn_wc_status_set_repos_locks(*args):
    r"""svn_wc_status_set_repos_locks(void * set_locks_baton, apr_hash_t locks, char const * repos_root, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_status_set_repos_locks(*args)

def svn_wc_copy3(*args):
    r"""svn_wc_copy3(svn_wc_context_t wc_ctx, char const * src_abspath, char const * dst_abspath, svn_boolean_t metadata_only, svn_cancel_func_t cancel_func, svn_wc_notify_func2_t notify_func, apr_pool_t scratch_pool) -> svn_error_t"""
    return _wc.svn_wc_copy3(*args)

def svn_wc_copy2(*args):
    r"""svn_wc_copy2(char const * src, svn_wc_adm_access_t dst_parent, char const * dst_basename, svn_cancel_func_t cancel_func, svn_wc_notify_func2_t notify_func, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_copy2(*args)

def svn_wc_copy(*args):
    r"""svn_wc_copy(char const * src, svn_wc_adm_access_t dst_parent, char const * dst_basename, svn_cancel_func_t cancel_func, svn_wc_notify_func_t notify_func, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_copy(*args)

def svn_wc_move(*args):
    r"""svn_wc_move(svn_wc_context_t wc_ctx, char const * src_abspath, char const * dst_abspath, svn_boolean_t metadata_only, svn_cancel_func_t cancel_func, svn_wc_notify_func2_t notify_func, apr_pool_t scratch_pool) -> svn_error_t"""
    return _wc.svn_wc_move(*args)

def svn_wc_delete4(*args):
    r"""svn_wc_delete4(svn_wc_context_t wc_ctx, char const * local_abspath, svn_boolean_t keep_local, svn_boolean_t delete_unversioned_target, svn_cancel_func_t cancel_func, svn_wc_notify_func2_t notify_func, apr_pool_t scratch_pool) -> svn_error_t"""
    return _wc.svn_wc_delete4(*args)

def svn_wc_delete3(*args):
    r"""svn_wc_delete3(char const * path, svn_wc_adm_access_t adm_access, svn_cancel_func_t cancel_func, svn_wc_notify_func2_t notify_func, svn_boolean_t keep_local, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_delete3(*args)

def svn_wc_delete2(*args):
    r"""svn_wc_delete2(char const * path, svn_wc_adm_access_t adm_access, svn_cancel_func_t cancel_func, svn_wc_notify_func2_t notify_func, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_delete2(*args)

def svn_wc_delete(*args):
    r"""svn_wc_delete(char const * path, svn_wc_adm_access_t adm_access, svn_cancel_func_t cancel_func, svn_wc_notify_func_t notify_func, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_delete(*args)

def svn_wc_add_from_disk3(*args):
    r"""svn_wc_add_from_disk3(svn_wc_context_t wc_ctx, char const * local_abspath, apr_hash_t props, svn_boolean_t skip_checks, svn_wc_notify_func2_t notify_func, apr_pool_t scratch_pool) -> svn_error_t"""
    return _wc.svn_wc_add_from_disk3(*args)

def svn_wc_add_from_disk2(*args):
    r"""svn_wc_add_from_disk2(svn_wc_context_t wc_ctx, char const * local_abspath, apr_hash_t props, svn_wc_notify_func2_t notify_func, apr_pool_t scratch_pool) -> svn_error_t"""
    return _wc.svn_wc_add_from_disk2(*args)

def svn_wc_add_from_disk(*args):
    r"""svn_wc_add_from_disk(svn_wc_context_t wc_ctx, char const * local_abspath, svn_wc_notify_func2_t notify_func, apr_pool_t scratch_pool) -> svn_error_t"""
    return _wc.svn_wc_add_from_disk(*args)

def svn_wc_add4(*args):
    r"""svn_wc_add4(svn_wc_context_t wc_ctx, char const * local_abspath, svn_depth_t depth, char const * copyfrom_url, svn_revnum_t copyfrom_rev, svn_cancel_func_t cancel_func, svn_wc_notify_func2_t notify_func, apr_pool_t scratch_pool) -> svn_error_t"""
    return _wc.svn_wc_add4(*args)

def svn_wc_add3(*args):
    r"""svn_wc_add3(char const * path, svn_wc_adm_access_t parent_access, svn_depth_t depth, char const * copyfrom_url, svn_revnum_t copyfrom_rev, svn_cancel_func_t cancel_func, svn_wc_notify_func2_t notify_func, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_add3(*args)

def svn_wc_add2(*args):
    r"""svn_wc_add2(char const * path, svn_wc_adm_access_t parent_access, char const * copyfrom_url, svn_revnum_t copyfrom_rev, svn_cancel_func_t cancel_func, svn_wc_notify_func2_t notify_func, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_add2(*args)

def svn_wc_add(*args):
    r"""svn_wc_add(char const * path, svn_wc_adm_access_t parent_access, char const * copyfrom_url, svn_revnum_t copyfrom_rev, svn_cancel_func_t cancel_func, svn_wc_notify_func_t notify_func, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_add(*args)

def svn_wc_add_repos_file4(*args):
    r"""svn_wc_add_repos_file4(svn_wc_context_t wc_ctx, char const * local_abspath, svn_stream_t new_base_contents, svn_stream_t new_contents, apr_hash_t new_base_props, apr_hash_t new_props, char const * copyfrom_url, svn_revnum_t copyfrom_rev, svn_cancel_func_t cancel_func, apr_pool_t scratch_pool) -> svn_error_t"""
    return _wc.svn_wc_add_repos_file4(*args)

def svn_wc_add_repos_file3(*args):
    r"""svn_wc_add_repos_file3(char const * dst_path, svn_wc_adm_access_t adm_access, svn_stream_t new_base_contents, svn_stream_t new_contents, apr_hash_t new_base_props, apr_hash_t new_props, char const * copyfrom_url, svn_revnum_t copyfrom_rev, svn_cancel_func_t cancel_func, svn_wc_notify_func2_t notify_func, apr_pool_t scratch_pool) -> svn_error_t"""
    return _wc.svn_wc_add_repos_file3(*args)

def svn_wc_add_repos_file2(*args):
    r"""svn_wc_add_repos_file2(char const * dst_path, svn_wc_adm_access_t adm_access, char const * new_text_base_path, char const * new_text_path, apr_hash_t new_base_props, apr_hash_t new_props, char const * copyfrom_url, svn_revnum_t copyfrom_rev, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_add_repos_file2(*args)

def svn_wc_add_repos_file(*args):
    r"""svn_wc_add_repos_file(char const * dst_path, svn_wc_adm_access_t adm_access, char const * new_text_path, apr_hash_t new_props, char const * copyfrom_url, svn_revnum_t copyfrom_rev, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_add_repos_file(*args)

def svn_wc_remove_from_revision_control2(*args):
    r"""svn_wc_remove_from_revision_control2(svn_wc_context_t wc_ctx, char const * local_abspath, svn_boolean_t destroy_wf, svn_boolean_t instant_error, svn_cancel_func_t cancel_func, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_remove_from_revision_control2(*args)

def svn_wc_remove_from_revision_control(*args):
    r"""svn_wc_remove_from_revision_control(svn_wc_adm_access_t adm_access, char const * name, svn_boolean_t destroy_wf, svn_boolean_t instant_error, svn_cancel_func_t cancel_func, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_remove_from_revision_control(*args)

def svn_wc_resolved_conflict5(*args):
    r"""svn_wc_resolved_conflict5(svn_wc_context_t wc_ctx, char const * local_abspath, svn_depth_t depth, svn_boolean_t resolve_text, char const * resolve_prop, svn_boolean_t resolve_tree, svn_wc_conflict_choice_t conflict_choice, svn_cancel_func_t cancel_func, svn_wc_notify_func2_t notify_func, apr_pool_t scratch_pool) -> svn_error_t"""
    return _wc.svn_wc_resolved_conflict5(*args)

def svn_wc_resolved_conflict4(*args):
    r"""svn_wc_resolved_conflict4(char const * path, svn_wc_adm_access_t adm_access, svn_boolean_t resolve_text, svn_boolean_t resolve_props, svn_boolean_t resolve_tree, svn_depth_t depth, svn_wc_conflict_choice_t conflict_choice, svn_wc_notify_func2_t notify_func, svn_cancel_func_t cancel_func, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_resolved_conflict4(*args)

def svn_wc_resolved_conflict3(*args):
    r"""svn_wc_resolved_conflict3(char const * path, svn_wc_adm_access_t adm_access, svn_boolean_t resolve_text, svn_boolean_t resolve_props, svn_depth_t depth, svn_wc_conflict_choice_t conflict_choice, svn_wc_notify_func2_t notify_func, svn_cancel_func_t cancel_func, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_resolved_conflict3(*args)

def svn_wc_resolved_conflict2(*args):
    r"""svn_wc_resolved_conflict2(char const * path, svn_wc_adm_access_t adm_access, svn_boolean_t resolve_text, svn_boolean_t resolve_props, svn_boolean_t recurse, svn_wc_notify_func2_t notify_func, svn_cancel_func_t cancel_func, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_resolved_conflict2(*args)

def svn_wc_resolved_conflict(*args):
    r"""svn_wc_resolved_conflict(char const * path, svn_wc_adm_access_t adm_access, svn_boolean_t resolve_text, svn_boolean_t resolve_props, svn_boolean_t recurse, svn_wc_notify_func_t notify_func, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_resolved_conflict(*args)

def svn_wc_committed_queue_create(*args):
    r"""svn_wc_committed_queue_create(apr_pool_t pool) -> svn_wc_committed_queue_t"""
    return _wc.svn_wc_committed_queue_create(*args)

def svn_wc_queue_committed4(*args):
    r"""svn_wc_queue_committed4(svn_wc_committed_queue_t queue, svn_wc_context_t wc_ctx, char const * local_abspath, svn_boolean_t recurse, svn_boolean_t is_committed, apr_array_header_t wcprop_changes, svn_boolean_t remove_lock, svn_boolean_t remove_changelist, svn_checksum_t sha1_checksum, apr_pool_t scratch_pool) -> svn_error_t"""
    return _wc.svn_wc_queue_committed4(*args)

def svn_wc_queue_committed3(*args):
    r"""svn_wc_queue_committed3(svn_wc_committed_queue_t queue, svn_wc_context_t wc_ctx, char const * local_abspath, svn_boolean_t recurse, apr_array_header_t wcprop_changes, svn_boolean_t remove_lock, svn_boolean_t remove_changelist, svn_checksum_t sha1_checksum, apr_pool_t scratch_pool) -> svn_error_t"""
    return _wc.svn_wc_queue_committed3(*args)

def svn_wc_queue_committed2(*args):
    r"""svn_wc_queue_committed2(svn_wc_committed_queue_t queue, char const * path, svn_wc_adm_access_t adm_access, svn_boolean_t recurse, apr_array_header_t wcprop_changes, svn_boolean_t remove_lock, svn_boolean_t remove_changelist, svn_checksum_t md5_checksum, apr_pool_t scratch_pool) -> svn_error_t"""
    return _wc.svn_wc_queue_committed2(*args)

def svn_wc_queue_committed(*args):
    r"""svn_wc_queue_committed(char const * path, svn_wc_adm_access_t adm_access, svn_boolean_t recurse, apr_array_header_t wcprop_changes, svn_boolean_t remove_lock, svn_boolean_t remove_changelist, unsigned char const * digest, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_queue_committed(*args)

def svn_wc_process_committed_queue2(*args):
    r"""svn_wc_process_committed_queue2(svn_wc_committed_queue_t queue, svn_wc_context_t wc_ctx, svn_revnum_t new_revnum, char const * rev_date, char const * rev_author, svn_cancel_func_t cancel_func, apr_pool_t scratch_pool) -> svn_error_t"""
    return _wc.svn_wc_process_committed_queue2(*args)

def svn_wc_process_committed_queue(*args):
    r"""svn_wc_process_committed_queue(svn_wc_committed_queue_t queue, svn_wc_adm_access_t adm_access, svn_revnum_t new_revnum, char const * rev_date, char const * rev_author, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_process_committed_queue(*args)

def svn_wc_process_committed4(*args):
    r"""svn_wc_process_committed4(char const * path, svn_wc_adm_access_t adm_access, svn_boolean_t recurse, svn_revnum_t new_revnum, char const * rev_date, char const * rev_author, apr_array_header_t wcprop_changes, svn_boolean_t remove_lock, svn_boolean_t remove_changelist, unsigned char const * digest, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_process_committed4(*args)

def svn_wc_process_committed3(*args):
    r"""svn_wc_process_committed3(char const * path, svn_wc_adm_access_t adm_access, svn_boolean_t recurse, svn_revnum_t new_revnum, char const * rev_date, char const * rev_author, apr_array_header_t wcprop_changes, svn_boolean_t remove_lock, unsigned char const * digest, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_process_committed3(*args)

def svn_wc_process_committed2(*args):
    r"""svn_wc_process_committed2(char const * path, svn_wc_adm_access_t adm_access, svn_boolean_t recurse, svn_revnum_t new_revnum, char const * rev_date, char const * rev_author, apr_array_header_t wcprop_changes, svn_boolean_t remove_lock, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_process_committed2(*args)

def svn_wc_process_committed(*args):
    r"""svn_wc_process_committed(char const * path, svn_wc_adm_access_t adm_access, svn_boolean_t recurse, svn_revnum_t new_revnum, char const * rev_date, char const * rev_author, apr_array_header_t wcprop_changes, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_process_committed(*args)

def svn_wc_crawl_revisions5(*args):
    r"""svn_wc_crawl_revisions5(svn_wc_context_t wc_ctx, char const * local_abspath, svn_ra_reporter3_t reporter, void * report_baton, svn_boolean_t restore_files, svn_depth_t depth, svn_boolean_t honor_depth_exclude, svn_boolean_t depth_compatibility_trick, svn_boolean_t use_commit_times, svn_cancel_func_t cancel_func, svn_wc_notify_func2_t notify_func, apr_pool_t scratch_pool) -> svn_error_t"""
    return _wc.svn_wc_crawl_revisions5(*args)

def svn_wc_crawl_revisions4(*args):
    r"""svn_wc_crawl_revisions4(char const * path, svn_wc_adm_access_t adm_access, svn_ra_reporter3_t reporter, void * report_baton, svn_boolean_t restore_files, svn_depth_t depth, svn_boolean_t honor_depth_exclude, svn_boolean_t depth_compatibility_trick, svn_boolean_t use_commit_times, svn_wc_notify_func2_t notify_func, svn_wc_traversal_info_t traversal_info, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_crawl_revisions4(*args)

def svn_wc_crawl_revisions3(*args):
    r"""svn_wc_crawl_revisions3(char const * path, svn_wc_adm_access_t adm_access, svn_ra_reporter3_t reporter, void * report_baton, svn_boolean_t restore_files, svn_depth_t depth, svn_boolean_t depth_compatibility_trick, svn_boolean_t use_commit_times, svn_wc_notify_func2_t notify_func, svn_wc_traversal_info_t traversal_info, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_crawl_revisions3(*args)

def svn_wc_crawl_revisions2(*args):
    r"""svn_wc_crawl_revisions2(char const * path, svn_wc_adm_access_t adm_access, svn_ra_reporter2_t reporter, svn_boolean_t restore_files, svn_boolean_t recurse, svn_boolean_t use_commit_times, svn_wc_notify_func2_t notify_func, svn_wc_traversal_info_t traversal_info, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_crawl_revisions2(*args)

def svn_wc_crawl_revisions(*args):
    r"""svn_wc_crawl_revisions(char const * path, svn_wc_adm_access_t adm_access, svn_ra_reporter_t reporter, void * report_baton, svn_boolean_t restore_files, svn_boolean_t recurse, svn_boolean_t use_commit_times, svn_wc_notify_func_t notify_func, svn_wc_traversal_info_t traversal_info, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_crawl_revisions(*args)

def svn_wc_check_root(*args):
    r"""svn_wc_check_root(svn_wc_context_t wc_ctx, char const * local_abspath, apr_pool_t scratch_pool) -> svn_error_t"""
    return _wc.svn_wc_check_root(*args)

def svn_wc_is_wc_root2(*args):
    r"""svn_wc_is_wc_root2(svn_wc_context_t wc_ctx, char const * local_abspath, apr_pool_t scratch_pool) -> svn_error_t"""
    return _wc.svn_wc_is_wc_root2(*args)

def svn_wc_is_wc_root(*args):
    r"""svn_wc_is_wc_root(char const * path, svn_wc_adm_access_t adm_access, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_is_wc_root(*args)

def svn_wc_get_actual_target2(*args):
    r"""svn_wc_get_actual_target2(svn_wc_context_t wc_ctx, char const * path, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _wc.svn_wc_get_actual_target2(*args)

def svn_wc_get_actual_target(*args):
    r"""svn_wc_get_actual_target(char const * path, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_get_actual_target(*args)

def svn_wc_get_update_editor4(*args):
    r"""svn_wc_get_update_editor4(svn_wc_context_t wc_ctx, char const * anchor_abspath, char const * target_basename, svn_boolean_t use_commit_times, svn_depth_t depth, svn_boolean_t depth_is_sticky, svn_boolean_t allow_unver_obstructions, svn_boolean_t adds_as_modification, svn_boolean_t server_performs_filtering, svn_boolean_t clean_checkout, char const * diff3_cmd, apr_array_header_t preserved_exts, svn_wc_dirents_func_t fetch_dirents_func, void * fetch_dirents_baton, svn_wc_conflict_resolver_func2_t conflict_func, void * conflict_baton, svn_wc_external_update_t external_func, void * external_baton, svn_cancel_func_t cancel_func, svn_wc_notify_func2_t notify_func, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _wc.svn_wc_get_update_editor4(*args)

def svn_wc_get_update_editor3(*args):
    r"""svn_wc_get_update_editor3(svn_wc_adm_access_t anchor, char const * target, svn_boolean_t use_commit_times, svn_depth_t depth, svn_boolean_t depth_is_sticky, svn_boolean_t allow_unver_obstructions, svn_wc_notify_func2_t notify_func, svn_cancel_func_t cancel_func, svn_wc_conflict_resolver_func_t conflict_func, void * conflict_baton, svn_wc_get_file_t fetch_func, void * fetch_baton, char const * diff3_cmd, apr_array_header_t preserved_exts, svn_wc_traversal_info_t ti, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_get_update_editor3(*args)

def svn_wc_get_update_editor2(*args):
    r"""svn_wc_get_update_editor2(svn_wc_adm_access_t anchor, char const * target, svn_boolean_t use_commit_times, svn_boolean_t recurse, svn_wc_notify_func2_t notify_func, svn_cancel_func_t cancel_func, char const * diff3_cmd, svn_wc_traversal_info_t ti, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_get_update_editor2(*args)

def svn_wc_get_update_editor(*args):
    r"""svn_wc_get_update_editor(svn_wc_adm_access_t anchor, char const * target, svn_boolean_t use_commit_times, svn_boolean_t recurse, svn_wc_notify_func_t notify_func, svn_cancel_func_t cancel_func, char const * diff3_cmd, svn_wc_traversal_info_t ti, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_get_update_editor(*args)

def svn_wc_get_switch_editor4(*args):
    r"""svn_wc_get_switch_editor4(svn_wc_context_t wc_ctx, char const * anchor_abspath, char const * target_basename, char const * switch_url, svn_boolean_t use_commit_times, svn_depth_t depth, svn_boolean_t depth_is_sticky, svn_boolean_t allow_unver_obstructions, svn_boolean_t server_performs_filtering, char const * diff3_cmd, apr_array_header_t preserved_exts, svn_wc_dirents_func_t fetch_dirents_func, void * fetch_dirents_baton, svn_wc_conflict_resolver_func2_t conflict_func, void * conflict_baton, svn_wc_external_update_t external_func, void * external_baton, svn_cancel_func_t cancel_func, svn_wc_notify_func2_t notify_func, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _wc.svn_wc_get_switch_editor4(*args)

def svn_wc_get_switch_editor3(*args):
    r"""svn_wc_get_switch_editor3(svn_wc_adm_access_t anchor, char const * target, char const * switch_url, svn_boolean_t use_commit_times, svn_depth_t depth, svn_boolean_t depth_is_sticky, svn_boolean_t allow_unver_obstructions, svn_wc_notify_func2_t notify_func, svn_cancel_func_t cancel_func, svn_wc_conflict_resolver_func_t conflict_func, void * conflict_baton, char const * diff3_cmd, apr_array_header_t preserved_exts, svn_wc_traversal_info_t ti, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_get_switch_editor3(*args)

def svn_wc_get_switch_editor2(*args):
    r"""svn_wc_get_switch_editor2(svn_wc_adm_access_t anchor, char const * target, char const * switch_url, svn_boolean_t use_commit_times, svn_boolean_t recurse, svn_wc_notify_func2_t notify_func, svn_cancel_func_t cancel_func, char const * diff3_cmd, svn_wc_traversal_info_t ti, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_get_switch_editor2(*args)

def svn_wc_get_switch_editor(*args):
    r"""svn_wc_get_switch_editor(svn_wc_adm_access_t anchor, char const * target, char const * switch_url, svn_boolean_t use_commit_times, svn_boolean_t recurse, svn_wc_notify_func_t notify_func, svn_cancel_func_t cancel_func, char const * diff3_cmd, svn_wc_traversal_info_t ti, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_get_switch_editor(*args)

def svn_wc_prop_list2(*args):
    r"""svn_wc_prop_list2(svn_wc_context_t wc_ctx, char const * local_abspath, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _wc.svn_wc_prop_list2(*args)

def svn_wc_prop_list(*args):
    r"""svn_wc_prop_list(char const * path, svn_wc_adm_access_t adm_access, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_prop_list(*args)

def svn_wc_get_pristine_props(*args):
    r"""svn_wc_get_pristine_props(svn_wc_context_t wc_ctx, char const * local_abspath, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _wc.svn_wc_get_pristine_props(*args)

def svn_wc_prop_get2(*args):
    r"""svn_wc_prop_get2(svn_wc_context_t wc_ctx, char const * local_abspath, char const * name, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _wc.svn_wc_prop_get2(*args)

def svn_wc_prop_get(*args):
    r"""svn_wc_prop_get(char const * name, char const * path, svn_wc_adm_access_t adm_access, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_prop_get(*args)

def svn_wc_prop_set4(*args):
    r"""svn_wc_prop_set4(svn_wc_context_t wc_ctx, char const * local_abspath, char const * name, svn_string_t const * value, svn_depth_t depth, svn_boolean_t skip_checks, apr_array_header_t changelist_filter, svn_cancel_func_t cancel_func, svn_wc_notify_func2_t notify_func, apr_pool_t scratch_pool) -> svn_error_t"""
    return _wc.svn_wc_prop_set4(*args)

def svn_wc_prop_set3(*args):
    r"""svn_wc_prop_set3(char const * name, svn_string_t const * value, char const * path, svn_wc_adm_access_t adm_access, svn_boolean_t skip_checks, svn_wc_notify_func2_t notify_func, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_prop_set3(*args)

def svn_wc_prop_set2(*args):
    r"""svn_wc_prop_set2(char const * name, svn_string_t const * value, char const * path, svn_wc_adm_access_t adm_access, svn_boolean_t skip_checks, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_prop_set2(*args)

def svn_wc_prop_set(*args):
    r"""svn_wc_prop_set(char const * name, svn_string_t const * value, char const * path, svn_wc_adm_access_t adm_access, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_prop_set(*args)

def svn_wc_is_normal_prop(name):
    r"""svn_wc_is_normal_prop(char const * name) -> svn_boolean_t"""
    return _wc.svn_wc_is_normal_prop(name)

def svn_wc_is_wc_prop(name):
    r"""svn_wc_is_wc_prop(char const * name) -> svn_boolean_t"""
    return _wc.svn_wc_is_wc_prop(name)

def svn_wc_is_entry_prop(name):
    r"""svn_wc_is_entry_prop(char const * name) -> svn_boolean_t"""
    return _wc.svn_wc_is_entry_prop(name)

def svn_wc_canonicalize_svn_prop(*args):
    r"""svn_wc_canonicalize_svn_prop(char const * propname, svn_string_t const * propval, char const * path, svn_node_kind_t kind, svn_boolean_t skip_some_checks, svn_wc_canonicalize_svn_prop_get_file_t prop_getter, void * getter_baton, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_canonicalize_svn_prop(*args)

def svn_wc_get_diff_editor6(*args):
    r"""svn_wc_get_diff_editor6(svn_wc_context_t wc_ctx, char const * anchor_abspath, char const * target, svn_depth_t depth, svn_boolean_t ignore_ancestry, svn_boolean_t show_copies_as_adds, svn_boolean_t use_git_diff_format, svn_boolean_t use_text_base, svn_boolean_t reverse_order, svn_boolean_t server_performs_filtering, apr_array_header_t changelist_filter, svn_wc_diff_callbacks4_t callbacks, void * callback_baton, svn_cancel_func_t cancel_func, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _wc.svn_wc_get_diff_editor6(*args)

def svn_wc_get_diff_editor5(*args):
    r"""svn_wc_get_diff_editor5(svn_wc_adm_access_t anchor, char const * target, svn_wc_diff_callbacks3_t callbacks, void * callback_baton, svn_depth_t depth, svn_boolean_t ignore_ancestry, svn_boolean_t use_text_base, svn_boolean_t reverse_order, svn_cancel_func_t cancel_func, apr_array_header_t changelist_filter, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_get_diff_editor5(*args)

def svn_wc_get_diff_editor4(*args):
    r"""svn_wc_get_diff_editor4(svn_wc_adm_access_t anchor, char const * target, svn_wc_diff_callbacks2_t callbacks, svn_depth_t depth, svn_boolean_t ignore_ancestry, svn_boolean_t use_text_base, svn_boolean_t reverse_order, svn_cancel_func_t cancel_func, apr_array_header_t changelist_filter, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_get_diff_editor4(*args)

def svn_wc_get_diff_editor3(*args):
    r"""svn_wc_get_diff_editor3(svn_wc_adm_access_t anchor, char const * target, svn_wc_diff_callbacks2_t callbacks, svn_boolean_t recurse, svn_boolean_t ignore_ancestry, svn_boolean_t use_text_base, svn_boolean_t reverse_order, svn_cancel_func_t cancel_func, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_get_diff_editor3(*args)

def svn_wc_get_diff_editor2(*args):
    r"""svn_wc_get_diff_editor2(svn_wc_adm_access_t anchor, char const * target, svn_wc_diff_callbacks_t callbacks, void * callback_baton, svn_boolean_t recurse, svn_boolean_t ignore_ancestry, svn_boolean_t use_text_base, svn_boolean_t reverse_order, svn_cancel_func_t cancel_func, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_get_diff_editor2(*args)

def svn_wc_get_diff_editor(*args):
    r"""svn_wc_get_diff_editor(svn_wc_adm_access_t anchor, char const * target, svn_wc_diff_callbacks_t callbacks, void * callback_baton, svn_boolean_t recurse, svn_boolean_t use_text_base, svn_boolean_t reverse_order, svn_cancel_func_t cancel_func, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_get_diff_editor(*args)

def svn_wc_diff6(*args):
    r"""svn_wc_diff6(svn_wc_context_t wc_ctx, char const * target_abspath, svn_wc_diff_callbacks4_t callbacks, void * callback_baton, svn_depth_t depth, svn_boolean_t ignore_ancestry, svn_boolean_t show_copies_as_adds, svn_boolean_t use_git_diff_format, apr_array_header_t changelist_filter, svn_cancel_func_t cancel_func, apr_pool_t scratch_pool) -> svn_error_t"""
    return _wc.svn_wc_diff6(*args)

def svn_wc_diff5(*args):
    r"""svn_wc_diff5(svn_wc_adm_access_t anchor, char const * target, svn_wc_diff_callbacks3_t callbacks, void * callback_baton, svn_depth_t depth, svn_boolean_t ignore_ancestry, apr_array_header_t changelist_filter, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_diff5(*args)

def svn_wc_diff4(*args):
    r"""svn_wc_diff4(svn_wc_adm_access_t anchor, char const * target, svn_wc_diff_callbacks2_t callbacks, svn_depth_t depth, svn_boolean_t ignore_ancestry, apr_array_header_t changelist_filter, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_diff4(*args)

def svn_wc_diff3(*args):
    r"""svn_wc_diff3(svn_wc_adm_access_t anchor, char const * target, svn_wc_diff_callbacks2_t callbacks, svn_boolean_t recurse, svn_boolean_t ignore_ancestry, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_diff3(*args)

def svn_wc_diff2(*args):
    r"""svn_wc_diff2(svn_wc_adm_access_t anchor, char const * target, svn_wc_diff_callbacks_t callbacks, void * callback_baton, svn_boolean_t recurse, svn_boolean_t ignore_ancestry, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_diff2(*args)

def svn_wc_diff(*args):
    r"""svn_wc_diff(svn_wc_adm_access_t anchor, char const * target, svn_wc_diff_callbacks_t callbacks, void * callback_baton, svn_boolean_t recurse, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_diff(*args)

def svn_wc_get_prop_diffs2(*args):
    r"""svn_wc_get_prop_diffs2(svn_wc_context_t wc_ctx, char const * local_abspath, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _wc.svn_wc_get_prop_diffs2(*args)

def svn_wc_get_prop_diffs(*args):
    r"""svn_wc_get_prop_diffs(char const * path, svn_wc_adm_access_t adm_access, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_get_prop_diffs(*args)
svn_wc_merge_unchanged = _wc.svn_wc_merge_unchanged

svn_wc_merge_merged = _wc.svn_wc_merge_merged

svn_wc_merge_conflict = _wc.svn_wc_merge_conflict

svn_wc_merge_no_merge = _wc.svn_wc_merge_no_merge


def svn_wc_merge5(*args):
    r"""svn_wc_merge5(enum svn_wc_notify_state_t * merge_props_state, svn_wc_context_t wc_ctx, char const * left_abspath, char const * right_abspath, char const * target_abspath, char const * left_label, char const * right_label, char const * target_label, svn_wc_conflict_version_t left_version, svn_wc_conflict_version_t right_version, svn_boolean_t dry_run, char const * diff3_cmd, apr_array_header_t merge_options, apr_hash_t original_props, apr_array_header_t prop_diff, svn_wc_conflict_resolver_func2_t conflict_func, void * conflict_baton, svn_cancel_func_t cancel_func, apr_pool_t scratch_pool) -> svn_error_t"""
    return _wc.svn_wc_merge5(*args)

def svn_wc_merge4(*args):
    r"""svn_wc_merge4(svn_wc_context_t wc_ctx, char const * left_abspath, char const * right_abspath, char const * target_abspath, char const * left_label, char const * right_label, char const * target_label, svn_wc_conflict_version_t left_version, svn_wc_conflict_version_t right_version, svn_boolean_t dry_run, char const * diff3_cmd, apr_array_header_t merge_options, apr_array_header_t prop_diff, svn_wc_conflict_resolver_func2_t conflict_func, void * conflict_baton, svn_cancel_func_t cancel_func, apr_pool_t scratch_pool) -> svn_error_t"""
    return _wc.svn_wc_merge4(*args)

def svn_wc_merge3(*args):
    r"""svn_wc_merge3(char const * left, char const * right, char const * merge_target, svn_wc_adm_access_t adm_access, char const * left_label, char const * right_label, char const * target_label, svn_boolean_t dry_run, char const * diff3_cmd, apr_array_header_t merge_options, apr_array_header_t prop_diff, svn_wc_conflict_resolver_func_t conflict_func, void * conflict_baton, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_merge3(*args)

def svn_wc_merge2(*args):
    r"""svn_wc_merge2(char const * left, char const * right, char const * merge_target, svn_wc_adm_access_t adm_access, char const * left_label, char const * right_label, char const * target_label, svn_boolean_t dry_run, char const * diff3_cmd, apr_array_header_t merge_options, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_merge2(*args)

def svn_wc_merge(*args):
    r"""svn_wc_merge(char const * left, char const * right, char const * merge_target, svn_wc_adm_access_t adm_access, char const * left_label, char const * right_label, char const * target_label, svn_boolean_t dry_run, char const * diff3_cmd, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_merge(*args)

def svn_wc_merge_props3(*args):
    r"""svn_wc_merge_props3(svn_wc_notify_state_t * state, svn_wc_context_t wc_ctx, char const * local_abspath, svn_wc_conflict_version_t left_version, svn_wc_conflict_version_t right_version, apr_hash_t baseprops, apr_array_header_t propchanges, svn_boolean_t dry_run, svn_wc_conflict_resolver_func2_t conflict_func, void * conflict_baton, svn_cancel_func_t cancel_func, apr_pool_t scratch_pool) -> svn_error_t"""
    return _wc.svn_wc_merge_props3(*args)

def svn_wc_merge_props2(*args):
    r"""svn_wc_merge_props2(svn_wc_notify_state_t * state, char const * path, svn_wc_adm_access_t adm_access, apr_hash_t baseprops, apr_array_header_t propchanges, svn_boolean_t base_merge, svn_boolean_t dry_run, svn_wc_conflict_resolver_func_t conflict_func, void * conflict_baton, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_merge_props2(*args)

def svn_wc_merge_props(*args):
    r"""svn_wc_merge_props(svn_wc_notify_state_t * state, char const * path, svn_wc_adm_access_t adm_access, apr_hash_t baseprops, apr_array_header_t propchanges, svn_boolean_t base_merge, svn_boolean_t dry_run, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_merge_props(*args)

def svn_wc_merge_prop_diffs(*args):
    r"""svn_wc_merge_prop_diffs(svn_wc_notify_state_t * state, char const * path, svn_wc_adm_access_t adm_access, apr_array_header_t propchanges, svn_boolean_t base_merge, svn_boolean_t dry_run, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_merge_prop_diffs(*args)

def svn_wc_get_pristine_contents2(*args):
    r"""svn_wc_get_pristine_contents2(svn_wc_context_t wc_ctx, char const * local_abspath, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _wc.svn_wc_get_pristine_contents2(*args)

def svn_wc_get_pristine_contents(*args):
    r"""svn_wc_get_pristine_contents(char const * path, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _wc.svn_wc_get_pristine_contents(*args)

def svn_wc_get_pristine_copy_path(*args):
    r"""svn_wc_get_pristine_copy_path(char const * path, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_get_pristine_copy_path(*args)

def svn_wc_cleanup4(*args):
    r"""svn_wc_cleanup4(svn_wc_context_t wc_ctx, char const * local_abspath, svn_boolean_t break_locks, svn_boolean_t fix_recorded_timestamps, svn_boolean_t clear_dav_cache, svn_boolean_t vacuum_pristines, svn_cancel_func_t cancel_func, svn_wc_notify_func2_t notify_func, apr_pool_t scratch_pool) -> svn_error_t"""
    return _wc.svn_wc_cleanup4(*args)

def svn_wc_cleanup3(*args):
    r"""svn_wc_cleanup3(svn_wc_context_t wc_ctx, char const * local_abspath, svn_cancel_func_t cancel_func, apr_pool_t scratch_pool) -> svn_error_t"""
    return _wc.svn_wc_cleanup3(*args)

def svn_wc_cleanup2(*args):
    r"""svn_wc_cleanup2(char const * path, char const * diff3_cmd, svn_cancel_func_t cancel_func, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_cleanup2(*args)

def svn_wc_cleanup(*args):
    r"""svn_wc_cleanup(char const * path, svn_wc_adm_access_t optional_adm_access, char const * diff3_cmd, svn_cancel_func_t cancel_func, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_cleanup(*args)

def svn_wc_upgrade(*args):
    r"""svn_wc_upgrade(svn_wc_context_t wc_ctx, char const * local_abspath, svn_wc_upgrade_get_repos_info_t repos_info_func, void * repos_info_baton, svn_cancel_func_t cancel_func, svn_wc_notify_func2_t notify_func, apr_pool_t scratch_pool) -> svn_error_t"""
    return _wc.svn_wc_upgrade(*args)

def svn_wc_relocate4(*args):
    r"""svn_wc_relocate4(svn_wc_context_t wc_ctx, char const * wcroot_abspath, char const * _from, char const * to, svn_wc_relocation_validator3_t validator, void * validator_baton, apr_pool_t scratch_pool) -> svn_error_t"""
    return _wc.svn_wc_relocate4(*args)

def svn_wc_relocate3(*args):
    r"""svn_wc_relocate3(char const * path, svn_wc_adm_access_t adm_access, char const * _from, char const * to, svn_boolean_t recurse, svn_wc_relocation_validator3_t validator, void * validator_baton, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_relocate3(*args)

def svn_wc_relocate2(*args):
    r"""svn_wc_relocate2(char const * path, svn_wc_adm_access_t adm_access, char const * _from, char const * to, svn_boolean_t recurse, svn_wc_relocation_validator2_t validator, void * validator_baton, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_relocate2(*args)

def svn_wc_relocate(*args):
    r"""svn_wc_relocate(char const * path, svn_wc_adm_access_t adm_access, char const * _from, char const * to, svn_boolean_t recurse, svn_wc_relocation_validator_t validator, void * validator_baton, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_relocate(*args)

def svn_wc_revert6(*args):
    r"""svn_wc_revert6(svn_wc_context_t wc_ctx, char const * local_abspath, svn_depth_t depth, svn_boolean_t use_commit_times, apr_array_header_t changelist_filter, svn_boolean_t clear_changelists, svn_boolean_t metadata_only, svn_boolean_t added_keep_local, svn_cancel_func_t cancel_func, svn_wc_notify_func2_t notify_func, apr_pool_t scratch_pool) -> svn_error_t"""
    return _wc.svn_wc_revert6(*args)

def svn_wc_revert5(*args):
    r"""svn_wc_revert5(svn_wc_context_t wc_ctx, char const * local_abspath, svn_depth_t depth, svn_boolean_t use_commit_times, apr_array_header_t changelist_filter, svn_boolean_t clear_changelists, svn_boolean_t metadata_only, svn_cancel_func_t cancel_func, svn_wc_notify_func2_t notify_func, apr_pool_t scratch_pool) -> svn_error_t"""
    return _wc.svn_wc_revert5(*args)

def svn_wc_revert4(*args):
    r"""svn_wc_revert4(svn_wc_context_t wc_ctx, char const * local_abspath, svn_depth_t depth, svn_boolean_t use_commit_times, apr_array_header_t changelist_filter, svn_cancel_func_t cancel_func, svn_wc_notify_func2_t notify_func, apr_pool_t scratch_pool) -> svn_error_t"""
    return _wc.svn_wc_revert4(*args)

def svn_wc_revert3(*args):
    r"""svn_wc_revert3(char const * path, svn_wc_adm_access_t parent_access, svn_depth_t depth, svn_boolean_t use_commit_times, apr_array_header_t changelist_filter, svn_cancel_func_t cancel_func, svn_wc_notify_func2_t notify_func, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_revert3(*args)

def svn_wc_revert2(*args):
    r"""svn_wc_revert2(char const * path, svn_wc_adm_access_t parent_access, svn_boolean_t recursive, svn_boolean_t use_commit_times, svn_cancel_func_t cancel_func, svn_wc_notify_func2_t notify_func, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_revert2(*args)

def svn_wc_revert(*args):
    r"""svn_wc_revert(char const * path, svn_wc_adm_access_t parent_access, svn_boolean_t recursive, svn_boolean_t use_commit_times, svn_cancel_func_t cancel_func, svn_wc_notify_func_t notify_func, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_revert(*args)

def svn_wc_restore(*args):
    r"""svn_wc_restore(svn_wc_context_t wc_ctx, char const * local_abspath, svn_boolean_t use_commit_times, apr_pool_t scratch_pool) -> svn_error_t"""
    return _wc.svn_wc_restore(*args)

def svn_wc_create_tmp_file2(*args):
    r"""svn_wc_create_tmp_file2(char const * path, svn_io_file_del_t delete_when, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_create_tmp_file2(*args)

def svn_wc_create_tmp_file(*args):
    r"""svn_wc_create_tmp_file(char const * path, svn_boolean_t delete_on_close, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_create_tmp_file(*args)

def svn_wc_translated_file2(*args):
    r"""svn_wc_translated_file2(char const * src, char const * versioned_file, svn_wc_adm_access_t adm_access, apr_uint32_t flags, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_translated_file2(*args)

def svn_wc_translated_file(*args):
    r"""svn_wc_translated_file(char const * vfile, svn_wc_adm_access_t adm_access, svn_boolean_t force_repair, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_translated_file(*args)

def svn_wc_translated_stream(*args):
    r"""svn_wc_translated_stream(char const * path, char const * versioned_file, svn_wc_adm_access_t adm_access, apr_uint32_t flags, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_translated_stream(*args)

def svn_wc_transmit_text_deltas3(*args):
    r"""svn_wc_transmit_text_deltas3(svn_wc_context_t wc_ctx, char const * local_abspath, svn_boolean_t fulltext, svn_delta_editor_t editor, void * file_baton, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _wc.svn_wc_transmit_text_deltas3(*args)

def svn_wc_transmit_text_deltas2(*args):
    r"""svn_wc_transmit_text_deltas2(char const * path, svn_wc_adm_access_t adm_access, svn_boolean_t fulltext, svn_delta_editor_t editor, void * file_baton, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_transmit_text_deltas2(*args)

def svn_wc_transmit_text_deltas(*args):
    r"""svn_wc_transmit_text_deltas(char const * path, svn_wc_adm_access_t adm_access, svn_boolean_t fulltext, svn_delta_editor_t editor, void * file_baton, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_transmit_text_deltas(*args)

def svn_wc_transmit_prop_deltas2(*args):
    r"""svn_wc_transmit_prop_deltas2(svn_wc_context_t wc_ctx, char const * local_abspath, svn_delta_editor_t editor, void * baton, apr_pool_t scratch_pool) -> svn_error_t"""
    return _wc.svn_wc_transmit_prop_deltas2(*args)

def svn_wc_transmit_prop_deltas(*args):
    r"""svn_wc_transmit_prop_deltas(char const * path, svn_wc_adm_access_t adm_access, svn_wc_entry_t entry, svn_delta_editor_t editor, void * baton, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_transmit_prop_deltas(*args)

def svn_wc_get_default_ignores(*args):
    r"""svn_wc_get_default_ignores(apr_hash_t config, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_get_default_ignores(*args)

def svn_wc_get_ignores2(*args):
    r"""svn_wc_get_ignores2(svn_wc_context_t wc_ctx, char const * local_abspath, apr_hash_t config, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _wc.svn_wc_get_ignores2(*args)

def svn_wc_get_ignores(*args):
    r"""svn_wc_get_ignores(apr_hash_t config, svn_wc_adm_access_t adm_access, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_get_ignores(*args)

def svn_wc_match_ignore_list(*args):
    r"""svn_wc_match_ignore_list(char const * str, apr_array_header_t list, apr_pool_t pool) -> svn_boolean_t"""
    return _wc.svn_wc_match_ignore_list(*args)

def svn_wc_add_lock2(*args):
    r"""svn_wc_add_lock2(svn_wc_context_t wc_ctx, char const * abspath, svn_lock_t lock, apr_pool_t scratch_pool) -> svn_error_t"""
    return _wc.svn_wc_add_lock2(*args)

def svn_wc_add_lock(*args):
    r"""svn_wc_add_lock(char const * path, svn_lock_t lock, svn_wc_adm_access_t adm_access, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_add_lock(*args)

def svn_wc_remove_lock2(*args):
    r"""svn_wc_remove_lock2(svn_wc_context_t wc_ctx, char const * local_abspath, apr_pool_t scratch_pool) -> svn_error_t"""
    return _wc.svn_wc_remove_lock2(*args)

def svn_wc_remove_lock(*args):
    r"""svn_wc_remove_lock(char const * path, svn_wc_adm_access_t adm_access, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_remove_lock(*args)
class svn_wc_revision_status_t(object):
    r"""Proxy of C svn_wc_revision_status_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    min_rev = property(_wc.svn_wc_revision_status_t_min_rev_get, _wc.svn_wc_revision_status_t_min_rev_set, doc=r"""min_rev : svn_revnum_t""")
    max_rev = property(_wc.svn_wc_revision_status_t_max_rev_get, _wc.svn_wc_revision_status_t_max_rev_set, doc=r"""max_rev : svn_revnum_t""")
    switched = property(_wc.svn_wc_revision_status_t_switched_get, _wc.svn_wc_revision_status_t_switched_set, doc=r"""switched : svn_boolean_t""")
    modified = property(_wc.svn_wc_revision_status_t_modified_get, _wc.svn_wc_revision_status_t_modified_set, doc=r"""modified : svn_boolean_t""")
    sparse_checkout = property(_wc.svn_wc_revision_status_t_sparse_checkout_get, _wc.svn_wc_revision_status_t_sparse_checkout_set, doc=r"""sparse_checkout : svn_boolean_t""")
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __init__(self):
        r"""__init__(svn_wc_revision_status_t self) -> svn_wc_revision_status_t"""
        _wc.svn_wc_revision_status_t_swiginit(self, _wc.new_svn_wc_revision_status_t())
    __swig_destroy__ = _wc.delete_svn_wc_revision_status_t

# Register svn_wc_revision_status_t in _wc:
_wc.svn_wc_revision_status_t_swigregister(svn_wc_revision_status_t)

def svn_wc_revision_status2(*args):
    r"""svn_wc_revision_status2(svn_wc_context_t wc_ctx, char const * local_abspath, char const * trail_url, svn_boolean_t committed, svn_cancel_func_t cancel_func, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _wc.svn_wc_revision_status2(*args)

def svn_wc_revision_status(*args):
    r"""svn_wc_revision_status(char const * wc_path, char const * trail_url, svn_boolean_t committed, svn_cancel_func_t cancel_func, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_revision_status(*args)

def svn_wc_set_changelist2(*args):
    r"""svn_wc_set_changelist2(svn_wc_context_t wc_ctx, char const * local_abspath, char const * changelist, svn_depth_t depth, apr_array_header_t changelist_filter, svn_cancel_func_t cancel_func, svn_wc_notify_func2_t notify_func, apr_pool_t scratch_pool) -> svn_error_t"""
    return _wc.svn_wc_set_changelist2(*args)

def svn_wc_set_changelist(*args):
    r"""svn_wc_set_changelist(char const * path, char const * changelist, svn_wc_adm_access_t adm_access, svn_cancel_func_t cancel_func, svn_wc_notify_func2_t notify_func, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_set_changelist(*args)

def svn_wc_get_changelists(*args):
    r"""svn_wc_get_changelists(svn_wc_context_t wc_ctx, char const * local_abspath, svn_depth_t depth, apr_array_header_t changelist_filter, svn_changelist_receiver_t callback_func, void * callback_baton, svn_cancel_func_t cancel_func, apr_pool_t scratch_pool) -> svn_error_t"""
    return _wc.svn_wc_get_changelists(*args)

def svn_wc_crop_tree2(*args):
    r"""svn_wc_crop_tree2(svn_wc_context_t wc_ctx, char const * local_abspath, svn_depth_t depth, svn_cancel_func_t cancel_func, svn_wc_notify_func2_t notify_func, apr_pool_t scratch_pool) -> svn_error_t"""
    return _wc.svn_wc_crop_tree2(*args)

def svn_wc_crop_tree(*args):
    r"""svn_wc_crop_tree(svn_wc_adm_access_t anchor, char const * target, svn_depth_t depth, svn_wc_notify_func2_t notify_func, svn_cancel_func_t cancel_func, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_crop_tree(*args)

def svn_wc_exclude(*args):
    r"""svn_wc_exclude(svn_wc_context_t wc_ctx, char const * local_abspath, svn_cancel_func_t cancel_func, svn_wc_notify_func2_t notify_func, apr_pool_t scratch_pool) -> svn_error_t"""
    return _wc.svn_wc_exclude(*args)

def svn_wc_read_kind2(*args):
    r"""svn_wc_read_kind2(svn_wc_context_t wc_ctx, char const * local_abspath, svn_boolean_t show_deleted, svn_boolean_t show_hidden, apr_pool_t scratch_pool) -> svn_error_t"""
    return _wc.svn_wc_read_kind2(*args)

def svn_wc_read_kind(*args):
    r"""svn_wc_read_kind(svn_wc_context_t wc_ctx, char const * abspath, svn_boolean_t show_hidden, apr_pool_t scratch_pool) -> svn_error_t"""
    return _wc.svn_wc_read_kind(*args)
class svn_wc_context_t(object):
    r"""Proxy of C svn_wc_context_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


# Register svn_wc_context_t in _wc:
_wc.svn_wc_context_t_swigregister(svn_wc_context_t)
class svn_wc_adm_access_t(object):
    r"""Proxy of C svn_wc_adm_access_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


# Register svn_wc_adm_access_t in _wc:
_wc.svn_wc_adm_access_t_swigregister(svn_wc_adm_access_t)
class svn_wc_traversal_info_t(object):
    r"""Proxy of C svn_wc_traversal_info_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


# Register svn_wc_traversal_info_t in _wc:
_wc.svn_wc_traversal_info_t_swigregister(svn_wc_traversal_info_t)
class svn_wc_committed_queue_t(object):
    r"""Proxy of C svn_wc_committed_queue_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


# Register svn_wc_committed_queue_t in _wc:
_wc.svn_wc_committed_queue_t_swigregister(svn_wc_committed_queue_t)

def svn_wc_diff_callbacks4_invoke_file_opened(*args):
    r"""svn_wc_diff_callbacks4_invoke_file_opened(svn_wc_diff_callbacks4_t _obj, char const * path, svn_revnum_t rev, void * diff_baton, apr_pool_t scratch_pool) -> svn_error_t"""
    return _wc.svn_wc_diff_callbacks4_invoke_file_opened(*args)

def svn_wc_diff_callbacks4_invoke_file_changed(*args):
    r"""svn_wc_diff_callbacks4_invoke_file_changed(svn_wc_diff_callbacks4_t _obj, svn_wc_notify_state_t * contentstate, svn_wc_notify_state_t * propstate, char const * path, char const * tmpfile1, char const * tmpfile2, svn_revnum_t rev1, svn_revnum_t rev2, char const * mimetype1, char const * mimetype2, apr_array_header_t propchanges, apr_hash_t originalprops, void * diff_baton, apr_pool_t scratch_pool) -> svn_error_t"""
    return _wc.svn_wc_diff_callbacks4_invoke_file_changed(*args)

def svn_wc_diff_callbacks4_invoke_file_added(*args):
    r"""svn_wc_diff_callbacks4_invoke_file_added(svn_wc_diff_callbacks4_t _obj, svn_wc_notify_state_t * contentstate, svn_wc_notify_state_t * propstate, char const * path, char const * tmpfile1, char const * tmpfile2, svn_revnum_t rev1, svn_revnum_t rev2, char const * mimetype1, char const * mimetype2, char const * copyfrom_path, svn_revnum_t copyfrom_revision, apr_array_header_t propchanges, apr_hash_t originalprops, void * diff_baton, apr_pool_t scratch_pool) -> svn_error_t"""
    return _wc.svn_wc_diff_callbacks4_invoke_file_added(*args)

def svn_wc_diff_callbacks4_invoke_file_deleted(*args):
    r"""svn_wc_diff_callbacks4_invoke_file_deleted(svn_wc_diff_callbacks4_t _obj, svn_wc_notify_state_t * state, char const * path, char const * tmpfile1, char const * tmpfile2, char const * mimetype1, char const * mimetype2, apr_hash_t originalprops, void * diff_baton, apr_pool_t scratch_pool) -> svn_error_t"""
    return _wc.svn_wc_diff_callbacks4_invoke_file_deleted(*args)

def svn_wc_diff_callbacks4_invoke_dir_deleted(*args):
    r"""svn_wc_diff_callbacks4_invoke_dir_deleted(svn_wc_diff_callbacks4_t _obj, svn_wc_notify_state_t * state, char const * path, void * diff_baton, apr_pool_t scratch_pool) -> svn_error_t"""
    return _wc.svn_wc_diff_callbacks4_invoke_dir_deleted(*args)

def svn_wc_diff_callbacks4_invoke_dir_opened(*args):
    r"""svn_wc_diff_callbacks4_invoke_dir_opened(svn_wc_diff_callbacks4_t _obj, char const * path, svn_revnum_t rev, void * diff_baton, apr_pool_t scratch_pool) -> svn_error_t"""
    return _wc.svn_wc_diff_callbacks4_invoke_dir_opened(*args)

def svn_wc_diff_callbacks4_invoke_dir_added(*args):
    r"""svn_wc_diff_callbacks4_invoke_dir_added(svn_wc_diff_callbacks4_t _obj, svn_wc_notify_state_t * state, char const * path, svn_revnum_t rev, char const * copyfrom_path, svn_revnum_t copyfrom_revision, void * diff_baton, apr_pool_t scratch_pool) -> svn_error_t"""
    return _wc.svn_wc_diff_callbacks4_invoke_dir_added(*args)

def svn_wc_diff_callbacks4_invoke_dir_props_changed(*args):
    r"""svn_wc_diff_callbacks4_invoke_dir_props_changed(svn_wc_diff_callbacks4_t _obj, svn_wc_notify_state_t * propstate, char const * path, svn_boolean_t dir_was_added, apr_array_header_t propchanges, apr_hash_t original_props, void * diff_baton, apr_pool_t scratch_pool) -> svn_error_t"""
    return _wc.svn_wc_diff_callbacks4_invoke_dir_props_changed(*args)

def svn_wc_diff_callbacks4_invoke_dir_closed(*args):
    r"""svn_wc_diff_callbacks4_invoke_dir_closed(svn_wc_diff_callbacks4_t _obj, svn_wc_notify_state_t * contentstate, svn_wc_notify_state_t * propstate, char const * path, svn_boolean_t dir_was_added, void * diff_baton, apr_pool_t scratch_pool) -> svn_error_t"""
    return _wc.svn_wc_diff_callbacks4_invoke_dir_closed(*args)

def svn_wc_diff_callbacks3_invoke_file_changed(_obj, adm_access, contentstate, propstate, path, tmpfile1, tmpfile2, rev1, rev2, mimetype1, mimetype2, propchanges, originalprops, diff_baton):
    r"""svn_wc_diff_callbacks3_invoke_file_changed(svn_wc_diff_callbacks3_t _obj, svn_wc_adm_access_t adm_access, svn_wc_notify_state_t * contentstate, svn_wc_notify_state_t * propstate, char const * path, char const * tmpfile1, char const * tmpfile2, svn_revnum_t rev1, svn_revnum_t rev2, char const * mimetype1, char const * mimetype2, apr_array_header_t propchanges, apr_hash_t originalprops, void * diff_baton) -> svn_error_t"""
    return _wc.svn_wc_diff_callbacks3_invoke_file_changed(_obj, adm_access, contentstate, propstate, path, tmpfile1, tmpfile2, rev1, rev2, mimetype1, mimetype2, propchanges, originalprops, diff_baton)

def svn_wc_diff_callbacks3_invoke_file_added(_obj, adm_access, contentstate, propstate, path, tmpfile1, tmpfile2, rev1, rev2, mimetype1, mimetype2, propchanges, originalprops, diff_baton):
    r"""svn_wc_diff_callbacks3_invoke_file_added(svn_wc_diff_callbacks3_t _obj, svn_wc_adm_access_t adm_access, svn_wc_notify_state_t * contentstate, svn_wc_notify_state_t * propstate, char const * path, char const * tmpfile1, char const * tmpfile2, svn_revnum_t rev1, svn_revnum_t rev2, char const * mimetype1, char const * mimetype2, apr_array_header_t propchanges, apr_hash_t originalprops, void * diff_baton) -> svn_error_t"""
    return _wc.svn_wc_diff_callbacks3_invoke_file_added(_obj, adm_access, contentstate, propstate, path, tmpfile1, tmpfile2, rev1, rev2, mimetype1, mimetype2, propchanges, originalprops, diff_baton)

def svn_wc_diff_callbacks3_invoke_file_deleted(_obj, adm_access, state, path, tmpfile1, tmpfile2, mimetype1, mimetype2, originalprops, diff_baton):
    r"""svn_wc_diff_callbacks3_invoke_file_deleted(svn_wc_diff_callbacks3_t _obj, svn_wc_adm_access_t adm_access, svn_wc_notify_state_t * state, char const * path, char const * tmpfile1, char const * tmpfile2, char const * mimetype1, char const * mimetype2, apr_hash_t originalprops, void * diff_baton) -> svn_error_t"""
    return _wc.svn_wc_diff_callbacks3_invoke_file_deleted(_obj, adm_access, state, path, tmpfile1, tmpfile2, mimetype1, mimetype2, originalprops, diff_baton)

def svn_wc_diff_callbacks3_invoke_dir_added(_obj, adm_access, state, path, rev, diff_baton):
    r"""svn_wc_diff_callbacks3_invoke_dir_added(svn_wc_diff_callbacks3_t _obj, svn_wc_adm_access_t adm_access, svn_wc_notify_state_t * state, char const * path, svn_revnum_t rev, void * diff_baton) -> svn_error_t"""
    return _wc.svn_wc_diff_callbacks3_invoke_dir_added(_obj, adm_access, state, path, rev, diff_baton)

def svn_wc_diff_callbacks3_invoke_dir_deleted(_obj, adm_access, state, path, diff_baton):
    r"""svn_wc_diff_callbacks3_invoke_dir_deleted(svn_wc_diff_callbacks3_t _obj, svn_wc_adm_access_t adm_access, svn_wc_notify_state_t * state, char const * path, void * diff_baton) -> svn_error_t"""
    return _wc.svn_wc_diff_callbacks3_invoke_dir_deleted(_obj, adm_access, state, path, diff_baton)

def svn_wc_diff_callbacks3_invoke_dir_props_changed(_obj, adm_access, propstate, path, propchanges, original_props, diff_baton):
    r"""svn_wc_diff_callbacks3_invoke_dir_props_changed(svn_wc_diff_callbacks3_t _obj, svn_wc_adm_access_t adm_access, svn_wc_notify_state_t * propstate, char const * path, apr_array_header_t propchanges, apr_hash_t original_props, void * diff_baton) -> svn_error_t"""
    return _wc.svn_wc_diff_callbacks3_invoke_dir_props_changed(_obj, adm_access, propstate, path, propchanges, original_props, diff_baton)

def svn_wc_diff_callbacks3_invoke_dir_opened(_obj, adm_access, path, rev, diff_baton):
    r"""svn_wc_diff_callbacks3_invoke_dir_opened(svn_wc_diff_callbacks3_t _obj, svn_wc_adm_access_t adm_access, char const * path, svn_revnum_t rev, void * diff_baton) -> svn_error_t"""
    return _wc.svn_wc_diff_callbacks3_invoke_dir_opened(_obj, adm_access, path, rev, diff_baton)

def svn_wc_diff_callbacks3_invoke_dir_closed(_obj, adm_access, contentstate, propstate, path, diff_baton):
    r"""svn_wc_diff_callbacks3_invoke_dir_closed(svn_wc_diff_callbacks3_t _obj, svn_wc_adm_access_t adm_access, svn_wc_notify_state_t * contentstate, svn_wc_notify_state_t * propstate, char const * path, void * diff_baton) -> svn_error_t"""
    return _wc.svn_wc_diff_callbacks3_invoke_dir_closed(_obj, adm_access, contentstate, propstate, path, diff_baton)

def svn_wc_diff_callbacks2_invoke_file_changed(_obj, adm_access, contentstate, propstate, path, tmpfile1, tmpfile2, rev1, rev2, mimetype1, mimetype2, propchanges, originalprops, diff_baton):
    r"""svn_wc_diff_callbacks2_invoke_file_changed(svn_wc_diff_callbacks2_t _obj, svn_wc_adm_access_t adm_access, svn_wc_notify_state_t * contentstate, svn_wc_notify_state_t * propstate, char const * path, char const * tmpfile1, char const * tmpfile2, svn_revnum_t rev1, svn_revnum_t rev2, char const * mimetype1, char const * mimetype2, apr_array_header_t propchanges, apr_hash_t originalprops, void * diff_baton) -> svn_error_t"""
    return _wc.svn_wc_diff_callbacks2_invoke_file_changed(_obj, adm_access, contentstate, propstate, path, tmpfile1, tmpfile2, rev1, rev2, mimetype1, mimetype2, propchanges, originalprops, diff_baton)

def svn_wc_diff_callbacks2_invoke_file_added(_obj, adm_access, contentstate, propstate, path, tmpfile1, tmpfile2, rev1, rev2, mimetype1, mimetype2, propchanges, originalprops, diff_baton):
    r"""svn_wc_diff_callbacks2_invoke_file_added(svn_wc_diff_callbacks2_t _obj, svn_wc_adm_access_t adm_access, svn_wc_notify_state_t * contentstate, svn_wc_notify_state_t * propstate, char const * path, char const * tmpfile1, char const * tmpfile2, svn_revnum_t rev1, svn_revnum_t rev2, char const * mimetype1, char const * mimetype2, apr_array_header_t propchanges, apr_hash_t originalprops, void * diff_baton) -> svn_error_t"""
    return _wc.svn_wc_diff_callbacks2_invoke_file_added(_obj, adm_access, contentstate, propstate, path, tmpfile1, tmpfile2, rev1, rev2, mimetype1, mimetype2, propchanges, originalprops, diff_baton)

def svn_wc_diff_callbacks2_invoke_file_deleted(_obj, adm_access, state, path, tmpfile1, tmpfile2, mimetype1, mimetype2, originalprops, diff_baton):
    r"""svn_wc_diff_callbacks2_invoke_file_deleted(svn_wc_diff_callbacks2_t _obj, svn_wc_adm_access_t adm_access, svn_wc_notify_state_t * state, char const * path, char const * tmpfile1, char const * tmpfile2, char const * mimetype1, char const * mimetype2, apr_hash_t originalprops, void * diff_baton) -> svn_error_t"""
    return _wc.svn_wc_diff_callbacks2_invoke_file_deleted(_obj, adm_access, state, path, tmpfile1, tmpfile2, mimetype1, mimetype2, originalprops, diff_baton)

def svn_wc_diff_callbacks2_invoke_dir_added(_obj, adm_access, state, path, rev, diff_baton):
    r"""svn_wc_diff_callbacks2_invoke_dir_added(svn_wc_diff_callbacks2_t _obj, svn_wc_adm_access_t adm_access, svn_wc_notify_state_t * state, char const * path, svn_revnum_t rev, void * diff_baton) -> svn_error_t"""
    return _wc.svn_wc_diff_callbacks2_invoke_dir_added(_obj, adm_access, state, path, rev, diff_baton)

def svn_wc_diff_callbacks2_invoke_dir_deleted(_obj, adm_access, state, path, diff_baton):
    r"""svn_wc_diff_callbacks2_invoke_dir_deleted(svn_wc_diff_callbacks2_t _obj, svn_wc_adm_access_t adm_access, svn_wc_notify_state_t * state, char const * path, void * diff_baton) -> svn_error_t"""
    return _wc.svn_wc_diff_callbacks2_invoke_dir_deleted(_obj, adm_access, state, path, diff_baton)

def svn_wc_diff_callbacks2_invoke_dir_props_changed(_obj, adm_access, state, path, propchanges, original_props, diff_baton):
    r"""svn_wc_diff_callbacks2_invoke_dir_props_changed(svn_wc_diff_callbacks2_t _obj, svn_wc_adm_access_t adm_access, svn_wc_notify_state_t * state, char const * path, apr_array_header_t propchanges, apr_hash_t original_props, void * diff_baton) -> svn_error_t"""
    return _wc.svn_wc_diff_callbacks2_invoke_dir_props_changed(_obj, adm_access, state, path, propchanges, original_props, diff_baton)

def svn_wc_diff_callbacks_invoke_file_changed(_obj, adm_access, state, path, tmpfile1, tmpfile2, rev1, rev2, mimetype1, mimetype2, diff_baton):
    r"""svn_wc_diff_callbacks_invoke_file_changed(svn_wc_diff_callbacks_t _obj, svn_wc_adm_access_t adm_access, svn_wc_notify_state_t * state, char const * path, char const * tmpfile1, char const * tmpfile2, svn_revnum_t rev1, svn_revnum_t rev2, char const * mimetype1, char const * mimetype2, void * diff_baton) -> svn_error_t"""
    return _wc.svn_wc_diff_callbacks_invoke_file_changed(_obj, adm_access, state, path, tmpfile1, tmpfile2, rev1, rev2, mimetype1, mimetype2, diff_baton)

def svn_wc_diff_callbacks_invoke_file_added(_obj, adm_access, state, path, tmpfile1, tmpfile2, rev1, rev2, mimetype1, mimetype2, diff_baton):
    r"""svn_wc_diff_callbacks_invoke_file_added(svn_wc_diff_callbacks_t _obj, svn_wc_adm_access_t adm_access, svn_wc_notify_state_t * state, char const * path, char const * tmpfile1, char const * tmpfile2, svn_revnum_t rev1, svn_revnum_t rev2, char const * mimetype1, char const * mimetype2, void * diff_baton) -> svn_error_t"""
    return _wc.svn_wc_diff_callbacks_invoke_file_added(_obj, adm_access, state, path, tmpfile1, tmpfile2, rev1, rev2, mimetype1, mimetype2, diff_baton)

def svn_wc_diff_callbacks_invoke_file_deleted(_obj, adm_access, state, path, tmpfile1, tmpfile2, mimetype1, mimetype2, diff_baton):
    r"""svn_wc_diff_callbacks_invoke_file_deleted(svn_wc_diff_callbacks_t _obj, svn_wc_adm_access_t adm_access, svn_wc_notify_state_t * state, char const * path, char const * tmpfile1, char const * tmpfile2, char const * mimetype1, char const * mimetype2, void * diff_baton) -> svn_error_t"""
    return _wc.svn_wc_diff_callbacks_invoke_file_deleted(_obj, adm_access, state, path, tmpfile1, tmpfile2, mimetype1, mimetype2, diff_baton)

def svn_wc_diff_callbacks_invoke_dir_added(_obj, adm_access, state, path, rev, diff_baton):
    r"""svn_wc_diff_callbacks_invoke_dir_added(svn_wc_diff_callbacks_t _obj, svn_wc_adm_access_t adm_access, svn_wc_notify_state_t * state, char const * path, svn_revnum_t rev, void * diff_baton) -> svn_error_t"""
    return _wc.svn_wc_diff_callbacks_invoke_dir_added(_obj, adm_access, state, path, rev, diff_baton)

def svn_wc_diff_callbacks_invoke_dir_deleted(_obj, adm_access, state, path, diff_baton):
    r"""svn_wc_diff_callbacks_invoke_dir_deleted(svn_wc_diff_callbacks_t _obj, svn_wc_adm_access_t adm_access, svn_wc_notify_state_t * state, char const * path, void * diff_baton) -> svn_error_t"""
    return _wc.svn_wc_diff_callbacks_invoke_dir_deleted(_obj, adm_access, state, path, diff_baton)

def svn_wc_diff_callbacks_invoke_props_changed(_obj, adm_access, state, path, propchanges, original_props, diff_baton):
    r"""svn_wc_diff_callbacks_invoke_props_changed(svn_wc_diff_callbacks_t _obj, svn_wc_adm_access_t adm_access, svn_wc_notify_state_t * state, char const * path, apr_array_header_t propchanges, apr_hash_t original_props, void * diff_baton) -> svn_error_t"""
    return _wc.svn_wc_diff_callbacks_invoke_props_changed(_obj, adm_access, state, path, propchanges, original_props, diff_baton)

def svn_wc_entry_callbacks2_invoke_found_entry(*args):
    r"""svn_wc_entry_callbacks2_invoke_found_entry(svn_wc_entry_callbacks2_t _obj, char const * path, svn_wc_entry_t entry, void * walk_baton, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_entry_callbacks2_invoke_found_entry(*args)

def svn_wc_entry_callbacks2_invoke_handle_error(*args):
    r"""svn_wc_entry_callbacks2_invoke_handle_error(svn_wc_entry_callbacks2_t _obj, char const * path, svn_error_t err, void * walk_baton, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_entry_callbacks2_invoke_handle_error(*args)

def svn_wc_entry_callbacks_invoke_found_entry(*args):
    r"""svn_wc_entry_callbacks_invoke_found_entry(svn_wc_entry_callbacks_t _obj, char const * path, svn_wc_entry_t entry, void * walk_baton, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_entry_callbacks_invoke_found_entry(*args)

def svn_wc_invoke_external_update(*args):
    r"""svn_wc_invoke_external_update(svn_wc_external_update_t _obj, void * baton, char const * local_abspath, svn_string_t const * old_val, svn_string_t const * new_val, svn_depth_t depth, apr_pool_t scratch_pool) -> svn_error_t"""
    return _wc.svn_wc_invoke_external_update(*args)

def svn_wc_invoke_notify_func2(*args):
    r"""svn_wc_invoke_notify_func2(svn_wc_notify_func2_t _obj, void * baton, svn_wc_notify_t notify, apr_pool_t pool)"""
    return _wc.svn_wc_invoke_notify_func2(*args)

def svn_wc_invoke_notify_func(_obj, baton, path, action, kind, mime_type, content_state, prop_state, revision):
    r"""svn_wc_invoke_notify_func(svn_wc_notify_func_t _obj, void * baton, char const * path, svn_wc_notify_action_t action, svn_node_kind_t kind, char const * mime_type, svn_wc_notify_state_t content_state, svn_wc_notify_state_t prop_state, svn_revnum_t revision)"""
    return _wc.svn_wc_invoke_notify_func(_obj, baton, path, action, kind, mime_type, content_state, prop_state, revision)

def svn_wc_invoke_conflict_resolver_func2(*args):
    r"""svn_wc_invoke_conflict_resolver_func2(svn_wc_conflict_resolver_func2_t _obj, svn_wc_conflict_description2_t const * description, void * baton, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _wc.svn_wc_invoke_conflict_resolver_func2(*args)

def svn_wc_invoke_conflict_resolver_func(*args):
    r"""svn_wc_invoke_conflict_resolver_func(svn_wc_conflict_resolver_func_t _obj, svn_wc_conflict_description_t description, void * baton, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_invoke_conflict_resolver_func(*args)

def svn_wc_invoke_status_func4(*args):
    r"""svn_wc_invoke_status_func4(svn_wc_status_func4_t _obj, void * baton, char const * local_abspath, svn_wc_status3_t status, apr_pool_t scratch_pool) -> svn_error_t"""
    return _wc.svn_wc_invoke_status_func4(*args)

def svn_wc_invoke_status_func3(*args):
    r"""svn_wc_invoke_status_func3(svn_wc_status_func3_t _obj, void * baton, char const * path, svn_wc_status2_t status, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_invoke_status_func3(*args)

def svn_wc_invoke_status_func2(_obj, baton, path, status):
    r"""svn_wc_invoke_status_func2(svn_wc_status_func2_t _obj, void * baton, char const * path, svn_wc_status2_t status)"""
    return _wc.svn_wc_invoke_status_func2(_obj, baton, path, status)

def svn_wc_invoke_status_func(_obj, baton, path, status):
    r"""svn_wc_invoke_status_func(svn_wc_status_func_t _obj, void * baton, char const * path, svn_wc_status_t status)"""
    return _wc.svn_wc_invoke_status_func(_obj, baton, path, status)

def svn_wc_invoke_get_file(*args):
    r"""svn_wc_invoke_get_file(svn_wc_get_file_t _obj, void * baton, char const * path, svn_revnum_t revision, svn_stream_t stream, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_invoke_get_file(*args)

def svn_wc_invoke_dirents_func(*args):
    r"""svn_wc_invoke_dirents_func(svn_wc_dirents_func_t _obj, void * baton, char const * repos_root_url, char const * repos_relpath, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _wc.svn_wc_invoke_dirents_func(*args)

def svn_wc_invoke_canonicalize_svn_prop_get_file(*args):
    r"""svn_wc_invoke_canonicalize_svn_prop_get_file(svn_wc_canonicalize_svn_prop_get_file_t _obj, svn_stream_t stream, void * baton, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_invoke_canonicalize_svn_prop_get_file(*args)

def svn_wc_invoke_upgrade_get_repos_info(*args):
    r"""svn_wc_invoke_upgrade_get_repos_info(svn_wc_upgrade_get_repos_info_t _obj, void * baton, char const * url, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _wc.svn_wc_invoke_upgrade_get_repos_info(*args)

def svn_wc_invoke_relocation_validator3(*args):
    r"""svn_wc_invoke_relocation_validator3(svn_wc_relocation_validator3_t _obj, void * baton, char const * uuid, char const * url, char const * root_url, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_invoke_relocation_validator3(*args)

def svn_wc_invoke_relocation_validator2(*args):
    r"""svn_wc_invoke_relocation_validator2(svn_wc_relocation_validator2_t _obj, void * baton, char const * uuid, char const * url, svn_boolean_t root, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_invoke_relocation_validator2(*args)

def svn_wc_invoke_relocation_validator(_obj, baton, uuid, url):
    r"""svn_wc_invoke_relocation_validator(svn_wc_relocation_validator_t _obj, void * baton, char const * uuid, char const * url) -> svn_error_t"""
    return _wc.svn_wc_invoke_relocation_validator(_obj, baton, uuid, url)

def svn_changelist_invoke_receiver(*args):
    r"""svn_changelist_invoke_receiver(svn_changelist_receiver_t _obj, void * baton, char const * path, char const * changelist, apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_changelist_invoke_receiver(*args)
class svn_wc_external_update_t(object):
    r"""Proxy of C svn_wc_external_update_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_wc_invoke_external_update(self, *args)


# Register svn_wc_external_update_t in _wc:
_wc.svn_wc_external_update_t_swigregister(svn_wc_external_update_t)
class svn_wc_notify_func2_t(object):
    r"""Proxy of C svn_wc_notify_func2_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_wc_invoke_notify_func2(self, *args)


# Register svn_wc_notify_func2_t in _wc:
_wc.svn_wc_notify_func2_t_swigregister(svn_wc_notify_func2_t)
class svn_wc_notify_func_t(object):
    r"""Proxy of C svn_wc_notify_func_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_wc_invoke_notify_func(self, *args)


# Register svn_wc_notify_func_t in _wc:
_wc.svn_wc_notify_func_t_swigregister(svn_wc_notify_func_t)
class svn_wc_conflict_resolver_func2_t(object):
    r"""Proxy of C svn_wc_conflict_resolver_func2_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_wc_invoke_conflict_resolver_func2(self, *args)


# Register svn_wc_conflict_resolver_func2_t in _wc:
_wc.svn_wc_conflict_resolver_func2_t_swigregister(svn_wc_conflict_resolver_func2_t)
class svn_wc_conflict_resolver_func_t(object):
    r"""Proxy of C svn_wc_conflict_resolver_func_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_wc_invoke_conflict_resolver_func(self, *args)


# Register svn_wc_conflict_resolver_func_t in _wc:
_wc.svn_wc_conflict_resolver_func_t_swigregister(svn_wc_conflict_resolver_func_t)
class svn_wc_status_func4_t(object):
    r"""Proxy of C svn_wc_status_func4_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_wc_invoke_status_func4(self, *args)


# Register svn_wc_status_func4_t in _wc:
_wc.svn_wc_status_func4_t_swigregister(svn_wc_status_func4_t)
class svn_wc_status_func3_t(object):
    r"""Proxy of C svn_wc_status_func3_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_wc_invoke_status_func3(self, *args)


# Register svn_wc_status_func3_t in _wc:
_wc.svn_wc_status_func3_t_swigregister(svn_wc_status_func3_t)
class svn_wc_status_func2_t(object):
    r"""Proxy of C svn_wc_status_func2_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_wc_invoke_status_func2(self, *args)


# Register svn_wc_status_func2_t in _wc:
_wc.svn_wc_status_func2_t_swigregister(svn_wc_status_func2_t)
class svn_wc_status_func_t(object):
    r"""Proxy of C svn_wc_status_func_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_wc_invoke_status_func(self, *args)


# Register svn_wc_status_func_t in _wc:
_wc.svn_wc_status_func_t_swigregister(svn_wc_status_func_t)
class svn_wc_get_file_t(object):
    r"""Proxy of C svn_wc_get_file_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_wc_invoke_get_file(self, *args)


# Register svn_wc_get_file_t in _wc:
_wc.svn_wc_get_file_t_swigregister(svn_wc_get_file_t)
class svn_wc_dirents_func_t(object):
    r"""Proxy of C svn_wc_dirents_func_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_wc_invoke_dirents_func(self, *args)


# Register svn_wc_dirents_func_t in _wc:
_wc.svn_wc_dirents_func_t_swigregister(svn_wc_dirents_func_t)
class svn_wc_canonicalize_svn_prop_get_file_t(object):
    r"""Proxy of C svn_wc_canonicalize_svn_prop_get_file_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_wc_invoke_canonicalize_svn_prop_get_file(self, *args)


# Register svn_wc_canonicalize_svn_prop_get_file_t in _wc:
_wc.svn_wc_canonicalize_svn_prop_get_file_t_swigregister(svn_wc_canonicalize_svn_prop_get_file_t)
class svn_wc_upgrade_get_repos_info_t(object):
    r"""Proxy of C svn_wc_upgrade_get_repos_info_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_wc_invoke_upgrade_get_repos_info(self, *args)


# Register svn_wc_upgrade_get_repos_info_t in _wc:
_wc.svn_wc_upgrade_get_repos_info_t_swigregister(svn_wc_upgrade_get_repos_info_t)
class svn_wc_relocation_validator3_t(object):
    r"""Proxy of C svn_wc_relocation_validator3_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_wc_invoke_relocation_validator3(self, *args)


# Register svn_wc_relocation_validator3_t in _wc:
_wc.svn_wc_relocation_validator3_t_swigregister(svn_wc_relocation_validator3_t)
class svn_wc_relocation_validator2_t(object):
    r"""Proxy of C svn_wc_relocation_validator2_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_wc_invoke_relocation_validator2(self, *args)


# Register svn_wc_relocation_validator2_t in _wc:
_wc.svn_wc_relocation_validator2_t_swigregister(svn_wc_relocation_validator2_t)
class svn_wc_relocation_validator_t(object):
    r"""Proxy of C svn_wc_relocation_validator_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_wc_invoke_relocation_validator(self, *args)


# Register svn_wc_relocation_validator_t in _wc:
_wc.svn_wc_relocation_validator_t_swigregister(svn_wc_relocation_validator_t)
class svn_changelist_receiver_t(object):
    r"""Proxy of C svn_changelist_receiver_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_changelist_invoke_receiver(self, *args)


# Register svn_changelist_receiver_t in _wc:
_wc.svn_changelist_receiver_t_swigregister(svn_changelist_receiver_t)

def svn_wc_swig_init_asp_dot_net_hack(*args):
    r"""svn_wc_swig_init_asp_dot_net_hack(apr_pool_t pool) -> svn_error_t"""
    return _wc.svn_wc_swig_init_asp_dot_net_hack(*args)
svn_wc_swig_init_asp_dot_net_hack() 


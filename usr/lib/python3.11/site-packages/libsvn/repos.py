# This file was automatically generated by SWIG (https://www.swig.org).
# Version 4.1.1
#
# Do not make changes to this file unless you know what you are doing - modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info

def _dll_paths():
    import os
    if hasattr(os, 'add_dll_directory'):  # Python 3.8+ on Windows
        cookies = []
        for path in os.environ.get('PATH', '').split(os.pathsep):
            if path and os.path.isabs(path):
                try:
                    cookie = os.add_dll_directory(path)
                except OSError:
                    continue
                else:
                    cookies.append(cookie)
        return cookies
    else:
        return ()

_dll_paths = _dll_paths()
try:
    from . import _repos
finally:
    _dll_path = None
    for _dll_path in _dll_paths:
        _dll_path.close()
    del _dll_paths, _dll_path


try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "this":
            set(self, name, value)
        elif name == "thisown":
            self.this.own(value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)



def _copy_metadata_deep(value, old_value):
  """Copy all attributes of old_value into value, recursively traversing
  lists and dicts if needed."""
  if value is None or old_value is None or value is old_value: return

  if isinstance(value, dict):
    for k in value:
      _copy_metadata_deep(value[k], old_value[k])
  elif isinstance(value, list):
    for v, old_v in zip(value, old_value):
      _copy_metadata_deep(v, old_v)
  else:
    try:
      value.__dict__.update(old_value.__dict__)
    except AttributeError:
      pass

def _assert_valid_deep(value):
  """Assert value's validity, recursively traversing lists and dicts."""
  if isinstance(value, dict):
    for k in value:
      _assert_valid_deep(value[k])
  elif isinstance(value, list):
    for v in value:
      _assert_valid_deep(v)
# Ensure that the passed in value isn't a type, which could have an
# assert_valid attribute, but it can not be called without an instance.
  elif type(value) != type:
    try:
      fn = value.assert_valid
    except AttributeError:
      pass
    else:
      fn()



  # SWIG classes generated with -classic do not define this variable,
  # so set it to 0 when it doesn't exist
try:
  _newclass
except NameError:
  _newclass = 0

if _newclass:
  def _get_instance_attr(self, name):
    try:
      return object.__getattribute__(self, name)
    except AttributeError:
      return _swig_getattr(self, object.__getattribute__(self, '__class__'),
                           name)
else:
  def _get_instance_attr(self, name):
    return _swig_getattr(self, self.__class__, name)

def _set_instance_attr(self, name, value):
  return _swig_setattr(self, self.__class__, name, value)


import libsvn.core
import libsvn.delta
import libsvn.fs

def svn_swig_py_make_parse_fns3(*args):
    r"""svn_swig_py_make_parse_fns3(PyObject * py_parse_fns3, apr_pool_t pool)"""
    return _repos.svn_swig_py_make_parse_fns3(*args)

def svn_repos_version():
    r"""svn_repos_version() -> svn_version_t"""
    return _repos.svn_repos_version()
svn_node_action_change = _repos.svn_node_action_change

svn_node_action_add = _repos.svn_node_action_add

svn_node_action_delete = _repos.svn_node_action_delete

svn_node_action_replace = _repos.svn_node_action_replace

svn_authz_none = _repos.svn_authz_none

svn_authz_read = _repos.svn_authz_read

svn_authz_write = _repos.svn_authz_write

svn_authz_recursive = _repos.svn_authz_recursive

svn_repos_notify_warning = _repos.svn_repos_notify_warning

svn_repos_notify_dump_rev_end = _repos.svn_repos_notify_dump_rev_end

svn_repos_notify_verify_rev_end = _repos.svn_repos_notify_verify_rev_end

svn_repos_notify_dump_end = _repos.svn_repos_notify_dump_end

svn_repos_notify_verify_end = _repos.svn_repos_notify_verify_end

svn_repos_notify_pack_shard_start = _repos.svn_repos_notify_pack_shard_start

svn_repos_notify_pack_shard_end = _repos.svn_repos_notify_pack_shard_end

svn_repos_notify_pack_shard_start_revprop = _repos.svn_repos_notify_pack_shard_start_revprop

svn_repos_notify_pack_shard_end_revprop = _repos.svn_repos_notify_pack_shard_end_revprop

svn_repos_notify_load_txn_start = _repos.svn_repos_notify_load_txn_start

svn_repos_notify_load_txn_committed = _repos.svn_repos_notify_load_txn_committed

svn_repos_notify_load_node_start = _repos.svn_repos_notify_load_node_start

svn_repos_notify_load_node_done = _repos.svn_repos_notify_load_node_done

svn_repos_notify_load_copied_node = _repos.svn_repos_notify_load_copied_node

svn_repos_notify_load_normalized_mergeinfo = _repos.svn_repos_notify_load_normalized_mergeinfo

svn_repos_notify_mutex_acquired = _repos.svn_repos_notify_mutex_acquired

svn_repos_notify_recover_start = _repos.svn_repos_notify_recover_start

svn_repos_notify_upgrade_start = _repos.svn_repos_notify_upgrade_start

svn_repos_notify_load_skipped_rev = _repos.svn_repos_notify_load_skipped_rev

svn_repos_notify_verify_rev_structure = _repos.svn_repos_notify_verify_rev_structure

svn_repos_notify_pack_revprops = _repos.svn_repos_notify_pack_revprops

svn_repos_notify_cleanup_revprops = _repos.svn_repos_notify_cleanup_revprops

svn_repos_notify_format_bumped = _repos.svn_repos_notify_format_bumped

svn_repos_notify_hotcopy_rev_range = _repos.svn_repos_notify_hotcopy_rev_range

svn_repos_notify_pack_noop = _repos.svn_repos_notify_pack_noop

svn_repos_notify_load_revprop_set = _repos.svn_repos_notify_load_revprop_set

svn_repos_notify_warning_found_old_reference = _repos.svn_repos_notify_warning_found_old_reference

svn_repos_notify_warning_found_old_mergeinfo = _repos.svn_repos_notify_warning_found_old_mergeinfo

svn_repos_notify_warning_invalid_fspath = _repos.svn_repos_notify_warning_invalid_fspath

svn_repos_notify_warning_name_collision = _repos.svn_repos_notify_warning_name_collision

svn_repos_notify_warning_mergeinfo_collision = _repos.svn_repos_notify_warning_mergeinfo_collision

svn_repos_notify_warning_invalid_mergeinfo = _repos.svn_repos_notify_warning_invalid_mergeinfo

class svn_repos_notify_t(object):
    r"""Proxy of C svn_repos_notify_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    action = property(_repos.svn_repos_notify_t_action_get, _repos.svn_repos_notify_t_action_set, doc=r"""action : svn_repos_notify_action_t""")
    revision = property(_repos.svn_repos_notify_t_revision_get, _repos.svn_repos_notify_t_revision_set, doc=r"""revision : svn_revnum_t""")
    warning_str = property(_repos.svn_repos_notify_t_warning_str_get, _repos.svn_repos_notify_t_warning_str_set, doc=r"""warning_str : p.q(const).char""")
    warning = property(_repos.svn_repos_notify_t_warning_get, _repos.svn_repos_notify_t_warning_set, doc=r"""warning : svn_repos_notify_warning_t""")
    shard = property(_repos.svn_repos_notify_t_shard_get, _repos.svn_repos_notify_t_shard_set, doc=r"""shard : apr_int64_t""")
    new_revision = property(_repos.svn_repos_notify_t_new_revision_get, _repos.svn_repos_notify_t_new_revision_set, doc=r"""new_revision : svn_revnum_t""")
    old_revision = property(_repos.svn_repos_notify_t_old_revision_get, _repos.svn_repos_notify_t_old_revision_set, doc=r"""old_revision : svn_revnum_t""")
    node_action = property(_repos.svn_repos_notify_t_node_action_get, _repos.svn_repos_notify_t_node_action_set, doc=r"""node_action : enum svn_node_action""")
    path = property(_repos.svn_repos_notify_t_path_get, _repos.svn_repos_notify_t_path_set, doc=r"""path : p.q(const).char""")
    start_revision = property(_repos.svn_repos_notify_t_start_revision_get, _repos.svn_repos_notify_t_start_revision_set, doc=r"""start_revision : svn_revnum_t""")
    end_revision = property(_repos.svn_repos_notify_t_end_revision_get, _repos.svn_repos_notify_t_end_revision_set, doc=r"""end_revision : svn_revnum_t""")
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


# Register svn_repos_notify_t in _repos:
_repos.svn_repos_notify_t_swigregister(svn_repos_notify_t)

def svn_repos_notify_create(*args):
    r"""svn_repos_notify_create(svn_repos_notify_action_t action, apr_pool_t result_pool) -> svn_repos_notify_t"""
    return _repos.svn_repos_notify_create(*args)

def svn_repos_find_root_path(*args):
    r"""svn_repos_find_root_path(char const * path, apr_pool_t pool) -> char const *"""
    return _repos.svn_repos_find_root_path(*args)

def svn_repos_open3(*args):
    r"""svn_repos_open3(char const * path, apr_hash_t fs_config, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _repos.svn_repos_open3(*args)

def svn_repos_open2(*args):
    r"""svn_repos_open2(char const * path, apr_hash_t fs_config, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_open2(*args)

def svn_repos_open(*args):
    r"""svn_repos_open(char const * path, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_open(*args)

def svn_repos_create(*args):
    r"""svn_repos_create(char const * path, char const * unused_1, char const * unused_2, apr_hash_t config, apr_hash_t fs_config, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_create(*args)

def svn_repos_upgrade2(*args):
    r"""svn_repos_upgrade2(char const * path, svn_boolean_t nonblocking, svn_repos_notify_func_t notify_func, void * notify_baton, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_upgrade2(*args)

def svn_repos_upgrade(*args):
    r"""svn_repos_upgrade(char const * path, svn_boolean_t nonblocking, svn_error_t *(*)(void *) start_callback, void * start_callback_baton, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_upgrade(*args)

def svn_repos_delete(*args):
    r"""svn_repos_delete(char const * path, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_delete(*args)

def svn_repos_has_capability(*args):
    r"""svn_repos_has_capability(svn_repos_t repos, char const * capability, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_has_capability(*args)

def svn_repos_capabilities(*args):
    r"""svn_repos_capabilities(svn_repos_t repos, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _repos.svn_repos_capabilities(*args)
SVN_REPOS_CAPABILITY_MERGEINFO = _repos.SVN_REPOS_CAPABILITY_MERGEINFO


def svn_repos_remember_client_capabilities(repos, capabilities):
    r"""svn_repos_remember_client_capabilities(svn_repos_t repos, apr_array_header_t capabilities) -> svn_error_t"""
    return _repos.svn_repos_remember_client_capabilities(repos, capabilities)

def svn_repos_fs(repos):
    r"""svn_repos_fs(svn_repos_t repos) -> svn_fs_t"""
    return _repos.svn_repos_fs(repos)

def svn_repos_fs_type(*args):
    r"""svn_repos_fs_type(svn_repos_t repos, apr_pool_t result_pool) -> char const *"""
    return _repos.svn_repos_fs_type(*args)

def svn_repos_hotcopy3(*args):
    r"""svn_repos_hotcopy3(char const * src_path, char const * dst_path, svn_boolean_t clean_logs, svn_boolean_t incremental, svn_repos_notify_func_t notify_func, void * notify_baton, svn_cancel_func_t cancel_func, apr_pool_t scratch_pool) -> svn_error_t"""
    return _repos.svn_repos_hotcopy3(*args)

def svn_repos_hotcopy2(*args):
    r"""svn_repos_hotcopy2(char const * src_path, char const * dst_path, svn_boolean_t clean_logs, svn_boolean_t incremental, svn_cancel_func_t cancel_func, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_hotcopy2(*args)

def svn_repos_hotcopy(*args):
    r"""svn_repos_hotcopy(char const * src_path, char const * dst_path, svn_boolean_t clean_logs, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_hotcopy(*args)

def svn_repos_fs_pack2(*args):
    r"""svn_repos_fs_pack2(svn_repos_t repos, svn_repos_notify_func_t notify_func, void * notify_baton, svn_cancel_func_t cancel_func, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_fs_pack2(*args)

def svn_repos_fs_pack(*args):
    r"""svn_repos_fs_pack(svn_repos_t repos, svn_fs_pack_notify_t notify_func, void * notify_baton, svn_cancel_func_t cancel_func, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_fs_pack(*args)

def svn_repos_recover4(*args):
    r"""svn_repos_recover4(char const * path, svn_boolean_t nonblocking, svn_repos_notify_func_t notify_func, void * notify_baton, svn_cancel_func_t cancel_func, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_recover4(*args)

def svn_repos_recover3(*args):
    r"""svn_repos_recover3(char const * path, svn_boolean_t nonblocking, svn_error_t *(*)(void *) start_callback, void * start_callback_baton, svn_cancel_func_t cancel_func, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_recover3(*args)

def svn_repos_recover2(*args):
    r"""svn_repos_recover2(char const * path, svn_boolean_t nonblocking, svn_error_t *(*)(void *) start_callback, void * start_callback_baton, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_recover2(*args)

def svn_repos_recover(*args):
    r"""svn_repos_recover(char const * path, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_recover(*args)

def svn_repos_freeze(*args):
    r"""svn_repos_freeze(apr_array_header_t paths, svn_repos_freeze_func_t freeze_func, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_freeze(*args)

def svn_repos_db_logfiles(*args):
    r"""svn_repos_db_logfiles(char const * path, svn_boolean_t only_unused, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_db_logfiles(*args)

def svn_repos_path(*args):
    r"""svn_repos_path(svn_repos_t repos, apr_pool_t pool) -> char const *"""
    return _repos.svn_repos_path(*args)

def svn_repos_db_env(*args):
    r"""svn_repos_db_env(svn_repos_t repos, apr_pool_t pool) -> char const *"""
    return _repos.svn_repos_db_env(*args)

def svn_repos_conf_dir(*args):
    r"""svn_repos_conf_dir(svn_repos_t repos, apr_pool_t pool) -> char const *"""
    return _repos.svn_repos_conf_dir(*args)

def svn_repos_svnserve_conf(*args):
    r"""svn_repos_svnserve_conf(svn_repos_t repos, apr_pool_t pool) -> char const *"""
    return _repos.svn_repos_svnserve_conf(*args)

def svn_repos_lock_dir(*args):
    r"""svn_repos_lock_dir(svn_repos_t repos, apr_pool_t pool) -> char const *"""
    return _repos.svn_repos_lock_dir(*args)

def svn_repos_db_lockfile(*args):
    r"""svn_repos_db_lockfile(svn_repos_t repos, apr_pool_t pool) -> char const *"""
    return _repos.svn_repos_db_lockfile(*args)

def svn_repos_db_logs_lockfile(*args):
    r"""svn_repos_db_logs_lockfile(svn_repos_t repos, apr_pool_t pool) -> char const *"""
    return _repos.svn_repos_db_logs_lockfile(*args)

def svn_repos_hook_dir(*args):
    r"""svn_repos_hook_dir(svn_repos_t repos, apr_pool_t pool) -> char const *"""
    return _repos.svn_repos_hook_dir(*args)

def svn_repos_start_commit_hook(*args):
    r"""svn_repos_start_commit_hook(svn_repos_t repos, apr_pool_t pool) -> char const *"""
    return _repos.svn_repos_start_commit_hook(*args)

def svn_repos_pre_commit_hook(*args):
    r"""svn_repos_pre_commit_hook(svn_repos_t repos, apr_pool_t pool) -> char const *"""
    return _repos.svn_repos_pre_commit_hook(*args)

def svn_repos_post_commit_hook(*args):
    r"""svn_repos_post_commit_hook(svn_repos_t repos, apr_pool_t pool) -> char const *"""
    return _repos.svn_repos_post_commit_hook(*args)

def svn_repos_pre_revprop_change_hook(*args):
    r"""svn_repos_pre_revprop_change_hook(svn_repos_t repos, apr_pool_t pool) -> char const *"""
    return _repos.svn_repos_pre_revprop_change_hook(*args)

def svn_repos_post_revprop_change_hook(*args):
    r"""svn_repos_post_revprop_change_hook(svn_repos_t repos, apr_pool_t pool) -> char const *"""
    return _repos.svn_repos_post_revprop_change_hook(*args)

def svn_repos_pre_lock_hook(*args):
    r"""svn_repos_pre_lock_hook(svn_repos_t repos, apr_pool_t pool) -> char const *"""
    return _repos.svn_repos_pre_lock_hook(*args)

def svn_repos_post_lock_hook(*args):
    r"""svn_repos_post_lock_hook(svn_repos_t repos, apr_pool_t pool) -> char const *"""
    return _repos.svn_repos_post_lock_hook(*args)

def svn_repos_pre_unlock_hook(*args):
    r"""svn_repos_pre_unlock_hook(svn_repos_t repos, apr_pool_t pool) -> char const *"""
    return _repos.svn_repos_pre_unlock_hook(*args)

def svn_repos_post_unlock_hook(*args):
    r"""svn_repos_post_unlock_hook(svn_repos_t repos, apr_pool_t pool) -> char const *"""
    return _repos.svn_repos_post_unlock_hook(*args)

def svn_repos_hooks_setenv(*args):
    r"""svn_repos_hooks_setenv(svn_repos_t repos, char const * hooks_env_path, apr_pool_t scratch_pool) -> svn_error_t"""
    return _repos.svn_repos_hooks_setenv(*args)

def svn_repos_begin_report3(*args):
    r"""svn_repos_begin_report3(svn_revnum_t revnum, svn_repos_t repos, char const * fs_base, char const * target, char const * tgt_path, svn_boolean_t text_deltas, svn_depth_t depth, svn_boolean_t ignore_ancestry, svn_boolean_t send_copyfrom_args, svn_delta_editor_t editor, void * edit_baton, svn_repos_authz_func_t authz_read_func, apr_size_t zero_copy_limit, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_begin_report3(*args)

def svn_repos_begin_report2(*args):
    r"""svn_repos_begin_report2(svn_revnum_t revnum, svn_repos_t repos, char const * fs_base, char const * target, char const * tgt_path, svn_boolean_t text_deltas, svn_depth_t depth, svn_boolean_t ignore_ancestry, svn_boolean_t send_copyfrom_args, svn_delta_editor_t editor, void * edit_baton, svn_repos_authz_func_t authz_read_func, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_begin_report2(*args)

def svn_repos_begin_report(*args):
    r"""svn_repos_begin_report(svn_revnum_t revnum, char const * username, svn_repos_t repos, char const * fs_base, char const * target, char const * tgt_path, svn_boolean_t text_deltas, svn_boolean_t recurse, svn_boolean_t ignore_ancestry, svn_delta_editor_t editor, void * edit_baton, svn_repos_authz_func_t authz_read_func, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_begin_report(*args)

def svn_repos_set_path3(*args):
    r"""svn_repos_set_path3(void * report_baton, char const * path, svn_revnum_t revision, svn_depth_t depth, svn_boolean_t start_empty, char const * lock_token, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_set_path3(*args)

def svn_repos_set_path2(*args):
    r"""svn_repos_set_path2(void * report_baton, char const * path, svn_revnum_t revision, svn_boolean_t start_empty, char const * lock_token, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_set_path2(*args)

def svn_repos_set_path(*args):
    r"""svn_repos_set_path(void * report_baton, char const * path, svn_revnum_t revision, svn_boolean_t start_empty, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_set_path(*args)

def svn_repos_link_path3(*args):
    r"""svn_repos_link_path3(void * report_baton, char const * path, char const * link_path, svn_revnum_t revision, svn_depth_t depth, svn_boolean_t start_empty, char const * lock_token, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_link_path3(*args)

def svn_repos_link_path2(*args):
    r"""svn_repos_link_path2(void * report_baton, char const * path, char const * link_path, svn_revnum_t revision, svn_boolean_t start_empty, char const * lock_token, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_link_path2(*args)

def svn_repos_link_path(*args):
    r"""svn_repos_link_path(void * report_baton, char const * path, char const * link_path, svn_revnum_t revision, svn_boolean_t start_empty, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_link_path(*args)

def svn_repos_delete_path(*args):
    r"""svn_repos_delete_path(void * report_baton, char const * path, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_delete_path(*args)

def svn_repos_finish_report(*args):
    r"""svn_repos_finish_report(void * report_baton, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_finish_report(*args)

def svn_repos_abort_report(*args):
    r"""svn_repos_abort_report(void * report_baton, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_abort_report(*args)

def svn_repos_dir_delta2(*args):
    r"""svn_repos_dir_delta2(svn_fs_root_t src_root, char const * src_parent_dir, char const * src_entry, svn_fs_root_t tgt_root, char const * tgt_path, svn_delta_editor_t editor, void * edit_baton, svn_repos_authz_func_t authz_read_func, svn_boolean_t text_deltas, svn_depth_t depth, svn_boolean_t entry_props, svn_boolean_t ignore_ancestry, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_dir_delta2(*args)

def svn_repos_dir_delta(*args):
    r"""svn_repos_dir_delta(svn_fs_root_t src_root, char const * src_parent_dir, char const * src_entry, svn_fs_root_t tgt_root, char const * tgt_path, svn_delta_editor_t editor, void * edit_baton, svn_repos_authz_func_t authz_read_func, svn_boolean_t text_deltas, svn_boolean_t recurse, svn_boolean_t entry_props, svn_boolean_t ignore_ancestry, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_dir_delta(*args)

def svn_repos_replay2(*args):
    r"""svn_repos_replay2(svn_fs_root_t root, char const * base_dir, svn_revnum_t low_water_mark, svn_boolean_t send_deltas, svn_delta_editor_t editor, void * edit_baton, svn_repos_authz_func_t authz_read_func, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_replay2(*args)

def svn_repos_replay(*args):
    r"""svn_repos_replay(svn_fs_root_t root, svn_delta_editor_t editor, void * edit_baton, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_replay(*args)

def svn_repos_get_commit_editor5(*args):
    r"""svn_repos_get_commit_editor5(svn_repos_t repos, svn_fs_txn_t txn, char const * repos_url_decoded, char const * base_path, apr_hash_t revprop_table, svn_commit_callback2_t commit_callback, svn_repos_authz_callback_t authz_callback, void * authz_baton, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_get_commit_editor5(*args)

def svn_repos_get_commit_editor4(*args):
    r"""svn_repos_get_commit_editor4(svn_repos_t repos, svn_fs_txn_t txn, char const * repos_url, char const * base_path, char const * user, char const * log_msg, svn_commit_callback2_t commit_callback, svn_repos_authz_callback_t authz_callback, void * authz_baton, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_get_commit_editor4(*args)

def svn_repos_get_commit_editor3(*args):
    r"""svn_repos_get_commit_editor3(svn_repos_t repos, svn_fs_txn_t txn, char const * repos_url, char const * base_path, char const * user, char const * log_msg, svn_commit_callback_t callback, svn_repos_authz_callback_t authz_callback, void * authz_baton, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_get_commit_editor3(*args)

def svn_repos_get_commit_editor2(*args):
    r"""svn_repos_get_commit_editor2(svn_repos_t repos, svn_fs_txn_t txn, char const * repos_url, char const * base_path, char const * user, char const * log_msg, svn_commit_callback_t callback, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_get_commit_editor2(*args)

def svn_repos_get_commit_editor(*args):
    r"""svn_repos_get_commit_editor(svn_repos_t repos, char const * repos_url, char const * base_path, char const * user, char const * log_msg, svn_commit_callback_t callback, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_get_commit_editor(*args)

def svn_repos_dated_revision(*args):
    r"""svn_repos_dated_revision(svn_repos_t repos, apr_time_t tm, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_dated_revision(*args)

def svn_repos_get_committed_info(*args):
    r"""svn_repos_get_committed_info(svn_fs_root_t root, char const * path, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_get_committed_info(*args)

def svn_repos_stat(*args):
    r"""svn_repos_stat(svn_fs_root_t root, char const * path, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_stat(*args)

def svn_repos_list(*args):
    r"""svn_repos_list(svn_fs_root_t root, char const * path, apr_array_header_t patterns, svn_depth_t depth, svn_boolean_t path_info_only, svn_repos_authz_func_t authz_read_func, svn_repos_dirent_receiver_t receiver, void * receiver_baton, svn_cancel_func_t cancel_func, apr_pool_t scratch_pool) -> svn_error_t"""
    return _repos.svn_repos_list(*args)

def svn_repos_deleted_rev(*args):
    r"""svn_repos_deleted_rev(svn_fs_t fs, char const * path, svn_revnum_t start, svn_revnum_t end, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_deleted_rev(*args)

def svn_repos_history2(*args):
    r"""svn_repos_history2(svn_fs_t fs, char const * path, svn_repos_history_func_t history_func, svn_repos_authz_func_t authz_read_func, svn_revnum_t start, svn_revnum_t end, svn_boolean_t cross_copies, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_history2(*args)

def svn_repos_history(*args):
    r"""svn_repos_history(svn_fs_t fs, char const * path, svn_repos_history_func_t history_func, svn_revnum_t start, svn_revnum_t end, svn_boolean_t cross_copies, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_history(*args)

def svn_repos_trace_node_locations(*args):
    r"""svn_repos_trace_node_locations(svn_fs_t fs, char const * fs_path, svn_revnum_t peg_revision, apr_array_header_t location_revisions, svn_repos_authz_func_t authz_read_func, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_trace_node_locations(*args)

def svn_repos_node_location_segments(*args):
    r"""svn_repos_node_location_segments(svn_repos_t repos, char const * path, svn_revnum_t peg_revision, svn_revnum_t start_rev, svn_revnum_t end_rev, svn_location_segment_receiver_t receiver, svn_repos_authz_func_t authz_read_func, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_node_location_segments(*args)

def svn_repos_path_change_create(*args):
    r"""svn_repos_path_change_create(apr_pool_t result_pool) -> svn_fs_path_change3_t"""
    return _repos.svn_repos_path_change_create(*args)

def svn_repos_path_change_dup(*args):
    r"""svn_repos_path_change_dup(svn_fs_path_change3_t change, apr_pool_t result_pool) -> svn_fs_path_change3_t"""
    return _repos.svn_repos_path_change_dup(*args)
class svn_repos_log_entry_t(object):
    r"""Proxy of C svn_repos_log_entry_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    revision = property(_repos.svn_repos_log_entry_t_revision_get, _repos.svn_repos_log_entry_t_revision_set, doc=r"""revision : svn_revnum_t""")
    revprops = property(_repos.svn_repos_log_entry_t_revprops_get, _repos.svn_repos_log_entry_t_revprops_set, doc=r"""revprops : p.apr_hash_t""")
    has_children = property(_repos.svn_repos_log_entry_t_has_children_get, _repos.svn_repos_log_entry_t_has_children_set, doc=r"""has_children : svn_boolean_t""")
    non_inheritable = property(_repos.svn_repos_log_entry_t_non_inheritable_get, _repos.svn_repos_log_entry_t_non_inheritable_set, doc=r"""non_inheritable : svn_boolean_t""")
    subtractive_merge = property(_repos.svn_repos_log_entry_t_subtractive_merge_get, _repos.svn_repos_log_entry_t_subtractive_merge_set, doc=r"""subtractive_merge : svn_boolean_t""")
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


# Register svn_repos_log_entry_t in _repos:
_repos.svn_repos_log_entry_t_swigregister(svn_repos_log_entry_t)

def svn_repos_log_entry_create(*args):
    r"""svn_repos_log_entry_create(apr_pool_t result_pool) -> svn_repos_log_entry_t"""
    return _repos.svn_repos_log_entry_create(*args)

def svn_repos_log_entry_dup(*args):
    r"""svn_repos_log_entry_dup(svn_repos_log_entry_t log_entry, apr_pool_t result_pool) -> svn_repos_log_entry_t"""
    return _repos.svn_repos_log_entry_dup(*args)

def svn_repos_get_logs5(*args):
    r"""svn_repos_get_logs5(svn_repos_t repos, apr_array_header_t paths, svn_revnum_t start, svn_revnum_t end, int limit, svn_boolean_t strict_node_history, svn_boolean_t include_merged_revisions, apr_array_header_t revprops, svn_repos_authz_func_t authz_read_func, svn_repos_path_change_receiver_t path_change_receiver, void * path_change_receiver_baton, svn_repos_log_entry_receiver_t revision_receiver, void * revision_receiver_baton, apr_pool_t scratch_pool) -> svn_error_t"""
    return _repos.svn_repos_get_logs5(*args)

def svn_repos_get_logs4(*args):
    r"""svn_repos_get_logs4(svn_repos_t repos, apr_array_header_t paths, svn_revnum_t start, svn_revnum_t end, int limit, svn_boolean_t discover_changed_paths, svn_boolean_t strict_node_history, svn_boolean_t include_merged_revisions, apr_array_header_t revprops, svn_repos_authz_func_t authz_read_func, svn_log_entry_receiver_t receiver, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_get_logs4(*args)

def svn_repos_get_logs3(*args):
    r"""svn_repos_get_logs3(svn_repos_t repos, apr_array_header_t paths, svn_revnum_t start, svn_revnum_t end, int limit, svn_boolean_t discover_changed_paths, svn_boolean_t strict_node_history, svn_repos_authz_func_t authz_read_func, svn_log_message_receiver_t receiver, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_get_logs3(*args)

def svn_repos_get_logs2(*args):
    r"""svn_repos_get_logs2(svn_repos_t repos, apr_array_header_t paths, svn_revnum_t start, svn_revnum_t end, svn_boolean_t discover_changed_paths, svn_boolean_t strict_node_history, svn_repos_authz_func_t authz_read_func, svn_log_message_receiver_t receiver, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_get_logs2(*args)

def svn_repos_get_logs(*args):
    r"""svn_repos_get_logs(svn_repos_t repos, apr_array_header_t paths, svn_revnum_t start, svn_revnum_t end, svn_boolean_t discover_changed_paths, svn_boolean_t strict_node_history, svn_log_message_receiver_t receiver, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_get_logs(*args)

def svn_repos_fs_get_mergeinfo2(*args):
    r"""svn_repos_fs_get_mergeinfo2(svn_repos_t repos, apr_array_header_t paths, svn_revnum_t revision, svn_mergeinfo_inheritance_t inherit, svn_boolean_t include_descendants, svn_repos_authz_func_t authz_read_func, svn_repos_mergeinfo_receiver_t receiver, void * receiver_baton, apr_pool_t scratch_pool) -> svn_error_t"""
    return _repos.svn_repos_fs_get_mergeinfo2(*args)

def svn_repos_fs_get_mergeinfo(*args):
    r"""svn_repos_fs_get_mergeinfo(svn_repos_t repos, apr_array_header_t paths, svn_revnum_t revision, svn_mergeinfo_inheritance_t inherit, svn_boolean_t include_descendants, svn_repos_authz_func_t authz_read_func, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_fs_get_mergeinfo(*args)

def svn_repos_get_file_revs2(*args):
    r"""svn_repos_get_file_revs2(svn_repos_t repos, char const * path, svn_revnum_t start, svn_revnum_t end, svn_boolean_t include_merged_revisions, svn_repos_authz_func_t authz_read_func, svn_file_rev_handler_t handler, void * handler_baton, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_get_file_revs2(*args)

def svn_repos_get_file_revs(*args):
    r"""svn_repos_get_file_revs(svn_repos_t repos, char const * path, svn_revnum_t start, svn_revnum_t end, svn_repos_authz_func_t authz_read_func, svn_repos_file_rev_handler_t handler, void * handler_baton, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_get_file_revs(*args)

def svn_repos_fs_commit_txn(*args):
    r"""svn_repos_fs_commit_txn(svn_repos_t repos, svn_fs_txn_t txn, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_fs_commit_txn(*args)

def svn_repos_fs_begin_txn_for_commit2(*args):
    r"""svn_repos_fs_begin_txn_for_commit2(svn_repos_t repos, svn_revnum_t rev, apr_hash_t revprop_table, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_fs_begin_txn_for_commit2(*args)

def svn_repos_fs_begin_txn_for_commit(*args):
    r"""svn_repos_fs_begin_txn_for_commit(svn_repos_t repos, svn_revnum_t rev, char const * author, char const * log_msg, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_fs_begin_txn_for_commit(*args)

def svn_repos_fs_begin_txn_for_update(*args):
    r"""svn_repos_fs_begin_txn_for_update(svn_repos_t repos, svn_revnum_t rev, char const * author, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_fs_begin_txn_for_update(*args)

def svn_repos_fs_lock_many(*args):
    r"""svn_repos_fs_lock_many(svn_repos_t repos, apr_hash_t lock_targets, char const * comment, svn_boolean_t is_dav_comment, apr_time_t expiration_date, svn_boolean_t steal_lock, svn_fs_lock_callback_t lock_callback, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _repos.svn_repos_fs_lock_many(*args)

def svn_repos_fs_lock(*args):
    r"""svn_repos_fs_lock(svn_repos_t repos, char const * path, char const * token, char const * comment, svn_boolean_t is_dav_comment, apr_time_t expiration_date, svn_revnum_t current_rev, svn_boolean_t steal_lock, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_fs_lock(*args)

def svn_repos_fs_unlock_many(*args):
    r"""svn_repos_fs_unlock_many(svn_repos_t repos, apr_hash_t unlock_targets, svn_boolean_t break_lock, svn_fs_lock_callback_t lock_callback, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _repos.svn_repos_fs_unlock_many(*args)

def svn_repos_fs_unlock(*args):
    r"""svn_repos_fs_unlock(svn_repos_t repos, char const * path, char const * token, svn_boolean_t break_lock, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_fs_unlock(*args)

def svn_repos_fs_get_locks2(*args):
    r"""svn_repos_fs_get_locks2(svn_repos_t repos, char const * path, svn_depth_t depth, svn_repos_authz_func_t authz_read_func, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_fs_get_locks2(*args)

def svn_repos_fs_get_locks(*args):
    r"""svn_repos_fs_get_locks(svn_repos_t repos, char const * path, svn_repos_authz_func_t authz_read_func, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_fs_get_locks(*args)

def svn_repos_fs_change_rev_prop4(*args):
    r"""svn_repos_fs_change_rev_prop4(svn_repos_t repos, svn_revnum_t rev, char const * author, char const * name, svn_string_t const *const * old_value_p, svn_string_t const * new_value, svn_boolean_t use_pre_revprop_change_hook, svn_boolean_t use_post_revprop_change_hook, svn_repos_authz_func_t authz_read_func, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_fs_change_rev_prop4(*args)

def svn_repos_fs_change_rev_prop3(*args):
    r"""svn_repos_fs_change_rev_prop3(svn_repos_t repos, svn_revnum_t rev, char const * author, char const * name, svn_string_t const * new_value, svn_boolean_t use_pre_revprop_change_hook, svn_boolean_t use_post_revprop_change_hook, svn_repos_authz_func_t authz_read_func, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_fs_change_rev_prop3(*args)

def svn_repos_fs_change_rev_prop2(*args):
    r"""svn_repos_fs_change_rev_prop2(svn_repos_t repos, svn_revnum_t rev, char const * author, char const * name, svn_string_t const * new_value, svn_repos_authz_func_t authz_read_func, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_fs_change_rev_prop2(*args)

def svn_repos_fs_change_rev_prop(*args):
    r"""svn_repos_fs_change_rev_prop(svn_repos_t repos, svn_revnum_t rev, char const * author, char const * name, svn_string_t const * new_value, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_fs_change_rev_prop(*args)

def svn_repos_fs_revision_prop(*args):
    r"""svn_repos_fs_revision_prop(svn_repos_t repos, svn_revnum_t rev, char const * propname, svn_repos_authz_func_t authz_read_func, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_fs_revision_prop(*args)

def svn_repos_fs_revision_proplist(*args):
    r"""svn_repos_fs_revision_proplist(svn_repos_t repos, svn_revnum_t rev, svn_repos_authz_func_t authz_read_func, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_fs_revision_proplist(*args)

def svn_repos_fs_change_node_prop(*args):
    r"""svn_repos_fs_change_node_prop(svn_fs_root_t root, char const * path, char const * name, svn_string_t const * value, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_fs_change_node_prop(*args)

def svn_repos_fs_get_inherited_props(*args):
    r"""svn_repos_fs_get_inherited_props(svn_fs_root_t root, char const * path, char const * propname, svn_repos_authz_func_t authz_read_func, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _repos.svn_repos_fs_get_inherited_props(*args)

def svn_repos_fs_change_txn_prop(*args):
    r"""svn_repos_fs_change_txn_prop(svn_fs_txn_t txn, char const * name, svn_string_t const * value, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_fs_change_txn_prop(*args)

def svn_repos_fs_change_txn_props(*args):
    r"""svn_repos_fs_change_txn_props(svn_fs_txn_t txn, apr_array_header_t props, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_fs_change_txn_props(*args)
class svn_repos_node_t(object):
    r"""Proxy of C svn_repos_node_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    kind = property(_repos.svn_repos_node_t_kind_get, _repos.svn_repos_node_t_kind_set, doc=r"""kind : svn_node_kind_t""")
    action = property(_repos.svn_repos_node_t_action_get, _repos.svn_repos_node_t_action_set, doc=r"""action : char""")
    text_mod = property(_repos.svn_repos_node_t_text_mod_get, _repos.svn_repos_node_t_text_mod_set, doc=r"""text_mod : svn_boolean_t""")
    prop_mod = property(_repos.svn_repos_node_t_prop_mod_get, _repos.svn_repos_node_t_prop_mod_set, doc=r"""prop_mod : svn_boolean_t""")
    name = property(_repos.svn_repos_node_t_name_get, _repos.svn_repos_node_t_name_set, doc=r"""name : p.q(const).char""")
    copyfrom_rev = property(_repos.svn_repos_node_t_copyfrom_rev_get, _repos.svn_repos_node_t_copyfrom_rev_set, doc=r"""copyfrom_rev : svn_revnum_t""")
    copyfrom_path = property(_repos.svn_repos_node_t_copyfrom_path_get, _repos.svn_repos_node_t_copyfrom_path_set, doc=r"""copyfrom_path : p.q(const).char""")
    sibling = property(_repos.svn_repos_node_t_sibling_get, _repos.svn_repos_node_t_sibling_set, doc=r"""sibling : p.struct svn_repos_node_t""")
    child = property(_repos.svn_repos_node_t_child_get, _repos.svn_repos_node_t_child_set, doc=r"""child : p.struct svn_repos_node_t""")
    parent = property(_repos.svn_repos_node_t_parent_get, _repos.svn_repos_node_t_parent_set, doc=r"""parent : p.struct svn_repos_node_t""")
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


# Register svn_repos_node_t in _repos:
_repos.svn_repos_node_t_swigregister(svn_repos_node_t)

def svn_repos_node_editor(*args):
    r"""svn_repos_node_editor(svn_repos_t repos, svn_fs_root_t base_root, svn_fs_root_t root, apr_pool_t node_pool, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_node_editor(*args)

def svn_repos_node_from_baton(edit_baton):
    r"""svn_repos_node_from_baton(void * edit_baton) -> svn_repos_node_t"""
    return _repos.svn_repos_node_from_baton(edit_baton)

def svn_repos_info_format(*args):
    r"""svn_repos_info_format(svn_repos_t repos, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _repos.svn_repos_info_format(*args)
SVN_REPOS_DUMPFILE_MAGIC_HEADER = _repos.SVN_REPOS_DUMPFILE_MAGIC_HEADER

SVN_REPOS_DUMPFILE_FORMAT_VERSION = _repos.SVN_REPOS_DUMPFILE_FORMAT_VERSION

SVN_REPOS_DUMPFILE_FORMAT_VERSION_DELTAS = _repos.SVN_REPOS_DUMPFILE_FORMAT_VERSION_DELTAS

SVN_REPOS_DUMPFILE_UUID = _repos.SVN_REPOS_DUMPFILE_UUID

SVN_REPOS_DUMPFILE_CONTENT_LENGTH = _repos.SVN_REPOS_DUMPFILE_CONTENT_LENGTH

SVN_REPOS_DUMPFILE_REVISION_NUMBER = _repos.SVN_REPOS_DUMPFILE_REVISION_NUMBER

SVN_REPOS_DUMPFILE_NODE_PATH = _repos.SVN_REPOS_DUMPFILE_NODE_PATH

SVN_REPOS_DUMPFILE_NODE_KIND = _repos.SVN_REPOS_DUMPFILE_NODE_KIND

SVN_REPOS_DUMPFILE_NODE_ACTION = _repos.SVN_REPOS_DUMPFILE_NODE_ACTION

SVN_REPOS_DUMPFILE_NODE_COPYFROM_PATH = _repos.SVN_REPOS_DUMPFILE_NODE_COPYFROM_PATH

SVN_REPOS_DUMPFILE_NODE_COPYFROM_REV = _repos.SVN_REPOS_DUMPFILE_NODE_COPYFROM_REV

SVN_REPOS_DUMPFILE_TEXT_COPY_SOURCE_MD5 = _repos.SVN_REPOS_DUMPFILE_TEXT_COPY_SOURCE_MD5

SVN_REPOS_DUMPFILE_TEXT_COPY_SOURCE_SHA1 = _repos.SVN_REPOS_DUMPFILE_TEXT_COPY_SOURCE_SHA1

SVN_REPOS_DUMPFILE_TEXT_COPY_SOURCE_CHECKSUM = _repos.SVN_REPOS_DUMPFILE_TEXT_COPY_SOURCE_CHECKSUM

SVN_REPOS_DUMPFILE_TEXT_CONTENT_MD5 = _repos.SVN_REPOS_DUMPFILE_TEXT_CONTENT_MD5

SVN_REPOS_DUMPFILE_TEXT_CONTENT_SHA1 = _repos.SVN_REPOS_DUMPFILE_TEXT_CONTENT_SHA1

SVN_REPOS_DUMPFILE_TEXT_CONTENT_CHECKSUM = _repos.SVN_REPOS_DUMPFILE_TEXT_CONTENT_CHECKSUM

SVN_REPOS_DUMPFILE_PROP_CONTENT_LENGTH = _repos.SVN_REPOS_DUMPFILE_PROP_CONTENT_LENGTH

SVN_REPOS_DUMPFILE_TEXT_CONTENT_LENGTH = _repos.SVN_REPOS_DUMPFILE_TEXT_CONTENT_LENGTH

SVN_REPOS_DUMPFILE_PROP_DELTA = _repos.SVN_REPOS_DUMPFILE_PROP_DELTA

SVN_REPOS_DUMPFILE_TEXT_DELTA = _repos.SVN_REPOS_DUMPFILE_TEXT_DELTA

SVN_REPOS_DUMPFILE_TEXT_DELTA_BASE_MD5 = _repos.SVN_REPOS_DUMPFILE_TEXT_DELTA_BASE_MD5

SVN_REPOS_DUMPFILE_TEXT_DELTA_BASE_SHA1 = _repos.SVN_REPOS_DUMPFILE_TEXT_DELTA_BASE_SHA1

SVN_REPOS_DUMPFILE_TEXT_DELTA_BASE_CHECKSUM = _repos.SVN_REPOS_DUMPFILE_TEXT_DELTA_BASE_CHECKSUM

svn_repos_load_uuid_default = _repos.svn_repos_load_uuid_default

svn_repos_load_uuid_ignore = _repos.svn_repos_load_uuid_ignore

svn_repos_load_uuid_force = _repos.svn_repos_load_uuid_force


def svn_repos_verify_fs3(*args):
    r"""svn_repos_verify_fs3(svn_repos_t repos, svn_revnum_t start_rev, svn_revnum_t end_rev, svn_boolean_t check_normalization, svn_boolean_t metadata_only, svn_repos_notify_func_t notify_func, void * notify_baton, svn_repos_verify_callback_t verify_callback, void * verify_baton, svn_cancel_func_t cancel, void * cancel_baton, apr_pool_t scratch_pool) -> svn_error_t"""
    return _repos.svn_repos_verify_fs3(*args)

def svn_repos_verify_fs2(*args):
    r"""svn_repos_verify_fs2(svn_repos_t repos, svn_revnum_t start_rev, svn_revnum_t end_rev, svn_repos_notify_func_t notify_func, void * notify_baton, svn_cancel_func_t cancel, void * cancel_baton, apr_pool_t scratch_pool) -> svn_error_t"""
    return _repos.svn_repos_verify_fs2(*args)

def svn_repos_verify_fs(*args):
    r"""svn_repos_verify_fs(svn_repos_t repos, svn_stream_t feedback_stream, svn_revnum_t start_rev, svn_revnum_t end_rev, svn_cancel_func_t cancel_func, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_verify_fs(*args)

def svn_repos_dump_fs4(*args):
    r"""svn_repos_dump_fs4(svn_repos_t repos, svn_stream_t stream, svn_revnum_t start_rev, svn_revnum_t end_rev, svn_boolean_t incremental, svn_boolean_t use_deltas, svn_boolean_t include_revprops, svn_boolean_t include_changes, svn_repos_notify_func_t notify_func, void * notify_baton, svn_repos_dump_filter_func_t filter_func, void * filter_baton, svn_cancel_func_t cancel_func, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_dump_fs4(*args)

def svn_repos_dump_fs3(*args):
    r"""svn_repos_dump_fs3(svn_repos_t repos, svn_stream_t dumpstream, svn_revnum_t start_rev, svn_revnum_t end_rev, svn_boolean_t incremental, svn_boolean_t use_deltas, svn_repos_notify_func_t notify_func, void * notify_baton, svn_cancel_func_t cancel_func, apr_pool_t scratch_pool) -> svn_error_t"""
    return _repos.svn_repos_dump_fs3(*args)

def svn_repos_dump_fs2(*args):
    r"""svn_repos_dump_fs2(svn_repos_t repos, svn_stream_t dumpstream, svn_stream_t feedback_stream, svn_revnum_t start_rev, svn_revnum_t end_rev, svn_boolean_t incremental, svn_boolean_t use_deltas, svn_cancel_func_t cancel_func, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_dump_fs2(*args)

def svn_repos_dump_fs(*args):
    r"""svn_repos_dump_fs(svn_repos_t repos, svn_stream_t dumpstream, svn_stream_t feedback_stream, svn_revnum_t start_rev, svn_revnum_t end_rev, svn_boolean_t incremental, svn_cancel_func_t cancel_func, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_dump_fs(*args)

def svn_repos_load_fs6(*args):
    r"""svn_repos_load_fs6(svn_repos_t repos, svn_stream_t dumpstream, svn_revnum_t start_rev, svn_revnum_t end_rev, enum svn_repos_load_uuid uuid_action, char const * parent_dir, svn_boolean_t use_pre_commit_hook, svn_boolean_t use_post_commit_hook, svn_boolean_t validate_props, svn_boolean_t ignore_dates, svn_boolean_t normalize_props, svn_repos_notify_func_t notify_func, void * notify_baton, svn_cancel_func_t cancel_func, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_load_fs6(*args)

def svn_repos_load_fs5(*args):
    r"""svn_repos_load_fs5(svn_repos_t repos, svn_stream_t dumpstream, svn_revnum_t start_rev, svn_revnum_t end_rev, enum svn_repos_load_uuid uuid_action, char const * parent_dir, svn_boolean_t use_pre_commit_hook, svn_boolean_t use_post_commit_hook, svn_boolean_t validate_props, svn_boolean_t ignore_dates, svn_repos_notify_func_t notify_func, void * notify_baton, svn_cancel_func_t cancel_func, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_load_fs5(*args)

def svn_repos_load_fs4(*args):
    r"""svn_repos_load_fs4(svn_repos_t repos, svn_stream_t dumpstream, svn_revnum_t start_rev, svn_revnum_t end_rev, enum svn_repos_load_uuid uuid_action, char const * parent_dir, svn_boolean_t use_pre_commit_hook, svn_boolean_t use_post_commit_hook, svn_boolean_t validate_props, svn_repos_notify_func_t notify_func, void * notify_baton, svn_cancel_func_t cancel_func, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_load_fs4(*args)

def svn_repos_load_fs3(*args):
    r"""svn_repos_load_fs3(svn_repos_t repos, svn_stream_t dumpstream, enum svn_repos_load_uuid uuid_action, char const * parent_dir, svn_boolean_t use_pre_commit_hook, svn_boolean_t use_post_commit_hook, svn_boolean_t validate_props, svn_repos_notify_func_t notify_func, void * notify_baton, svn_cancel_func_t cancel_func, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_load_fs3(*args)

def svn_repos_load_fs2(*args):
    r"""svn_repos_load_fs2(svn_repos_t repos, svn_stream_t dumpstream, svn_stream_t feedback_stream, enum svn_repos_load_uuid uuid_action, char const * parent_dir, svn_boolean_t use_pre_commit_hook, svn_boolean_t use_post_commit_hook, svn_cancel_func_t cancel_func, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_load_fs2(*args)

def svn_repos_load_fs(*args):
    r"""svn_repos_load_fs(svn_repos_t repos, svn_stream_t dumpstream, svn_stream_t feedback_stream, enum svn_repos_load_uuid uuid_action, char const * parent_dir, svn_cancel_func_t cancel_func, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_load_fs(*args)

def svn_repos_load_fs_revprops(*args):
    r"""svn_repos_load_fs_revprops(svn_repos_t repos, svn_stream_t dumpstream, svn_revnum_t start_rev, svn_revnum_t end_rev, svn_boolean_t validate_props, svn_boolean_t ignore_dates, svn_boolean_t normalize_props, svn_repos_notify_func_t notify_func, void * notify_baton, svn_cancel_func_t cancel_func, apr_pool_t scratch_pool) -> svn_error_t"""
    return _repos.svn_repos_load_fs_revprops(*args)
class svn_repos_parse_fns3_t(object):
    r"""Proxy of C svn_repos_parse_fns3_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    magic_header_record = property(_repos.svn_repos_parse_fns3_t_magic_header_record_get, _repos.svn_repos_parse_fns3_t_magic_header_record_set, doc=r"""magic_header_record : p.f(int,p.void,p.apr_pool_t).p.svn_error_t""")
    uuid_record = property(_repos.svn_repos_parse_fns3_t_uuid_record_get, _repos.svn_repos_parse_fns3_t_uuid_record_set, doc=r"""uuid_record : p.f(p.q(const).char,p.void,p.apr_pool_t).p.svn_error_t""")
    new_revision_record = property(_repos.svn_repos_parse_fns3_t_new_revision_record_get, _repos.svn_repos_parse_fns3_t_new_revision_record_set, doc=r"""new_revision_record : p.f(p.p.void,p.apr_hash_t,p.void,p.apr_pool_t).p.svn_error_t""")
    new_node_record = property(_repos.svn_repos_parse_fns3_t_new_node_record_get, _repos.svn_repos_parse_fns3_t_new_node_record_set, doc=r"""new_node_record : p.f(p.p.void,p.apr_hash_t,p.void,p.apr_pool_t).p.svn_error_t""")
    set_revision_property = property(_repos.svn_repos_parse_fns3_t_set_revision_property_get, _repos.svn_repos_parse_fns3_t_set_revision_property_set, doc=r"""set_revision_property : p.f(p.void,p.q(const).char,p.q(const).svn_string_t).p.svn_error_t""")
    set_node_property = property(_repos.svn_repos_parse_fns3_t_set_node_property_get, _repos.svn_repos_parse_fns3_t_set_node_property_set, doc=r"""set_node_property : p.f(p.void,p.q(const).char,p.q(const).svn_string_t).p.svn_error_t""")
    delete_node_property = property(_repos.svn_repos_parse_fns3_t_delete_node_property_get, _repos.svn_repos_parse_fns3_t_delete_node_property_set, doc=r"""delete_node_property : p.f(p.void,p.q(const).char).p.svn_error_t""")
    remove_node_props = property(_repos.svn_repos_parse_fns3_t_remove_node_props_get, _repos.svn_repos_parse_fns3_t_remove_node_props_set, doc=r"""remove_node_props : p.f(p.void).p.svn_error_t""")
    set_fulltext = property(_repos.svn_repos_parse_fns3_t_set_fulltext_get, _repos.svn_repos_parse_fns3_t_set_fulltext_set, doc=r"""set_fulltext : p.f(p.p.svn_stream_t,p.void).p.svn_error_t""")
    apply_textdelta = property(_repos.svn_repos_parse_fns3_t_apply_textdelta_get, _repos.svn_repos_parse_fns3_t_apply_textdelta_set, doc=r"""apply_textdelta : p.f(p.svn_txdelta_window_handler_t,p.p.void,p.void).p.svn_error_t""")
    close_node = property(_repos.svn_repos_parse_fns3_t_close_node_get, _repos.svn_repos_parse_fns3_t_close_node_set, doc=r"""close_node : p.f(p.void).p.svn_error_t""")
    close_revision = property(_repos.svn_repos_parse_fns3_t_close_revision_get, _repos.svn_repos_parse_fns3_t_close_revision_set, doc=r"""close_revision : p.f(p.void).p.svn_error_t""")
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def magic_header_record(self, *args):
      return svn_repos_parse_fns3_invoke_magic_header_record(self, *args)


    def uuid_record(self, *args):
      return svn_repos_parse_fns3_invoke_uuid_record(self, *args)


    def new_revision_record(self, *args):
      return svn_repos_parse_fns3_invoke_new_revision_record(self, *args)


    def new_node_record(self, *args):
      return svn_repos_parse_fns3_invoke_new_node_record(self, *args)


    def set_revision_property(self, *args):
      return svn_repos_parse_fns3_invoke_set_revision_property(self, *args)


    def set_node_property(self, *args):
      return svn_repos_parse_fns3_invoke_set_node_property(self, *args)


    def delete_node_property(self, *args):
      return svn_repos_parse_fns3_invoke_delete_node_property(self, *args)


    def remove_node_props(self, *args):
      return svn_repos_parse_fns3_invoke_remove_node_props(self, *args)


    def set_fulltext(self, *args):
      return svn_repos_parse_fns3_invoke_set_fulltext(self, *args)


    def apply_textdelta(self, *args):
      return svn_repos_parse_fns3_invoke_apply_textdelta(self, *args)


    def close_node(self, *args):
      return svn_repos_parse_fns3_invoke_close_node(self, *args)


    def close_revision(self, *args):
      return svn_repos_parse_fns3_invoke_close_revision(self, *args)


# Register svn_repos_parse_fns3_t in _repos:
_repos.svn_repos_parse_fns3_t_swigregister(svn_repos_parse_fns3_t)

def svn_repos_parse_dumpstream3(*args):
    r"""svn_repos_parse_dumpstream3(svn_stream_t stream, svn_repos_parse_fns3_t parse_fns, void * parse_baton, svn_boolean_t deltas_are_text, svn_cancel_func_t cancel_func, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_parse_dumpstream3(*args)

def svn_repos_get_fs_build_parser6(*args):
    r"""svn_repos_get_fs_build_parser6(svn_repos_t repos, svn_revnum_t start_rev, svn_revnum_t end_rev, svn_boolean_t use_history, svn_boolean_t validate_props, enum svn_repos_load_uuid uuid_action, char const * parent_dir, svn_boolean_t use_pre_commit_hook, svn_boolean_t use_post_commit_hook, svn_boolean_t ignore_dates, svn_boolean_t normalize_props, svn_repos_notify_func_t notify_func, void * notify_baton, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_get_fs_build_parser6(*args)

def svn_repos_get_fs_build_parser5(*args):
    r"""svn_repos_get_fs_build_parser5(svn_repos_t repos, svn_revnum_t start_rev, svn_revnum_t end_rev, svn_boolean_t use_history, svn_boolean_t validate_props, enum svn_repos_load_uuid uuid_action, char const * parent_dir, svn_boolean_t use_pre_commit_hook, svn_boolean_t use_post_commit_hook, svn_boolean_t ignore_dates, svn_repos_notify_func_t notify_func, void * notify_baton, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_get_fs_build_parser5(*args)

def svn_repos_get_fs_build_parser4(*args):
    r"""svn_repos_get_fs_build_parser4(svn_repos_t repos, svn_revnum_t start_rev, svn_revnum_t end_rev, svn_boolean_t use_history, svn_boolean_t validate_props, enum svn_repos_load_uuid uuid_action, char const * parent_dir, svn_repos_notify_func_t notify_func, void * notify_baton, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_get_fs_build_parser4(*args)
class svn_repos_parse_fns2_t(object):
    r"""Proxy of C svn_repos_parse_fns2_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    new_revision_record = property(_repos.svn_repos_parse_fns2_t_new_revision_record_get, _repos.svn_repos_parse_fns2_t_new_revision_record_set, doc=r"""new_revision_record : p.f(p.p.void,p.apr_hash_t,p.void,p.apr_pool_t).p.svn_error_t""")
    uuid_record = property(_repos.svn_repos_parse_fns2_t_uuid_record_get, _repos.svn_repos_parse_fns2_t_uuid_record_set, doc=r"""uuid_record : p.f(p.q(const).char,p.void,p.apr_pool_t).p.svn_error_t""")
    new_node_record = property(_repos.svn_repos_parse_fns2_t_new_node_record_get, _repos.svn_repos_parse_fns2_t_new_node_record_set, doc=r"""new_node_record : p.f(p.p.void,p.apr_hash_t,p.void,p.apr_pool_t).p.svn_error_t""")
    set_revision_property = property(_repos.svn_repos_parse_fns2_t_set_revision_property_get, _repos.svn_repos_parse_fns2_t_set_revision_property_set, doc=r"""set_revision_property : p.f(p.void,p.q(const).char,p.q(const).svn_string_t).p.svn_error_t""")
    set_node_property = property(_repos.svn_repos_parse_fns2_t_set_node_property_get, _repos.svn_repos_parse_fns2_t_set_node_property_set, doc=r"""set_node_property : p.f(p.void,p.q(const).char,p.q(const).svn_string_t).p.svn_error_t""")
    delete_node_property = property(_repos.svn_repos_parse_fns2_t_delete_node_property_get, _repos.svn_repos_parse_fns2_t_delete_node_property_set, doc=r"""delete_node_property : p.f(p.void,p.q(const).char).p.svn_error_t""")
    remove_node_props = property(_repos.svn_repos_parse_fns2_t_remove_node_props_get, _repos.svn_repos_parse_fns2_t_remove_node_props_set, doc=r"""remove_node_props : p.f(p.void).p.svn_error_t""")
    set_fulltext = property(_repos.svn_repos_parse_fns2_t_set_fulltext_get, _repos.svn_repos_parse_fns2_t_set_fulltext_set, doc=r"""set_fulltext : p.f(p.p.svn_stream_t,p.void).p.svn_error_t""")
    apply_textdelta = property(_repos.svn_repos_parse_fns2_t_apply_textdelta_get, _repos.svn_repos_parse_fns2_t_apply_textdelta_set, doc=r"""apply_textdelta : p.f(p.svn_txdelta_window_handler_t,p.p.void,p.void).p.svn_error_t""")
    close_node = property(_repos.svn_repos_parse_fns2_t_close_node_get, _repos.svn_repos_parse_fns2_t_close_node_set, doc=r"""close_node : p.f(p.void).p.svn_error_t""")
    close_revision = property(_repos.svn_repos_parse_fns2_t_close_revision_get, _repos.svn_repos_parse_fns2_t_close_revision_set, doc=r"""close_revision : p.f(p.void).p.svn_error_t""")
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def new_revision_record(self, *args):
      return svn_repos_parse_fns2_invoke_new_revision_record(self, *args)


    def uuid_record(self, *args):
      return svn_repos_parse_fns2_invoke_uuid_record(self, *args)


    def new_node_record(self, *args):
      return svn_repos_parse_fns2_invoke_new_node_record(self, *args)


    def set_revision_property(self, *args):
      return svn_repos_parse_fns2_invoke_set_revision_property(self, *args)


    def set_node_property(self, *args):
      return svn_repos_parse_fns2_invoke_set_node_property(self, *args)


    def delete_node_property(self, *args):
      return svn_repos_parse_fns2_invoke_delete_node_property(self, *args)


    def remove_node_props(self, *args):
      return svn_repos_parse_fns2_invoke_remove_node_props(self, *args)


    def set_fulltext(self, *args):
      return svn_repos_parse_fns2_invoke_set_fulltext(self, *args)


    def apply_textdelta(self, *args):
      return svn_repos_parse_fns2_invoke_apply_textdelta(self, *args)


    def close_node(self, *args):
      return svn_repos_parse_fns2_invoke_close_node(self, *args)


    def close_revision(self, *args):
      return svn_repos_parse_fns2_invoke_close_revision(self, *args)


# Register svn_repos_parse_fns2_t in _repos:
_repos.svn_repos_parse_fns2_t_swigregister(svn_repos_parse_fns2_t)
class svn_repos_parser_fns_t(object):
    r"""Proxy of C svn_repos_parse_fns_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    new_revision_record = property(_repos.svn_repos_parser_fns_t_new_revision_record_get, _repos.svn_repos_parser_fns_t_new_revision_record_set, doc=r"""new_revision_record : p.f(p.p.void,p.apr_hash_t,p.void,p.apr_pool_t).p.svn_error_t""")
    uuid_record = property(_repos.svn_repos_parser_fns_t_uuid_record_get, _repos.svn_repos_parser_fns_t_uuid_record_set, doc=r"""uuid_record : p.f(p.q(const).char,p.void,p.apr_pool_t).p.svn_error_t""")
    new_node_record = property(_repos.svn_repos_parser_fns_t_new_node_record_get, _repos.svn_repos_parser_fns_t_new_node_record_set, doc=r"""new_node_record : p.f(p.p.void,p.apr_hash_t,p.void,p.apr_pool_t).p.svn_error_t""")
    set_revision_property = property(_repos.svn_repos_parser_fns_t_set_revision_property_get, _repos.svn_repos_parser_fns_t_set_revision_property_set, doc=r"""set_revision_property : p.f(p.void,p.q(const).char,p.q(const).svn_string_t).p.svn_error_t""")
    set_node_property = property(_repos.svn_repos_parser_fns_t_set_node_property_get, _repos.svn_repos_parser_fns_t_set_node_property_set, doc=r"""set_node_property : p.f(p.void,p.q(const).char,p.q(const).svn_string_t).p.svn_error_t""")
    remove_node_props = property(_repos.svn_repos_parser_fns_t_remove_node_props_get, _repos.svn_repos_parser_fns_t_remove_node_props_set, doc=r"""remove_node_props : p.f(p.void).p.svn_error_t""")
    set_fulltext = property(_repos.svn_repos_parser_fns_t_set_fulltext_get, _repos.svn_repos_parser_fns_t_set_fulltext_set, doc=r"""set_fulltext : p.f(p.p.svn_stream_t,p.void).p.svn_error_t""")
    close_node = property(_repos.svn_repos_parser_fns_t_close_node_get, _repos.svn_repos_parser_fns_t_close_node_set, doc=r"""close_node : p.f(p.void).p.svn_error_t""")
    close_revision = property(_repos.svn_repos_parser_fns_t_close_revision_get, _repos.svn_repos_parser_fns_t_close_revision_set, doc=r"""close_revision : p.f(p.void).p.svn_error_t""")
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


# Register svn_repos_parser_fns_t in _repos:
_repos.svn_repos_parser_fns_t_swigregister(svn_repos_parser_fns_t)

def svn_repos_parse_dumpstream2(*args):
    r"""svn_repos_parse_dumpstream2(svn_stream_t stream, svn_repos_parse_fns2_t parse_fns, void * parse_baton, svn_cancel_func_t cancel_func, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_parse_dumpstream2(*args)

def svn_repos_parse_dumpstream(*args):
    r"""svn_repos_parse_dumpstream(svn_stream_t stream, svn_repos_parser_fns_t parse_fns, void * parse_baton, svn_cancel_func_t cancel_func, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_parse_dumpstream(*args)

def svn_repos_get_fs_build_parser3(*args):
    r"""svn_repos_get_fs_build_parser3(svn_repos_t repos, svn_boolean_t use_history, svn_boolean_t validate_props, enum svn_repos_load_uuid uuid_action, char const * parent_dir, svn_repos_notify_func_t notify_func, void * notify_baton, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_get_fs_build_parser3(*args)

def svn_repos_get_fs_build_parser2(*args):
    r"""svn_repos_get_fs_build_parser2(svn_repos_t repos, svn_boolean_t use_history, enum svn_repos_load_uuid uuid_action, svn_stream_t outstream, char const * parent_dir, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_get_fs_build_parser2(*args)

def svn_repos_get_fs_build_parser(*args):
    r"""svn_repos_get_fs_build_parser(svn_repos_t repos, svn_boolean_t use_history, enum svn_repos_load_uuid uuid_action, svn_stream_t outstream, char const * parent_dir, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_get_fs_build_parser(*args)

def svn_repos_authz_initialize(*args):
    r"""svn_repos_authz_initialize(apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_authz_initialize(*args)

def svn_repos_authz_read4(*args):
    r"""svn_repos_authz_read4(char const * path, char const * groups_path, svn_boolean_t must_exist, svn_repos_t repos_hint, svn_repos_authz_warning_func_t warning_func, void * warning_baton, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _repos.svn_repos_authz_read4(*args)

def svn_repos_authz_read3(*args):
    r"""svn_repos_authz_read3(char const * path, char const * groups_path, svn_boolean_t must_exist, svn_repos_t repos_hint, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _repos.svn_repos_authz_read3(*args)

def svn_repos_authz_read2(*args):
    r"""svn_repos_authz_read2(char const * path, char const * groups_path, svn_boolean_t must_exist, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_authz_read2(*args)

def svn_repos_authz_read(*args):
    r"""svn_repos_authz_read(char const * file, svn_boolean_t must_exist, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_authz_read(*args)

def svn_repos_authz_parse2(*args):
    r"""svn_repos_authz_parse2(svn_stream_t stream, svn_stream_t groups_stream, svn_repos_authz_warning_func_t warning_func, void * warning_baton, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _repos.svn_repos_authz_parse2(*args)

def svn_repos_authz_parse(*args):
    r"""svn_repos_authz_parse(svn_stream_t stream, svn_stream_t groups_stream, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_authz_parse(*args)

def svn_repos_authz_check_access(*args):
    r"""svn_repos_authz_check_access(svn_authz_t authz, char const * repos_name, char const * path, char const * user, svn_repos_authz_access_t required_access, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_authz_check_access(*args)
svn_repos_revision_access_none = _repos.svn_repos_revision_access_none

svn_repos_revision_access_partial = _repos.svn_repos_revision_access_partial

svn_repos_revision_access_full = _repos.svn_repos_revision_access_full


def svn_repos_check_revision_access(*args):
    r"""svn_repos_check_revision_access(svn_repos_revision_access_level_t * access_level, svn_repos_t repos, svn_revnum_t revision, svn_repos_authz_func_t authz_read_func, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_check_revision_access(*args)
class svn_repos_t(object):
    r"""Proxy of C svn_repos_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


# Register svn_repos_t in _repos:
_repos.svn_repos_t_swigregister(svn_repos_t)
class svn_authz_t(object):
    r"""Proxy of C svn_authz_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


# Register svn_authz_t in _repos:
_repos.svn_authz_t_swigregister(svn_authz_t)

def svn_repos_parse_fns3_invoke_magic_header_record(*args):
    r"""svn_repos_parse_fns3_invoke_magic_header_record(svn_repos_parse_fns3_t _obj, int version, void * parse_baton, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_parse_fns3_invoke_magic_header_record(*args)

def svn_repos_parse_fns3_invoke_uuid_record(*args):
    r"""svn_repos_parse_fns3_invoke_uuid_record(svn_repos_parse_fns3_t _obj, char const * uuid, void * parse_baton, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_parse_fns3_invoke_uuid_record(*args)

def svn_repos_parse_fns3_invoke_new_revision_record(*args):
    r"""svn_repos_parse_fns3_invoke_new_revision_record(svn_repos_parse_fns3_t _obj, apr_hash_t headers, void * parse_baton, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_parse_fns3_invoke_new_revision_record(*args)

def svn_repos_parse_fns3_invoke_new_node_record(*args):
    r"""svn_repos_parse_fns3_invoke_new_node_record(svn_repos_parse_fns3_t _obj, apr_hash_t headers, void * revision_baton, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_parse_fns3_invoke_new_node_record(*args)

def svn_repos_parse_fns3_invoke_set_revision_property(_obj, revision_baton, name, value):
    r"""svn_repos_parse_fns3_invoke_set_revision_property(svn_repos_parse_fns3_t _obj, void * revision_baton, char const * name, svn_string_t const * value) -> svn_error_t"""
    return _repos.svn_repos_parse_fns3_invoke_set_revision_property(_obj, revision_baton, name, value)

def svn_repos_parse_fns3_invoke_set_node_property(_obj, node_baton, name, value):
    r"""svn_repos_parse_fns3_invoke_set_node_property(svn_repos_parse_fns3_t _obj, void * node_baton, char const * name, svn_string_t const * value) -> svn_error_t"""
    return _repos.svn_repos_parse_fns3_invoke_set_node_property(_obj, node_baton, name, value)

def svn_repos_parse_fns3_invoke_delete_node_property(_obj, node_baton, name):
    r"""svn_repos_parse_fns3_invoke_delete_node_property(svn_repos_parse_fns3_t _obj, void * node_baton, char const * name) -> svn_error_t"""
    return _repos.svn_repos_parse_fns3_invoke_delete_node_property(_obj, node_baton, name)

def svn_repos_parse_fns3_invoke_remove_node_props(_obj, node_baton):
    r"""svn_repos_parse_fns3_invoke_remove_node_props(svn_repos_parse_fns3_t _obj, void * node_baton) -> svn_error_t"""
    return _repos.svn_repos_parse_fns3_invoke_remove_node_props(_obj, node_baton)

def svn_repos_parse_fns3_invoke_set_fulltext(_obj, node_baton):
    r"""svn_repos_parse_fns3_invoke_set_fulltext(svn_repos_parse_fns3_t _obj, void * node_baton) -> svn_error_t"""
    return _repos.svn_repos_parse_fns3_invoke_set_fulltext(_obj, node_baton)

def svn_repos_parse_fns3_invoke_apply_textdelta(_obj, node_baton):
    r"""svn_repos_parse_fns3_invoke_apply_textdelta(svn_repos_parse_fns3_t _obj, void * node_baton) -> svn_error_t"""
    return _repos.svn_repos_parse_fns3_invoke_apply_textdelta(_obj, node_baton)

def svn_repos_parse_fns3_invoke_close_node(_obj, node_baton):
    r"""svn_repos_parse_fns3_invoke_close_node(svn_repos_parse_fns3_t _obj, void * node_baton) -> svn_error_t"""
    return _repos.svn_repos_parse_fns3_invoke_close_node(_obj, node_baton)

def svn_repos_parse_fns3_invoke_close_revision(_obj, revision_baton):
    r"""svn_repos_parse_fns3_invoke_close_revision(svn_repos_parse_fns3_t _obj, void * revision_baton) -> svn_error_t"""
    return _repos.svn_repos_parse_fns3_invoke_close_revision(_obj, revision_baton)

def svn_repos_parse_fns2_invoke_new_revision_record(*args):
    r"""svn_repos_parse_fns2_invoke_new_revision_record(svn_repos_parse_fns2_t _obj, apr_hash_t headers, void * parse_baton, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_parse_fns2_invoke_new_revision_record(*args)

def svn_repos_parse_fns2_invoke_uuid_record(*args):
    r"""svn_repos_parse_fns2_invoke_uuid_record(svn_repos_parse_fns2_t _obj, char const * uuid, void * parse_baton, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_parse_fns2_invoke_uuid_record(*args)

def svn_repos_parse_fns2_invoke_new_node_record(*args):
    r"""svn_repos_parse_fns2_invoke_new_node_record(svn_repos_parse_fns2_t _obj, apr_hash_t headers, void * revision_baton, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_parse_fns2_invoke_new_node_record(*args)

def svn_repos_parse_fns2_invoke_set_revision_property(_obj, revision_baton, name, value):
    r"""svn_repos_parse_fns2_invoke_set_revision_property(svn_repos_parse_fns2_t _obj, void * revision_baton, char const * name, svn_string_t const * value) -> svn_error_t"""
    return _repos.svn_repos_parse_fns2_invoke_set_revision_property(_obj, revision_baton, name, value)

def svn_repos_parse_fns2_invoke_set_node_property(_obj, node_baton, name, value):
    r"""svn_repos_parse_fns2_invoke_set_node_property(svn_repos_parse_fns2_t _obj, void * node_baton, char const * name, svn_string_t const * value) -> svn_error_t"""
    return _repos.svn_repos_parse_fns2_invoke_set_node_property(_obj, node_baton, name, value)

def svn_repos_parse_fns2_invoke_delete_node_property(_obj, node_baton, name):
    r"""svn_repos_parse_fns2_invoke_delete_node_property(svn_repos_parse_fns2_t _obj, void * node_baton, char const * name) -> svn_error_t"""
    return _repos.svn_repos_parse_fns2_invoke_delete_node_property(_obj, node_baton, name)

def svn_repos_parse_fns2_invoke_remove_node_props(_obj, node_baton):
    r"""svn_repos_parse_fns2_invoke_remove_node_props(svn_repos_parse_fns2_t _obj, void * node_baton) -> svn_error_t"""
    return _repos.svn_repos_parse_fns2_invoke_remove_node_props(_obj, node_baton)

def svn_repos_parse_fns2_invoke_set_fulltext(_obj, node_baton):
    r"""svn_repos_parse_fns2_invoke_set_fulltext(svn_repos_parse_fns2_t _obj, void * node_baton) -> svn_error_t"""
    return _repos.svn_repos_parse_fns2_invoke_set_fulltext(_obj, node_baton)

def svn_repos_parse_fns2_invoke_apply_textdelta(_obj, node_baton):
    r"""svn_repos_parse_fns2_invoke_apply_textdelta(svn_repos_parse_fns2_t _obj, void * node_baton) -> svn_error_t"""
    return _repos.svn_repos_parse_fns2_invoke_apply_textdelta(_obj, node_baton)

def svn_repos_parse_fns2_invoke_close_node(_obj, node_baton):
    r"""svn_repos_parse_fns2_invoke_close_node(svn_repos_parse_fns2_t _obj, void * node_baton) -> svn_error_t"""
    return _repos.svn_repos_parse_fns2_invoke_close_node(_obj, node_baton)

def svn_repos_parse_fns2_invoke_close_revision(_obj, revision_baton):
    r"""svn_repos_parse_fns2_invoke_close_revision(svn_repos_parse_fns2_t _obj, void * revision_baton) -> svn_error_t"""
    return _repos.svn_repos_parse_fns2_invoke_close_revision(_obj, revision_baton)

def svn_repos_invoke_authz_func(*args):
    r"""svn_repos_invoke_authz_func(svn_repos_authz_func_t _obj, svn_fs_root_t root, char const * path, void * baton, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_invoke_authz_func(*args)

def svn_repos_invoke_authz_callback(*args):
    r"""svn_repos_invoke_authz_callback(svn_repos_authz_callback_t _obj, svn_repos_authz_access_t required, svn_fs_root_t root, char const * path, void * baton, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_invoke_authz_callback(*args)

def svn_repos_invoke_notify_func(*args):
    r"""svn_repos_invoke_notify_func(svn_repos_notify_func_t _obj, void * baton, svn_repos_notify_t notify, apr_pool_t scratch_pool)"""
    return _repos.svn_repos_invoke_notify_func(*args)

def svn_repos_invoke_dump_filter_func(*args):
    r"""svn_repos_invoke_dump_filter_func(svn_repos_dump_filter_func_t _obj, svn_fs_root_t root, char const * path, void * baton, apr_pool_t scratch_pool) -> svn_error_t"""
    return _repos.svn_repos_invoke_dump_filter_func(*args)

def svn_repos_invoke_freeze_func(*args):
    r"""svn_repos_invoke_freeze_func(svn_repos_freeze_func_t _obj, void * baton, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_invoke_freeze_func(*args)

def svn_repos_invoke_history_func(*args):
    r"""svn_repos_invoke_history_func(svn_repos_history_func_t _obj, void * baton, char const * path, svn_revnum_t revision, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_invoke_history_func(*args)

def svn_repos_invoke_path_change_receiver(*args):
    r"""svn_repos_invoke_path_change_receiver(svn_repos_path_change_receiver_t _obj, void * baton, svn_fs_path_change3_t change, apr_pool_t scratch_pool) -> svn_error_t"""
    return _repos.svn_repos_invoke_path_change_receiver(*args)

def svn_repos_invoke_log_entry_receiver(*args):
    r"""svn_repos_invoke_log_entry_receiver(svn_repos_log_entry_receiver_t _obj, void * baton, svn_repos_log_entry_t log_entry, apr_pool_t scratch_pool) -> svn_error_t"""
    return _repos.svn_repos_invoke_log_entry_receiver(*args)

def svn_repos_invoke_file_rev_handler(*args):
    r"""svn_repos_invoke_file_rev_handler(svn_repos_file_rev_handler_t _obj, void * baton, char const * path, svn_revnum_t rev, apr_hash_t rev_props, apr_array_header_t prop_diffs, apr_pool_t pool) -> svn_error_t"""
    return _repos.svn_repos_invoke_file_rev_handler(*args)

def svn_repos_invoke_verify_callback(*args):
    r"""svn_repos_invoke_verify_callback(svn_repos_verify_callback_t _obj, void * baton, svn_revnum_t revision, svn_error_t verify_err, apr_pool_t scratch_pool) -> svn_error_t"""
    return _repos.svn_repos_invoke_verify_callback(*args)

def svn_repos_invoke_authz_warning_func(*args):
    r"""svn_repos_invoke_authz_warning_func(svn_repos_authz_warning_func_t _obj, void * baton, svn_error_t error, apr_pool_t scratch_pool)"""
    return _repos.svn_repos_invoke_authz_warning_func(*args)
class svn_repos_authz_func_t(object):
    r"""Proxy of C svn_repos_authz_func_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_repos_invoke_authz_func(self, *args)


# Register svn_repos_authz_func_t in _repos:
_repos.svn_repos_authz_func_t_swigregister(svn_repos_authz_func_t)
class svn_repos_authz_callback_t(object):
    r"""Proxy of C svn_repos_authz_callback_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_repos_invoke_authz_callback(self, *args)


# Register svn_repos_authz_callback_t in _repos:
_repos.svn_repos_authz_callback_t_swigregister(svn_repos_authz_callback_t)
class svn_repos_notify_func_t(object):
    r"""Proxy of C svn_repos_notify_func_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_repos_invoke_notify_func(self, *args)


# Register svn_repos_notify_func_t in _repos:
_repos.svn_repos_notify_func_t_swigregister(svn_repos_notify_func_t)
class svn_repos_dump_filter_func_t(object):
    r"""Proxy of C svn_repos_dump_filter_func_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_repos_invoke_dump_filter_func(self, *args)


# Register svn_repos_dump_filter_func_t in _repos:
_repos.svn_repos_dump_filter_func_t_swigregister(svn_repos_dump_filter_func_t)
class svn_repos_freeze_func_t(object):
    r"""Proxy of C svn_repos_freeze_func_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_repos_invoke_freeze_func(self, *args)


# Register svn_repos_freeze_func_t in _repos:
_repos.svn_repos_freeze_func_t_swigregister(svn_repos_freeze_func_t)
class svn_repos_history_func_t(object):
    r"""Proxy of C svn_repos_history_func_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_repos_invoke_history_func(self, *args)


# Register svn_repos_history_func_t in _repos:
_repos.svn_repos_history_func_t_swigregister(svn_repos_history_func_t)
class svn_repos_path_change_receiver_t(object):
    r"""Proxy of C svn_repos_path_change_receiver_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_repos_invoke_path_change_receiver(self, *args)


# Register svn_repos_path_change_receiver_t in _repos:
_repos.svn_repos_path_change_receiver_t_swigregister(svn_repos_path_change_receiver_t)
class svn_repos_log_entry_receiver_t(object):
    r"""Proxy of C svn_repos_log_entry_receiver_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_repos_invoke_log_entry_receiver(self, *args)


# Register svn_repos_log_entry_receiver_t in _repos:
_repos.svn_repos_log_entry_receiver_t_swigregister(svn_repos_log_entry_receiver_t)
class svn_repos_file_rev_handler_t(object):
    r"""Proxy of C svn_repos_file_rev_handler_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_repos_invoke_file_rev_handler(self, *args)


# Register svn_repos_file_rev_handler_t in _repos:
_repos.svn_repos_file_rev_handler_t_swigregister(svn_repos_file_rev_handler_t)
class svn_repos_verify_callback_t(object):
    r"""Proxy of C svn_repos_verify_callback_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_repos_invoke_verify_callback(self, *args)


# Register svn_repos_verify_callback_t in _repos:
_repos.svn_repos_verify_callback_t_swigregister(svn_repos_verify_callback_t)
class svn_repos_authz_warning_func_t(object):
    r"""Proxy of C svn_repos_authz_warning_func_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_repos_invoke_authz_warning_func(self, *args)


# Register svn_repos_authz_warning_func_t in _repos:
_repos.svn_repos_authz_warning_func_t_swigregister(svn_repos_authz_warning_func_t)


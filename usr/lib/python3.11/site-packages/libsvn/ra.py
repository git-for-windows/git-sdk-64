# This file was automatically generated by SWIG (https://www.swig.org).
# Version 4.1.1
#
# Do not make changes to this file unless you know what you are doing - modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info

def _dll_paths():
    import os
    if hasattr(os, 'add_dll_directory'):  # Python 3.8+ on Windows
        cookies = []
        for path in os.environ.get('PATH', '').split(os.pathsep):
            if path and os.path.isabs(path):
                try:
                    cookie = os.add_dll_directory(path)
                except OSError:
                    continue
                else:
                    cookies.append(cookie)
        return cookies
    else:
        return ()

_dll_paths = _dll_paths()
try:
    from . import _ra
finally:
    _dll_path = None
    for _dll_path in _dll_paths:
        _dll_path.close()
    del _dll_paths, _dll_path


try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "this":
            set(self, name, value)
        elif name == "thisown":
            self.this.own(value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)



def _copy_metadata_deep(value, old_value):
  """Copy all attributes of old_value into value, recursively traversing
  lists and dicts if needed."""
  if value is None or old_value is None or value is old_value: return

  if isinstance(value, dict):
    for k in value:
      _copy_metadata_deep(value[k], old_value[k])
  elif isinstance(value, list):
    for v, old_v in zip(value, old_value):
      _copy_metadata_deep(v, old_v)
  else:
    try:
      value.__dict__.update(old_value.__dict__)
    except AttributeError:
      pass

def _assert_valid_deep(value):
  """Assert value's validity, recursively traversing lists and dicts."""
  if isinstance(value, dict):
    for k in value:
      _assert_valid_deep(value[k])
  elif isinstance(value, list):
    for v in value:
      _assert_valid_deep(v)
# Ensure that the passed in value isn't a type, which could have an
# assert_valid attribute, but it can not be called without an instance.
  elif type(value) != type:
    try:
      fn = value.assert_valid
    except AttributeError:
      pass
    else:
      fn()



  # SWIG classes generated with -classic do not define this variable,
  # so set it to 0 when it doesn't exist
try:
  _newclass
except NameError:
  _newclass = 0

if _newclass:
  def _get_instance_attr(self, name):
    try:
      return object.__getattribute__(self, name)
    except AttributeError:
      return _swig_getattr(self, object.__getattribute__(self, '__class__'),
                           name)
else:
  def _get_instance_attr(self, name):
    return _swig_getattr(self, self.__class__, name)

def _set_instance_attr(self, name, value):
  return _swig_setattr(self, self.__class__, name, value)


import libsvn.core
import libsvn.delta

def svn_ra_version():
    r"""svn_ra_version() -> svn_version_t"""
    return _ra.svn_ra_version()
class svn_ra_reporter3_t(object):
    r"""Proxy of C svn_ra_reporter3_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    set_path = property(_ra.svn_ra_reporter3_t_set_path_get, _ra.svn_ra_reporter3_t_set_path_set, doc=r"""set_path : p.f(p.void,p.q(const).char,svn_revnum_t,svn_depth_t,svn_boolean_t,p.q(const).char,p.apr_pool_t).p.svn_error_t""")
    delete_path = property(_ra.svn_ra_reporter3_t_delete_path_get, _ra.svn_ra_reporter3_t_delete_path_set, doc=r"""delete_path : p.f(p.void,p.q(const).char,p.apr_pool_t).p.svn_error_t""")
    link_path = property(_ra.svn_ra_reporter3_t_link_path_get, _ra.svn_ra_reporter3_t_link_path_set, doc=r"""link_path : p.f(p.void,p.q(const).char,p.q(const).char,svn_revnum_t,svn_depth_t,svn_boolean_t,p.q(const).char,p.apr_pool_t).p.svn_error_t""")
    finish_report = property(_ra.svn_ra_reporter3_t_finish_report_get, _ra.svn_ra_reporter3_t_finish_report_set, doc=r"""finish_report : p.f(p.void,p.apr_pool_t).p.svn_error_t""")
    abort_report = property(_ra.svn_ra_reporter3_t_abort_report_get, _ra.svn_ra_reporter3_t_abort_report_set, doc=r"""abort_report : p.f(p.void,p.apr_pool_t).p.svn_error_t""")
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def set_path(self, *args):
      return svn_ra_reporter3_invoke_set_path(self, *args)


    def delete_path(self, *args):
      return svn_ra_reporter3_invoke_delete_path(self, *args)


    def link_path(self, *args):
      return svn_ra_reporter3_invoke_link_path(self, *args)


    def finish_report(self, *args):
      return svn_ra_reporter3_invoke_finish_report(self, *args)


    def abort_report(self, *args):
      return svn_ra_reporter3_invoke_abort_report(self, *args)


    def __init__(self):
        r"""__init__(svn_ra_reporter3_t self) -> svn_ra_reporter3_t"""
        _ra.svn_ra_reporter3_t_swiginit(self, _ra.new_svn_ra_reporter3_t())
    __swig_destroy__ = _ra.delete_svn_ra_reporter3_t

# Register svn_ra_reporter3_t in _ra:
_ra.svn_ra_reporter3_t_swigregister(svn_ra_reporter3_t)
class svn_ra_reporter2_t(object):
    r"""Proxy of C svn_ra_reporter2_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    set_path = property(_ra.svn_ra_reporter2_t_set_path_get, _ra.svn_ra_reporter2_t_set_path_set, doc=r"""set_path : p.f(p.void,p.q(const).char,svn_revnum_t,svn_boolean_t,p.q(const).char,p.apr_pool_t).p.svn_error_t""")
    delete_path = property(_ra.svn_ra_reporter2_t_delete_path_get, _ra.svn_ra_reporter2_t_delete_path_set, doc=r"""delete_path : p.f(p.void,p.q(const).char,p.apr_pool_t).p.svn_error_t""")
    link_path = property(_ra.svn_ra_reporter2_t_link_path_get, _ra.svn_ra_reporter2_t_link_path_set, doc=r"""link_path : p.f(p.void,p.q(const).char,p.q(const).char,svn_revnum_t,svn_boolean_t,p.q(const).char,p.apr_pool_t).p.svn_error_t""")
    finish_report = property(_ra.svn_ra_reporter2_t_finish_report_get, _ra.svn_ra_reporter2_t_finish_report_set, doc=r"""finish_report : p.f(p.void,p.apr_pool_t).p.svn_error_t""")
    abort_report = property(_ra.svn_ra_reporter2_t_abort_report_get, _ra.svn_ra_reporter2_t_abort_report_set, doc=r"""abort_report : p.f(p.void,p.apr_pool_t).p.svn_error_t""")
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def set_path(self, *args):
      return svn_ra_reporter2_invoke_set_path(self, *args)


    def delete_path(self, *args):
      return svn_ra_reporter2_invoke_delete_path(self, *args)


    def link_path(self, *args):
      return svn_ra_reporter2_invoke_link_path(self, *args)


    def finish_report(self, *args):
      return svn_ra_reporter2_invoke_finish_report(self, *args)


    def abort_report(self, *args):
      return svn_ra_reporter2_invoke_abort_report(self, *args)


    def __init__(self):
        r"""__init__(svn_ra_reporter2_t self) -> svn_ra_reporter2_t"""
        _ra.svn_ra_reporter2_t_swiginit(self, _ra.new_svn_ra_reporter2_t())
    __swig_destroy__ = _ra.delete_svn_ra_reporter2_t

# Register svn_ra_reporter2_t in _ra:
_ra.svn_ra_reporter2_t_swigregister(svn_ra_reporter2_t)
class svn_ra_reporter_t(object):
    r"""Proxy of C svn_ra_reporter_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    set_path = property(_ra.svn_ra_reporter_t_set_path_get, _ra.svn_ra_reporter_t_set_path_set, doc=r"""set_path : p.f(p.void,p.q(const).char,svn_revnum_t,svn_boolean_t,p.apr_pool_t).p.svn_error_t""")
    delete_path = property(_ra.svn_ra_reporter_t_delete_path_get, _ra.svn_ra_reporter_t_delete_path_set, doc=r"""delete_path : p.f(p.void,p.q(const).char,p.apr_pool_t).p.svn_error_t""")
    link_path = property(_ra.svn_ra_reporter_t_link_path_get, _ra.svn_ra_reporter_t_link_path_set, doc=r"""link_path : p.f(p.void,p.q(const).char,p.q(const).char,svn_revnum_t,svn_boolean_t,p.apr_pool_t).p.svn_error_t""")
    finish_report = property(_ra.svn_ra_reporter_t_finish_report_get, _ra.svn_ra_reporter_t_finish_report_set, doc=r"""finish_report : p.f(p.void,p.apr_pool_t).p.svn_error_t""")
    abort_report = property(_ra.svn_ra_reporter_t_abort_report_get, _ra.svn_ra_reporter_t_abort_report_set, doc=r"""abort_report : p.f(p.void,p.apr_pool_t).p.svn_error_t""")
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def set_path(self, *args):
      return svn_ra_reporter_invoke_set_path(self, *args)


    def delete_path(self, *args):
      return svn_ra_reporter_invoke_delete_path(self, *args)


    def link_path(self, *args):
      return svn_ra_reporter_invoke_link_path(self, *args)


    def finish_report(self, *args):
      return svn_ra_reporter_invoke_finish_report(self, *args)


    def abort_report(self, *args):
      return svn_ra_reporter_invoke_abort_report(self, *args)


    def __init__(self):
        r"""__init__(svn_ra_reporter_t self) -> svn_ra_reporter_t"""
        _ra.svn_ra_reporter_t_swiginit(self, _ra.new_svn_ra_reporter_t())
    __swig_destroy__ = _ra.delete_svn_ra_reporter_t

# Register svn_ra_reporter_t in _ra:
_ra.svn_ra_reporter_t_swigregister(svn_ra_reporter_t)
class svn_ra_callbacks2_t(object):
    r"""Proxy of C svn_ra_callbacks2_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    open_tmp_file = property(_ra.svn_ra_callbacks2_t_open_tmp_file_get, _ra.svn_ra_callbacks2_t_open_tmp_file_set, doc=r"""open_tmp_file : p.f(p.p.apr_file_t,p.void,p.apr_pool_t).p.svn_error_t""")
    auth_baton = property(_ra.svn_ra_callbacks2_t_auth_baton_get, _ra.svn_ra_callbacks2_t_auth_baton_set, doc=r"""auth_baton : p.svn_auth_baton_t""")
    get_wc_prop = property(_ra.svn_ra_callbacks2_t_get_wc_prop_get, _ra.svn_ra_callbacks2_t_get_wc_prop_set, doc=r"""get_wc_prop : svn_ra_get_wc_prop_func_t""")
    set_wc_prop = property(_ra.svn_ra_callbacks2_t_set_wc_prop_get, _ra.svn_ra_callbacks2_t_set_wc_prop_set, doc=r"""set_wc_prop : svn_ra_set_wc_prop_func_t""")
    push_wc_prop = property(_ra.svn_ra_callbacks2_t_push_wc_prop_get, _ra.svn_ra_callbacks2_t_push_wc_prop_set, doc=r"""push_wc_prop : svn_ra_push_wc_prop_func_t""")
    invalidate_wc_props = property(_ra.svn_ra_callbacks2_t_invalidate_wc_props_get, _ra.svn_ra_callbacks2_t_invalidate_wc_props_set, doc=r"""invalidate_wc_props : svn_ra_invalidate_wc_props_func_t""")
    progress_func = property(_ra.svn_ra_callbacks2_t_progress_func_get, _ra.svn_ra_callbacks2_t_progress_func_set, doc=r"""progress_func : svn_ra_progress_notify_func_t""")
    progress_baton = property(_ra.svn_ra_callbacks2_t_progress_baton_get, _ra.svn_ra_callbacks2_t_progress_baton_set, doc=r"""progress_baton : p.void""")
    cancel_func = property(_ra.svn_ra_callbacks2_t_cancel_func_get, _ra.svn_ra_callbacks2_t_cancel_func_set, doc=r"""cancel_func : svn_cancel_func_t""")
    get_client_string = property(_ra.svn_ra_callbacks2_t_get_client_string_get, _ra.svn_ra_callbacks2_t_get_client_string_set, doc=r"""get_client_string : svn_ra_get_client_string_func_t""")
    get_wc_contents = property(_ra.svn_ra_callbacks2_t_get_wc_contents_get, _ra.svn_ra_callbacks2_t_get_wc_contents_set, doc=r"""get_wc_contents : svn_ra_get_wc_contents_func_t""")
    check_tunnel_func = property(_ra.svn_ra_callbacks2_t_check_tunnel_func_get, _ra.svn_ra_callbacks2_t_check_tunnel_func_set, doc=r"""check_tunnel_func : svn_ra_check_tunnel_func_t""")
    open_tunnel_func = property(_ra.svn_ra_callbacks2_t_open_tunnel_func_get, _ra.svn_ra_callbacks2_t_open_tunnel_func_set, doc=r"""open_tunnel_func : svn_ra_open_tunnel_func_t""")
    tunnel_baton = property(_ra.svn_ra_callbacks2_t_tunnel_baton_get, _ra.svn_ra_callbacks2_t_tunnel_baton_set, doc=r"""tunnel_baton : p.void""")
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def open_tmp_file(self, *args):
      return svn_ra_callbacks2_invoke_open_tmp_file(self, *args)


    def __init__(self):
        r"""__init__(svn_ra_callbacks2_t self) -> svn_ra_callbacks2_t"""
        _ra.svn_ra_callbacks2_t_swiginit(self, _ra.new_svn_ra_callbacks2_t())
    __swig_destroy__ = _ra.delete_svn_ra_callbacks2_t

# Register svn_ra_callbacks2_t in _ra:
_ra.svn_ra_callbacks2_t_swigregister(svn_ra_callbacks2_t)
class svn_ra_callbacks_t(object):
    r"""Proxy of C svn_ra_callbacks_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    open_tmp_file = property(_ra.svn_ra_callbacks_t_open_tmp_file_get, _ra.svn_ra_callbacks_t_open_tmp_file_set, doc=r"""open_tmp_file : p.f(p.p.apr_file_t,p.void,p.apr_pool_t).p.svn_error_t""")
    auth_baton = property(_ra.svn_ra_callbacks_t_auth_baton_get, _ra.svn_ra_callbacks_t_auth_baton_set, doc=r"""auth_baton : p.svn_auth_baton_t""")
    get_wc_prop = property(_ra.svn_ra_callbacks_t_get_wc_prop_get, _ra.svn_ra_callbacks_t_get_wc_prop_set, doc=r"""get_wc_prop : svn_ra_get_wc_prop_func_t""")
    set_wc_prop = property(_ra.svn_ra_callbacks_t_set_wc_prop_get, _ra.svn_ra_callbacks_t_set_wc_prop_set, doc=r"""set_wc_prop : svn_ra_set_wc_prop_func_t""")
    push_wc_prop = property(_ra.svn_ra_callbacks_t_push_wc_prop_get, _ra.svn_ra_callbacks_t_push_wc_prop_set, doc=r"""push_wc_prop : svn_ra_push_wc_prop_func_t""")
    invalidate_wc_props = property(_ra.svn_ra_callbacks_t_invalidate_wc_props_get, _ra.svn_ra_callbacks_t_invalidate_wc_props_set, doc=r"""invalidate_wc_props : svn_ra_invalidate_wc_props_func_t""")
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def open_tmp_file(self, *args):
      return svn_ra_callbacks_invoke_open_tmp_file(self, *args)


    def __init__(self):
        r"""__init__(svn_ra_callbacks_t self) -> svn_ra_callbacks_t"""
        _ra.svn_ra_callbacks_t_swiginit(self, _ra.new_svn_ra_callbacks_t())
    __swig_destroy__ = _ra.delete_svn_ra_callbacks_t

# Register svn_ra_callbacks_t in _ra:
_ra.svn_ra_callbacks_t_swigregister(svn_ra_callbacks_t)

def svn_ra_initialize(*args):
    r"""svn_ra_initialize(apr_pool_t pool) -> svn_error_t"""
    return _ra.svn_ra_initialize(*args)

def svn_ra_create_callbacks(*args):
    r"""svn_ra_create_callbacks(apr_pool_t pool) -> svn_error_t"""
    return _ra.svn_ra_create_callbacks(*args)

def svn_ra_open5(*args):
    r"""svn_ra_open5(char const * repos_URL, char const * uuid, svn_ra_callbacks2_t callbacks, apr_hash_t config, apr_pool_t pool) -> svn_error_t"""
    return _ra.svn_ra_open5(*args)

def svn_ra_open4(*args):
    r"""svn_ra_open4(char const * repos_URL, char const * uuid, svn_ra_callbacks2_t callbacks, apr_hash_t config, apr_pool_t pool) -> svn_error_t"""
    return _ra.svn_ra_open4(*args)

def svn_ra_open3(*args):
    r"""svn_ra_open3(char const * repos_URL, char const * uuid, svn_ra_callbacks2_t callbacks, apr_hash_t config, apr_pool_t pool) -> svn_error_t"""
    return _ra.svn_ra_open3(*args)

def svn_ra_open2(*args):
    r"""svn_ra_open2(char const * repos_URL, svn_ra_callbacks2_t callbacks, apr_hash_t config, apr_pool_t pool) -> svn_error_t"""
    return _ra.svn_ra_open2(*args)

def svn_ra_open(*args):
    r"""svn_ra_open(char const * repos_URL, svn_ra_callbacks_t callbacks, void * callback_baton, apr_hash_t config, apr_pool_t pool) -> svn_error_t"""
    return _ra.svn_ra_open(*args)

def svn_ra_reparent(*args):
    r"""svn_ra_reparent(svn_ra_session_t ra_session, char const * url, apr_pool_t pool) -> svn_error_t"""
    return _ra.svn_ra_reparent(*args)

def svn_ra_get_session_url(*args):
    r"""svn_ra_get_session_url(svn_ra_session_t ra_session, apr_pool_t pool) -> svn_error_t"""
    return _ra.svn_ra_get_session_url(*args)

def svn_ra_get_path_relative_to_session(*args):
    r"""svn_ra_get_path_relative_to_session(svn_ra_session_t ra_session, char const * url, apr_pool_t pool) -> svn_error_t"""
    return _ra.svn_ra_get_path_relative_to_session(*args)

def svn_ra_get_path_relative_to_root(*args):
    r"""svn_ra_get_path_relative_to_root(svn_ra_session_t ra_session, char const * url, apr_pool_t pool) -> svn_error_t"""
    return _ra.svn_ra_get_path_relative_to_root(*args)

def svn_ra_get_latest_revnum(*args):
    r"""svn_ra_get_latest_revnum(svn_ra_session_t session, apr_pool_t pool) -> svn_error_t"""
    return _ra.svn_ra_get_latest_revnum(*args)

def svn_ra_get_dated_revision(*args):
    r"""svn_ra_get_dated_revision(svn_ra_session_t session, apr_time_t tm, apr_pool_t pool) -> svn_error_t"""
    return _ra.svn_ra_get_dated_revision(*args)

def svn_ra_change_rev_prop2(*args):
    r"""svn_ra_change_rev_prop2(svn_ra_session_t session, svn_revnum_t rev, char const * name, svn_string_t const *const * old_value_p, svn_string_t const * value, apr_pool_t pool) -> svn_error_t"""
    return _ra.svn_ra_change_rev_prop2(*args)

def svn_ra_change_rev_prop(*args):
    r"""svn_ra_change_rev_prop(svn_ra_session_t session, svn_revnum_t rev, char const * name, svn_string_t const * value, apr_pool_t pool) -> svn_error_t"""
    return _ra.svn_ra_change_rev_prop(*args)

def svn_ra_rev_proplist(*args):
    r"""svn_ra_rev_proplist(svn_ra_session_t session, svn_revnum_t rev, apr_pool_t pool) -> svn_error_t"""
    return _ra.svn_ra_rev_proplist(*args)

def svn_ra_rev_prop(*args):
    r"""svn_ra_rev_prop(svn_ra_session_t session, svn_revnum_t rev, char const * name, apr_pool_t pool) -> svn_error_t"""
    return _ra.svn_ra_rev_prop(*args)

def svn_ra_get_commit_editor3(*args):
    r"""svn_ra_get_commit_editor3(svn_ra_session_t session, apr_hash_t revprop_table, svn_commit_callback2_t commit_callback, apr_hash_t lock_tokens, svn_boolean_t keep_locks, apr_pool_t pool) -> svn_error_t"""
    return _ra.svn_ra_get_commit_editor3(*args)

def svn_ra_get_commit_editor2(*args):
    r"""svn_ra_get_commit_editor2(svn_ra_session_t session, char const * log_msg, svn_commit_callback2_t commit_callback, apr_hash_t lock_tokens, svn_boolean_t keep_locks, apr_pool_t pool) -> svn_error_t"""
    return _ra.svn_ra_get_commit_editor2(*args)

def svn_ra_get_commit_editor(*args):
    r"""svn_ra_get_commit_editor(svn_ra_session_t session, char const * log_msg, svn_commit_callback_t callback, apr_hash_t lock_tokens, svn_boolean_t keep_locks, apr_pool_t pool) -> svn_error_t"""
    return _ra.svn_ra_get_commit_editor(*args)

def svn_ra_get_file(*args):
    r"""svn_ra_get_file(svn_ra_session_t session, char const * path, svn_revnum_t revision, svn_stream_t stream, apr_pool_t pool) -> svn_error_t"""
    return _ra.svn_ra_get_file(*args)

def svn_ra_get_dir2(*args):
    r"""svn_ra_get_dir2(svn_ra_session_t session, char const * path, svn_revnum_t revision, apr_uint32_t dirent_fields, apr_pool_t pool) -> svn_error_t"""
    return _ra.svn_ra_get_dir2(*args)

def svn_ra_get_dir(*args):
    r"""svn_ra_get_dir(svn_ra_session_t session, char const * path, svn_revnum_t revision, apr_pool_t pool) -> svn_error_t"""
    return _ra.svn_ra_get_dir(*args)

def svn_ra_list(*args):
    r"""svn_ra_list(svn_ra_session_t session, char const * path, svn_revnum_t revision, apr_array_header_t patterns, svn_depth_t depth, apr_uint32_t dirent_fields, svn_ra_dirent_receiver_t receiver, void * receiver_baton, apr_pool_t scratch_pool) -> svn_error_t"""
    return _ra.svn_ra_list(*args)

def svn_ra_get_mergeinfo(*args):
    r"""svn_ra_get_mergeinfo(svn_ra_session_t session, apr_array_header_t paths, svn_revnum_t revision, svn_mergeinfo_inheritance_t inherit, svn_boolean_t include_descendants, apr_pool_t pool) -> svn_error_t"""
    return _ra.svn_ra_get_mergeinfo(*args)

def svn_ra_do_update3(*args):
    r"""svn_ra_do_update3(svn_ra_session_t session, svn_revnum_t revision_to_update_to, char const * update_target, svn_depth_t depth, svn_boolean_t send_copyfrom_args, svn_boolean_t ignore_ancestry, svn_delta_editor_t update_editor, void * update_baton, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _ra.svn_ra_do_update3(*args)

def svn_ra_do_update2(*args):
    r"""svn_ra_do_update2(svn_ra_session_t session, svn_revnum_t revision_to_update_to, char const * update_target, svn_depth_t depth, svn_boolean_t send_copyfrom_args, svn_delta_editor_t update_editor, void * update_baton, apr_pool_t pool) -> svn_error_t"""
    return _ra.svn_ra_do_update2(*args)

def svn_ra_do_update(*args):
    r"""svn_ra_do_update(svn_ra_session_t session, svn_revnum_t revision_to_update_to, char const * update_target, svn_boolean_t recurse, svn_delta_editor_t update_editor, void * update_baton, apr_pool_t pool) -> svn_error_t"""
    return _ra.svn_ra_do_update(*args)

def svn_ra_do_switch3(*args):
    r"""svn_ra_do_switch3(svn_ra_session_t session, svn_revnum_t revision_to_switch_to, char const * switch_target, svn_depth_t depth, char const * switch_url, svn_boolean_t send_copyfrom_args, svn_boolean_t ignore_ancestry, svn_delta_editor_t switch_editor, void * switch_baton, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _ra.svn_ra_do_switch3(*args)

def svn_ra_do_switch2(*args):
    r"""svn_ra_do_switch2(svn_ra_session_t session, svn_revnum_t revision_to_switch_to, char const * switch_target, svn_depth_t depth, char const * switch_url, svn_delta_editor_t switch_editor, void * switch_baton, apr_pool_t pool) -> svn_error_t"""
    return _ra.svn_ra_do_switch2(*args)

def svn_ra_do_switch(*args):
    r"""svn_ra_do_switch(svn_ra_session_t session, svn_revnum_t revision_to_switch_to, char const * switch_target, svn_boolean_t recurse, char const * switch_url, svn_delta_editor_t switch_editor, void * switch_baton, apr_pool_t pool) -> svn_error_t"""
    return _ra.svn_ra_do_switch(*args)

def svn_ra_do_status2(*args):
    r"""svn_ra_do_status2(svn_ra_session_t session, char const * status_target, svn_revnum_t revision, svn_depth_t depth, svn_delta_editor_t status_editor, void * status_baton, apr_pool_t pool) -> svn_error_t"""
    return _ra.svn_ra_do_status2(*args)

def svn_ra_do_status(*args):
    r"""svn_ra_do_status(svn_ra_session_t session, char const * status_target, svn_revnum_t revision, svn_boolean_t recurse, svn_delta_editor_t status_editor, void * status_baton, apr_pool_t pool) -> svn_error_t"""
    return _ra.svn_ra_do_status(*args)

def svn_ra_do_diff3(*args):
    r"""svn_ra_do_diff3(svn_ra_session_t session, svn_revnum_t revision, char const * diff_target, svn_depth_t depth, svn_boolean_t ignore_ancestry, svn_boolean_t text_deltas, char const * versus_url, svn_delta_editor_t diff_editor, void * diff_baton, apr_pool_t pool) -> svn_error_t"""
    return _ra.svn_ra_do_diff3(*args)

def svn_ra_do_diff2(*args):
    r"""svn_ra_do_diff2(svn_ra_session_t session, svn_revnum_t revision, char const * diff_target, svn_boolean_t recurse, svn_boolean_t ignore_ancestry, svn_boolean_t text_deltas, char const * versus_url, svn_delta_editor_t diff_editor, void * diff_baton, apr_pool_t pool) -> svn_error_t"""
    return _ra.svn_ra_do_diff2(*args)

def svn_ra_do_diff(*args):
    r"""svn_ra_do_diff(svn_ra_session_t session, svn_revnum_t revision, char const * diff_target, svn_boolean_t recurse, svn_boolean_t ignore_ancestry, char const * versus_url, svn_delta_editor_t diff_editor, void * diff_baton, apr_pool_t pool) -> svn_error_t"""
    return _ra.svn_ra_do_diff(*args)

def svn_ra_get_log2(*args):
    r"""svn_ra_get_log2(svn_ra_session_t session, apr_array_header_t paths, svn_revnum_t start, svn_revnum_t end, int limit, svn_boolean_t discover_changed_paths, svn_boolean_t strict_node_history, svn_boolean_t include_merged_revisions, apr_array_header_t revprops, svn_log_entry_receiver_t receiver, apr_pool_t pool) -> svn_error_t"""
    return _ra.svn_ra_get_log2(*args)

def svn_ra_get_log(*args):
    r"""svn_ra_get_log(svn_ra_session_t session, apr_array_header_t paths, svn_revnum_t start, svn_revnum_t end, int limit, svn_boolean_t discover_changed_paths, svn_boolean_t strict_node_history, svn_log_message_receiver_t receiver, apr_pool_t pool) -> svn_error_t"""
    return _ra.svn_ra_get_log(*args)

def svn_ra_check_path(*args):
    r"""svn_ra_check_path(svn_ra_session_t session, char const * path, svn_revnum_t revision, apr_pool_t pool) -> svn_error_t"""
    return _ra.svn_ra_check_path(*args)

def svn_ra_stat(*args):
    r"""svn_ra_stat(svn_ra_session_t session, char const * path, svn_revnum_t revision, apr_pool_t pool) -> svn_error_t"""
    return _ra.svn_ra_stat(*args)

def svn_ra_get_uuid2(*args):
    r"""svn_ra_get_uuid2(svn_ra_session_t session, apr_pool_t pool) -> svn_error_t"""
    return _ra.svn_ra_get_uuid2(*args)

def svn_ra_get_uuid(*args):
    r"""svn_ra_get_uuid(svn_ra_session_t session, apr_pool_t pool) -> svn_error_t"""
    return _ra.svn_ra_get_uuid(*args)

def svn_ra_get_repos_root2(*args):
    r"""svn_ra_get_repos_root2(svn_ra_session_t session, apr_pool_t pool) -> svn_error_t"""
    return _ra.svn_ra_get_repos_root2(*args)

def svn_ra_get_repos_root(*args):
    r"""svn_ra_get_repos_root(svn_ra_session_t session, apr_pool_t pool) -> svn_error_t"""
    return _ra.svn_ra_get_repos_root(*args)

def svn_ra_get_locations(*args):
    r"""svn_ra_get_locations(svn_ra_session_t session, char const * path, svn_revnum_t peg_revision, apr_array_header_t location_revisions, apr_pool_t pool) -> svn_error_t"""
    return _ra.svn_ra_get_locations(*args)

def svn_ra_get_location_segments(*args):
    r"""svn_ra_get_location_segments(svn_ra_session_t session, char const * path, svn_revnum_t peg_revision, svn_revnum_t start_rev, svn_revnum_t end_rev, svn_location_segment_receiver_t receiver, apr_pool_t pool) -> svn_error_t"""
    return _ra.svn_ra_get_location_segments(*args)

def svn_ra_get_file_revs2(*args):
    r"""svn_ra_get_file_revs2(svn_ra_session_t session, char const * path, svn_revnum_t start, svn_revnum_t end, svn_boolean_t include_merged_revisions, svn_file_rev_handler_t handler, void * handler_baton, apr_pool_t pool) -> svn_error_t"""
    return _ra.svn_ra_get_file_revs2(*args)

def svn_ra_get_file_revs(*args):
    r"""svn_ra_get_file_revs(svn_ra_session_t session, char const * path, svn_revnum_t start, svn_revnum_t end, svn_ra_file_rev_handler_t handler, apr_pool_t pool) -> svn_error_t"""
    return _ra.svn_ra_get_file_revs(*args)

def svn_ra_lock(*args):
    r"""svn_ra_lock(svn_ra_session_t session, apr_hash_t path_revs, char const * comment, svn_boolean_t steal_lock, svn_ra_lock_callback_t lock_func, apr_pool_t pool) -> svn_error_t"""
    return _ra.svn_ra_lock(*args)

def svn_ra_unlock(*args):
    r"""svn_ra_unlock(svn_ra_session_t session, apr_hash_t path_tokens, svn_boolean_t break_lock, svn_ra_lock_callback_t lock_func, apr_pool_t pool) -> svn_error_t"""
    return _ra.svn_ra_unlock(*args)

def svn_ra_get_lock(*args):
    r"""svn_ra_get_lock(svn_ra_session_t session, char const * path, apr_pool_t pool) -> svn_error_t"""
    return _ra.svn_ra_get_lock(*args)

def svn_ra_get_locks2(*args):
    r"""svn_ra_get_locks2(svn_ra_session_t session, char const * path, svn_depth_t depth, apr_pool_t pool) -> svn_error_t"""
    return _ra.svn_ra_get_locks2(*args)

def svn_ra_get_locks(*args):
    r"""svn_ra_get_locks(svn_ra_session_t session, char const * path, apr_pool_t pool) -> svn_error_t"""
    return _ra.svn_ra_get_locks(*args)

def svn_ra_replay_range(*args):
    r"""svn_ra_replay_range(svn_ra_session_t session, svn_revnum_t start_revision, svn_revnum_t end_revision, svn_revnum_t low_water_mark, svn_boolean_t send_deltas, svn_ra_replay_revstart_callback_t revstart_func, svn_ra_replay_revfinish_callback_t revfinish_func, void * replay_baton, apr_pool_t pool) -> svn_error_t"""
    return _ra.svn_ra_replay_range(*args)

def svn_ra_replay(*args):
    r"""svn_ra_replay(svn_ra_session_t session, svn_revnum_t revision, svn_revnum_t low_water_mark, svn_boolean_t send_deltas, svn_delta_editor_t editor, void * edit_baton, apr_pool_t pool) -> svn_error_t"""
    return _ra.svn_ra_replay(*args)

def svn_ra_get_deleted_rev(*args):
    r"""svn_ra_get_deleted_rev(svn_ra_session_t session, char const * path, svn_revnum_t peg_revision, svn_revnum_t end_revision, apr_pool_t pool) -> svn_error_t"""
    return _ra.svn_ra_get_deleted_rev(*args)

def svn_ra_get_inherited_props(*args):
    r"""svn_ra_get_inherited_props(svn_ra_session_t session, char const * path, svn_revnum_t revision, apr_pool_t result_pool, apr_pool_t scratch_pool) -> svn_error_t"""
    return _ra.svn_ra_get_inherited_props(*args)

def svn_ra_has_capability(*args):
    r"""svn_ra_has_capability(svn_ra_session_t session, char const * capability, apr_pool_t pool) -> svn_error_t"""
    return _ra.svn_ra_has_capability(*args)
SVN_RA_CAPABILITY_DEPTH = _ra.SVN_RA_CAPABILITY_DEPTH

SVN_RA_CAPABILITY_MERGEINFO = _ra.SVN_RA_CAPABILITY_MERGEINFO

SVN_RA_CAPABILITY_LOG_REVPROPS = _ra.SVN_RA_CAPABILITY_LOG_REVPROPS

SVN_RA_CAPABILITY_PARTIAL_REPLAY = _ra.SVN_RA_CAPABILITY_PARTIAL_REPLAY

SVN_RA_CAPABILITY_COMMIT_REVPROPS = _ra.SVN_RA_CAPABILITY_COMMIT_REVPROPS

SVN_RA_CAPABILITY_ATOMIC_REVPROPS = _ra.SVN_RA_CAPABILITY_ATOMIC_REVPROPS

SVN_RA_CAPABILITY_INHERITED_PROPS = _ra.SVN_RA_CAPABILITY_INHERITED_PROPS

SVN_RA_CAPABILITY_EPHEMERAL_TXNPROPS = _ra.SVN_RA_CAPABILITY_EPHEMERAL_TXNPROPS

SVN_RA_CAPABILITY_GET_FILE_REVS_REVERSE = _ra.SVN_RA_CAPABILITY_GET_FILE_REVS_REVERSE

SVN_RA_CAPABILITY_LIST = _ra.SVN_RA_CAPABILITY_LIST


def svn_ra_print_modules(*args):
    r"""svn_ra_print_modules(svn_stringbuf_t * output, apr_pool_t pool) -> svn_error_t"""
    return _ra.svn_ra_print_modules(*args)

def svn_ra_print_ra_libraries(*args):
    r"""svn_ra_print_ra_libraries(void * ra_baton, apr_pool_t pool) -> svn_error_t"""
    return _ra.svn_ra_print_ra_libraries(*args)
class svn_ra_plugin_t(object):
    r"""Proxy of C svn_ra_plugin_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    name = property(_ra.svn_ra_plugin_t_name_get, _ra.svn_ra_plugin_t_name_set, doc=r"""name : p.q(const).char""")
    description = property(_ra.svn_ra_plugin_t_description_get, _ra.svn_ra_plugin_t_description_set, doc=r"""description : p.q(const).char""")
    open = property(_ra.svn_ra_plugin_t_open_get, _ra.svn_ra_plugin_t_open_set, doc=r"""open : p.f(p.p.void,p.q(const).char,p.q(const).svn_ra_callbacks_t,p.void,p.apr_hash_t,p.apr_pool_t).p.svn_error_t""")
    get_latest_revnum = property(_ra.svn_ra_plugin_t_get_latest_revnum_get, _ra.svn_ra_plugin_t_get_latest_revnum_set, doc=r"""get_latest_revnum : p.f(p.void,p.svn_revnum_t,p.apr_pool_t).p.svn_error_t""")
    get_dated_revision = property(_ra.svn_ra_plugin_t_get_dated_revision_get, _ra.svn_ra_plugin_t_get_dated_revision_set, doc=r"""get_dated_revision : p.f(p.void,p.svn_revnum_t,apr_time_t,p.apr_pool_t).p.svn_error_t""")
    change_rev_prop = property(_ra.svn_ra_plugin_t_change_rev_prop_get, _ra.svn_ra_plugin_t_change_rev_prop_set, doc=r"""change_rev_prop : p.f(p.void,svn_revnum_t,p.q(const).char,p.q(const).svn_string_t,p.apr_pool_t).p.svn_error_t""")
    rev_proplist = property(_ra.svn_ra_plugin_t_rev_proplist_get, _ra.svn_ra_plugin_t_rev_proplist_set, doc=r"""rev_proplist : p.f(p.void,svn_revnum_t,p.p.apr_hash_t,p.apr_pool_t).p.svn_error_t""")
    rev_prop = property(_ra.svn_ra_plugin_t_rev_prop_get, _ra.svn_ra_plugin_t_rev_prop_set, doc=r"""rev_prop : p.f(p.void,svn_revnum_t,p.q(const).char,p.p.svn_string_t,p.apr_pool_t).p.svn_error_t""")
    get_commit_editor = property(_ra.svn_ra_plugin_t_get_commit_editor_get, _ra.svn_ra_plugin_t_get_commit_editor_set, doc=r"""get_commit_editor : p.f(p.void,p.p.q(const).svn_delta_editor_t,p.p.void,p.q(const).char,svn_commit_callback_t,p.void,p.apr_pool_t).p.svn_error_t""")
    get_file = property(_ra.svn_ra_plugin_t_get_file_get, _ra.svn_ra_plugin_t_get_file_set, doc=r"""get_file : p.f(p.void,p.q(const).char,svn_revnum_t,p.svn_stream_t,p.svn_revnum_t,p.p.apr_hash_t,p.apr_pool_t).p.svn_error_t""")
    get_dir = property(_ra.svn_ra_plugin_t_get_dir_get, _ra.svn_ra_plugin_t_get_dir_set, doc=r"""get_dir : p.f(p.void,p.q(const).char,svn_revnum_t,p.p.apr_hash_t,p.svn_revnum_t,p.p.apr_hash_t,p.apr_pool_t).p.svn_error_t""")
    do_update = property(_ra.svn_ra_plugin_t_do_update_get, _ra.svn_ra_plugin_t_do_update_set, doc=r"""do_update : p.f(p.void,p.p.q(const).svn_ra_reporter_t,p.p.void,svn_revnum_t,p.q(const).char,svn_boolean_t,p.q(const).svn_delta_editor_t,p.void,p.apr_pool_t).p.svn_error_t""")
    do_switch = property(_ra.svn_ra_plugin_t_do_switch_get, _ra.svn_ra_plugin_t_do_switch_set, doc=r"""do_switch : p.f(p.void,p.p.q(const).svn_ra_reporter_t,p.p.void,svn_revnum_t,p.q(const).char,svn_boolean_t,p.q(const).char,p.q(const).svn_delta_editor_t,p.void,p.apr_pool_t).p.svn_error_t""")
    do_status = property(_ra.svn_ra_plugin_t_do_status_get, _ra.svn_ra_plugin_t_do_status_set, doc=r"""do_status : p.f(p.void,p.p.q(const).svn_ra_reporter_t,p.p.void,p.q(const).char,svn_revnum_t,svn_boolean_t,p.q(const).svn_delta_editor_t,p.void,p.apr_pool_t).p.svn_error_t""")
    do_diff = property(_ra.svn_ra_plugin_t_do_diff_get, _ra.svn_ra_plugin_t_do_diff_set, doc=r"""do_diff : p.f(p.void,p.p.q(const).svn_ra_reporter_t,p.p.void,svn_revnum_t,p.q(const).char,svn_boolean_t,svn_boolean_t,p.q(const).char,p.q(const).svn_delta_editor_t,p.void,p.apr_pool_t).p.svn_error_t""")
    get_log = property(_ra.svn_ra_plugin_t_get_log_get, _ra.svn_ra_plugin_t_get_log_set, doc=r"""get_log : p.f(p.void,p.q(const).apr_array_header_t,svn_revnum_t,svn_revnum_t,svn_boolean_t,svn_boolean_t,svn_log_message_receiver_t,p.void,p.apr_pool_t).p.svn_error_t""")
    check_path = property(_ra.svn_ra_plugin_t_check_path_get, _ra.svn_ra_plugin_t_check_path_set, doc=r"""check_path : p.f(p.void,p.q(const).char,svn_revnum_t,p.svn_node_kind_t,p.apr_pool_t).p.svn_error_t""")
    get_uuid = property(_ra.svn_ra_plugin_t_get_uuid_get, _ra.svn_ra_plugin_t_get_uuid_set, doc=r"""get_uuid : p.f(p.void,p.p.q(const).char,p.apr_pool_t).p.svn_error_t""")
    get_repos_root = property(_ra.svn_ra_plugin_t_get_repos_root_get, _ra.svn_ra_plugin_t_get_repos_root_set, doc=r"""get_repos_root : p.f(p.void,p.p.q(const).char,p.apr_pool_t).p.svn_error_t""")
    get_locations = property(_ra.svn_ra_plugin_t_get_locations_get, _ra.svn_ra_plugin_t_get_locations_set, doc=r"""get_locations : p.f(p.void,p.p.apr_hash_t,p.q(const).char,svn_revnum_t,p.apr_array_header_t,p.apr_pool_t).p.svn_error_t""")
    get_file_revs = property(_ra.svn_ra_plugin_t_get_file_revs_get, _ra.svn_ra_plugin_t_get_file_revs_set, doc=r"""get_file_revs : p.f(p.void,p.q(const).char,svn_revnum_t,svn_revnum_t,svn_ra_file_rev_handler_t,p.void,p.apr_pool_t).p.svn_error_t""")
    get_version = property(_ra.svn_ra_plugin_t_get_version_get, _ra.svn_ra_plugin_t_get_version_set, doc=r"""get_version : p.f(void).p.q(const).svn_version_t""")
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def open(self, *args):
      return svn_ra_plugin_invoke_open(self, *args)


    def get_latest_revnum(self, *args):
      return svn_ra_plugin_invoke_get_latest_revnum(self, *args)


    def get_dated_revision(self, *args):
      return svn_ra_plugin_invoke_get_dated_revision(self, *args)


    def change_rev_prop(self, *args):
      return svn_ra_plugin_invoke_change_rev_prop(self, *args)


    def rev_proplist(self, *args):
      return svn_ra_plugin_invoke_rev_proplist(self, *args)


    def rev_prop(self, *args):
      return svn_ra_plugin_invoke_rev_prop(self, *args)


    def get_commit_editor(self, *args):
      return svn_ra_plugin_invoke_get_commit_editor(self, *args)


    def get_file(self, *args):
      return svn_ra_plugin_invoke_get_file(self, *args)


    def get_dir(self, *args):
      return svn_ra_plugin_invoke_get_dir(self, *args)


    def do_update(self, *args):
      return svn_ra_plugin_invoke_do_update(self, *args)


    def do_switch(self, *args):
      return svn_ra_plugin_invoke_do_switch(self, *args)


    def do_status(self, *args):
      return svn_ra_plugin_invoke_do_status(self, *args)


    def do_diff(self, *args):
      return svn_ra_plugin_invoke_do_diff(self, *args)


    def get_log(self, *args):
      return svn_ra_plugin_invoke_get_log(self, *args)


    def check_path(self, *args):
      return svn_ra_plugin_invoke_check_path(self, *args)


    def get_uuid(self, *args):
      return svn_ra_plugin_invoke_get_uuid(self, *args)


    def get_repos_root(self, *args):
      return svn_ra_plugin_invoke_get_repos_root(self, *args)


    def get_locations(self, *args):
      return svn_ra_plugin_invoke_get_locations(self, *args)


    def get_file_revs(self, *args):
      return svn_ra_plugin_invoke_get_file_revs(self, *args)


    def get_version(self, *args):
      return svn_ra_plugin_invoke_get_version(self, *args)


    def __init__(self):
        r"""__init__(svn_ra_plugin_t self) -> svn_ra_plugin_t"""
        _ra.svn_ra_plugin_t_swiginit(self, _ra.new_svn_ra_plugin_t())
    __swig_destroy__ = _ra.delete_svn_ra_plugin_t

# Register svn_ra_plugin_t in _ra:
_ra.svn_ra_plugin_t_swigregister(svn_ra_plugin_t)
SVN_RA_ABI_VERSION = _ra.SVN_RA_ABI_VERSION


def svn_ra_init_ra_libs(*args):
    r"""svn_ra_init_ra_libs(apr_pool_t pool) -> svn_error_t"""
    return _ra.svn_ra_init_ra_libs(*args)

def svn_ra_get_ra_library(*args):
    r"""svn_ra_get_ra_library(void * ra_baton, char const * url, apr_pool_t pool) -> svn_error_t"""
    return _ra.svn_ra_get_ra_library(*args)
class svn_ra_session_t(object):
    r"""Proxy of C svn_ra_session_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


# Register svn_ra_session_t in _ra:
_ra.svn_ra_session_t_swigregister(svn_ra_session_t)

def svn_ra_reporter3_invoke_set_path(*args):
    r"""svn_ra_reporter3_invoke_set_path(svn_ra_reporter3_t _obj, void * report_baton, char const * path, svn_revnum_t revision, svn_depth_t depth, svn_boolean_t start_empty, char const * lock_token, apr_pool_t pool) -> svn_error_t"""
    return _ra.svn_ra_reporter3_invoke_set_path(*args)

def svn_ra_reporter3_invoke_delete_path(*args):
    r"""svn_ra_reporter3_invoke_delete_path(svn_ra_reporter3_t _obj, void * report_baton, char const * path, apr_pool_t pool) -> svn_error_t"""
    return _ra.svn_ra_reporter3_invoke_delete_path(*args)

def svn_ra_reporter3_invoke_link_path(*args):
    r"""svn_ra_reporter3_invoke_link_path(svn_ra_reporter3_t _obj, void * report_baton, char const * path, char const * url, svn_revnum_t revision, svn_depth_t depth, svn_boolean_t start_empty, char const * lock_token, apr_pool_t pool) -> svn_error_t"""
    return _ra.svn_ra_reporter3_invoke_link_path(*args)

def svn_ra_reporter3_invoke_finish_report(*args):
    r"""svn_ra_reporter3_invoke_finish_report(svn_ra_reporter3_t _obj, void * report_baton, apr_pool_t pool) -> svn_error_t"""
    return _ra.svn_ra_reporter3_invoke_finish_report(*args)

def svn_ra_reporter3_invoke_abort_report(*args):
    r"""svn_ra_reporter3_invoke_abort_report(svn_ra_reporter3_t _obj, void * report_baton, apr_pool_t pool) -> svn_error_t"""
    return _ra.svn_ra_reporter3_invoke_abort_report(*args)

def svn_ra_reporter2_invoke_set_path(*args):
    r"""svn_ra_reporter2_invoke_set_path(svn_ra_reporter2_t _obj, void * report_baton, char const * path, svn_revnum_t revision, svn_boolean_t start_empty, char const * lock_token, apr_pool_t pool) -> svn_error_t"""
    return _ra.svn_ra_reporter2_invoke_set_path(*args)

def svn_ra_reporter2_invoke_delete_path(*args):
    r"""svn_ra_reporter2_invoke_delete_path(svn_ra_reporter2_t _obj, void * report_baton, char const * path, apr_pool_t pool) -> svn_error_t"""
    return _ra.svn_ra_reporter2_invoke_delete_path(*args)

def svn_ra_reporter2_invoke_link_path(*args):
    r"""svn_ra_reporter2_invoke_link_path(svn_ra_reporter2_t _obj, void * report_baton, char const * path, char const * url, svn_revnum_t revision, svn_boolean_t start_empty, char const * lock_token, apr_pool_t pool) -> svn_error_t"""
    return _ra.svn_ra_reporter2_invoke_link_path(*args)

def svn_ra_reporter2_invoke_finish_report(*args):
    r"""svn_ra_reporter2_invoke_finish_report(svn_ra_reporter2_t _obj, void * report_baton, apr_pool_t pool) -> svn_error_t"""
    return _ra.svn_ra_reporter2_invoke_finish_report(*args)

def svn_ra_reporter2_invoke_abort_report(*args):
    r"""svn_ra_reporter2_invoke_abort_report(svn_ra_reporter2_t _obj, void * report_baton, apr_pool_t pool) -> svn_error_t"""
    return _ra.svn_ra_reporter2_invoke_abort_report(*args)

def svn_ra_reporter_invoke_set_path(*args):
    r"""svn_ra_reporter_invoke_set_path(svn_ra_reporter_t _obj, void * report_baton, char const * path, svn_revnum_t revision, svn_boolean_t start_empty, apr_pool_t pool) -> svn_error_t"""
    return _ra.svn_ra_reporter_invoke_set_path(*args)

def svn_ra_reporter_invoke_delete_path(*args):
    r"""svn_ra_reporter_invoke_delete_path(svn_ra_reporter_t _obj, void * report_baton, char const * path, apr_pool_t pool) -> svn_error_t"""
    return _ra.svn_ra_reporter_invoke_delete_path(*args)

def svn_ra_reporter_invoke_link_path(*args):
    r"""svn_ra_reporter_invoke_link_path(svn_ra_reporter_t _obj, void * report_baton, char const * path, char const * url, svn_revnum_t revision, svn_boolean_t start_empty, apr_pool_t pool) -> svn_error_t"""
    return _ra.svn_ra_reporter_invoke_link_path(*args)

def svn_ra_reporter_invoke_finish_report(*args):
    r"""svn_ra_reporter_invoke_finish_report(svn_ra_reporter_t _obj, void * report_baton, apr_pool_t pool) -> svn_error_t"""
    return _ra.svn_ra_reporter_invoke_finish_report(*args)

def svn_ra_reporter_invoke_abort_report(*args):
    r"""svn_ra_reporter_invoke_abort_report(svn_ra_reporter_t _obj, void * report_baton, apr_pool_t pool) -> svn_error_t"""
    return _ra.svn_ra_reporter_invoke_abort_report(*args)

def svn_ra_callbacks2_invoke_open_tmp_file(*args):
    r"""svn_ra_callbacks2_invoke_open_tmp_file(svn_ra_callbacks2_t _obj, void * callback_baton, apr_pool_t pool) -> svn_error_t"""
    return _ra.svn_ra_callbacks2_invoke_open_tmp_file(*args)

def svn_ra_callbacks_invoke_open_tmp_file(*args):
    r"""svn_ra_callbacks_invoke_open_tmp_file(svn_ra_callbacks_t _obj, void * callback_baton, apr_pool_t pool) -> svn_error_t"""
    return _ra.svn_ra_callbacks_invoke_open_tmp_file(*args)

def svn_ra_plugin_invoke_open(*args):
    r"""svn_ra_plugin_invoke_open(svn_ra_plugin_t _obj, char const * repos_URL, svn_ra_callbacks_t callbacks, void * callback_baton, apr_hash_t config, apr_pool_t pool) -> svn_error_t"""
    return _ra.svn_ra_plugin_invoke_open(*args)

def svn_ra_plugin_invoke_get_latest_revnum(*args):
    r"""svn_ra_plugin_invoke_get_latest_revnum(svn_ra_plugin_t _obj, void * session_baton, apr_pool_t pool) -> svn_error_t"""
    return _ra.svn_ra_plugin_invoke_get_latest_revnum(*args)

def svn_ra_plugin_invoke_get_dated_revision(*args):
    r"""svn_ra_plugin_invoke_get_dated_revision(svn_ra_plugin_t _obj, void * session_baton, apr_time_t tm, apr_pool_t pool) -> svn_error_t"""
    return _ra.svn_ra_plugin_invoke_get_dated_revision(*args)

def svn_ra_plugin_invoke_change_rev_prop(*args):
    r"""svn_ra_plugin_invoke_change_rev_prop(svn_ra_plugin_t _obj, void * session_baton, svn_revnum_t rev, char const * name, svn_string_t const * value, apr_pool_t pool) -> svn_error_t"""
    return _ra.svn_ra_plugin_invoke_change_rev_prop(*args)

def svn_ra_plugin_invoke_rev_proplist(*args):
    r"""svn_ra_plugin_invoke_rev_proplist(svn_ra_plugin_t _obj, void * session_baton, svn_revnum_t rev, apr_pool_t pool) -> svn_error_t"""
    return _ra.svn_ra_plugin_invoke_rev_proplist(*args)

def svn_ra_plugin_invoke_rev_prop(*args):
    r"""svn_ra_plugin_invoke_rev_prop(svn_ra_plugin_t _obj, void * session_baton, svn_revnum_t rev, char const * name, apr_pool_t pool) -> svn_error_t"""
    return _ra.svn_ra_plugin_invoke_rev_prop(*args)

def svn_ra_plugin_invoke_get_commit_editor(*args):
    r"""svn_ra_plugin_invoke_get_commit_editor(svn_ra_plugin_t _obj, void * session_baton, char const * log_msg, svn_commit_callback_t callback, apr_pool_t pool) -> svn_error_t"""
    return _ra.svn_ra_plugin_invoke_get_commit_editor(*args)

def svn_ra_plugin_invoke_get_file(*args):
    r"""svn_ra_plugin_invoke_get_file(svn_ra_plugin_t _obj, void * session_baton, char const * path, svn_revnum_t revision, svn_stream_t stream, apr_pool_t pool) -> svn_error_t"""
    return _ra.svn_ra_plugin_invoke_get_file(*args)

def svn_ra_plugin_invoke_get_dir(*args):
    r"""svn_ra_plugin_invoke_get_dir(svn_ra_plugin_t _obj, void * session_baton, char const * path, svn_revnum_t revision, apr_pool_t pool) -> svn_error_t"""
    return _ra.svn_ra_plugin_invoke_get_dir(*args)

def svn_ra_plugin_invoke_do_update(*args):
    r"""svn_ra_plugin_invoke_do_update(svn_ra_plugin_t _obj, void * session_baton, svn_revnum_t revision_to_update_to, char const * update_target, svn_boolean_t recurse, svn_delta_editor_t update_editor, void * update_baton, apr_pool_t pool) -> svn_error_t"""
    return _ra.svn_ra_plugin_invoke_do_update(*args)

def svn_ra_plugin_invoke_do_switch(*args):
    r"""svn_ra_plugin_invoke_do_switch(svn_ra_plugin_t _obj, void * session_baton, svn_revnum_t revision_to_switch_to, char const * switch_target, svn_boolean_t recurse, char const * switch_url, svn_delta_editor_t switch_editor, void * switch_baton, apr_pool_t pool) -> svn_error_t"""
    return _ra.svn_ra_plugin_invoke_do_switch(*args)

def svn_ra_plugin_invoke_do_status(*args):
    r"""svn_ra_plugin_invoke_do_status(svn_ra_plugin_t _obj, void * session_baton, char const * status_target, svn_revnum_t revision, svn_boolean_t recurse, svn_delta_editor_t status_editor, void * status_baton, apr_pool_t pool) -> svn_error_t"""
    return _ra.svn_ra_plugin_invoke_do_status(*args)

def svn_ra_plugin_invoke_do_diff(*args):
    r"""svn_ra_plugin_invoke_do_diff(svn_ra_plugin_t _obj, void * session_baton, svn_revnum_t revision, char const * diff_target, svn_boolean_t recurse, svn_boolean_t ignore_ancestry, char const * versus_url, svn_delta_editor_t diff_editor, void * diff_baton, apr_pool_t pool) -> svn_error_t"""
    return _ra.svn_ra_plugin_invoke_do_diff(*args)

def svn_ra_plugin_invoke_get_log(*args):
    r"""svn_ra_plugin_invoke_get_log(svn_ra_plugin_t _obj, void * session_baton, apr_array_header_t paths, svn_revnum_t start, svn_revnum_t end, svn_boolean_t discover_changed_paths, svn_boolean_t strict_node_history, svn_log_message_receiver_t receiver, apr_pool_t pool) -> svn_error_t"""
    return _ra.svn_ra_plugin_invoke_get_log(*args)

def svn_ra_plugin_invoke_check_path(*args):
    r"""svn_ra_plugin_invoke_check_path(svn_ra_plugin_t _obj, void * session_baton, char const * path, svn_revnum_t revision, apr_pool_t pool) -> svn_error_t"""
    return _ra.svn_ra_plugin_invoke_check_path(*args)

def svn_ra_plugin_invoke_get_uuid(*args):
    r"""svn_ra_plugin_invoke_get_uuid(svn_ra_plugin_t _obj, void * session_baton, apr_pool_t pool) -> svn_error_t"""
    return _ra.svn_ra_plugin_invoke_get_uuid(*args)

def svn_ra_plugin_invoke_get_repos_root(*args):
    r"""svn_ra_plugin_invoke_get_repos_root(svn_ra_plugin_t _obj, void * session_baton, apr_pool_t pool) -> svn_error_t"""
    return _ra.svn_ra_plugin_invoke_get_repos_root(*args)

def svn_ra_plugin_invoke_get_locations(*args):
    r"""svn_ra_plugin_invoke_get_locations(svn_ra_plugin_t _obj, void * session_baton, char const * path, svn_revnum_t peg_revision, apr_array_header_t location_revisions, apr_pool_t pool) -> svn_error_t"""
    return _ra.svn_ra_plugin_invoke_get_locations(*args)

def svn_ra_plugin_invoke_get_file_revs(*args):
    r"""svn_ra_plugin_invoke_get_file_revs(svn_ra_plugin_t _obj, void * session_baton, char const * path, svn_revnum_t start, svn_revnum_t end, svn_ra_file_rev_handler_t handler, apr_pool_t pool) -> svn_error_t"""
    return _ra.svn_ra_plugin_invoke_get_file_revs(*args)

def svn_ra_plugin_invoke_get_version(_obj):
    r"""svn_ra_plugin_invoke_get_version(svn_ra_plugin_t _obj) -> svn_version_t"""
    return _ra.svn_ra_plugin_invoke_get_version(_obj)

def svn_ra_invoke_get_wc_prop_func(*args):
    r"""svn_ra_invoke_get_wc_prop_func(svn_ra_get_wc_prop_func_t _obj, void * baton, char const * path, char const * name, apr_pool_t pool) -> svn_error_t"""
    return _ra.svn_ra_invoke_get_wc_prop_func(*args)

def svn_ra_invoke_set_wc_prop_func(*args):
    r"""svn_ra_invoke_set_wc_prop_func(svn_ra_set_wc_prop_func_t _obj, void * baton, char const * path, char const * name, svn_string_t const * value, apr_pool_t pool) -> svn_error_t"""
    return _ra.svn_ra_invoke_set_wc_prop_func(*args)

def svn_ra_invoke_push_wc_prop_func(*args):
    r"""svn_ra_invoke_push_wc_prop_func(svn_ra_push_wc_prop_func_t _obj, void * baton, char const * path, char const * name, svn_string_t const * value, apr_pool_t pool) -> svn_error_t"""
    return _ra.svn_ra_invoke_push_wc_prop_func(*args)

def svn_ra_invoke_invalidate_wc_props_func(*args):
    r"""svn_ra_invoke_invalidate_wc_props_func(svn_ra_invalidate_wc_props_func_t _obj, void * baton, char const * path, char const * name, apr_pool_t pool) -> svn_error_t"""
    return _ra.svn_ra_invoke_invalidate_wc_props_func(*args)

def svn_ra_invoke_get_wc_contents_func(*args):
    r"""svn_ra_invoke_get_wc_contents_func(svn_ra_get_wc_contents_func_t _obj, void * baton, svn_checksum_t checksum, apr_pool_t pool) -> svn_error_t"""
    return _ra.svn_ra_invoke_get_wc_contents_func(*args)

def svn_ra_invoke_get_latest_revnum_func(_obj, session_baton):
    r"""svn_ra_invoke_get_latest_revnum_func(svn_ra_get_latest_revnum_func_t _obj, void * session_baton) -> svn_error_t"""
    return _ra.svn_ra_invoke_get_latest_revnum_func(_obj, session_baton)

def svn_ra_invoke_get_client_string_func(*args):
    r"""svn_ra_invoke_get_client_string_func(svn_ra_get_client_string_func_t _obj, void * baton, apr_pool_t pool) -> svn_error_t"""
    return _ra.svn_ra_invoke_get_client_string_func(*args)

def svn_ra_invoke_file_rev_handler(*args):
    r"""svn_ra_invoke_file_rev_handler(svn_ra_file_rev_handler_t _obj, void * baton, char const * path, svn_revnum_t rev, apr_hash_t rev_props, apr_array_header_t prop_diffs, apr_pool_t pool) -> svn_error_t"""
    return _ra.svn_ra_invoke_file_rev_handler(*args)

def svn_ra_invoke_lock_callback(*args):
    r"""svn_ra_invoke_lock_callback(svn_ra_lock_callback_t _obj, void * baton, char const * path, svn_boolean_t do_lock, svn_lock_t lock, svn_error_t ra_err, apr_pool_t pool) -> svn_error_t"""
    return _ra.svn_ra_invoke_lock_callback(*args)

def svn_ra_invoke_progress_notify_func(*args):
    r"""svn_ra_invoke_progress_notify_func(svn_ra_progress_notify_func_t _obj, apr_off_t progress, apr_off_t total, void * baton, apr_pool_t pool)"""
    return _ra.svn_ra_invoke_progress_notify_func(*args)

def svn_ra_invoke_replay_revstart_callback(*args):
    r"""svn_ra_invoke_replay_revstart_callback(svn_ra_replay_revstart_callback_t _obj, svn_revnum_t revision, void * replay_baton, apr_hash_t rev_props, apr_pool_t pool) -> svn_error_t"""
    return _ra.svn_ra_invoke_replay_revstart_callback(*args)

def svn_ra_invoke_replay_revfinish_callback(*args):
    r"""svn_ra_invoke_replay_revfinish_callback(svn_ra_replay_revfinish_callback_t _obj, svn_revnum_t revision, void * replay_baton, svn_delta_editor_t editor, void * edit_baton, apr_hash_t rev_props, apr_pool_t pool) -> svn_error_t"""
    return _ra.svn_ra_invoke_replay_revfinish_callback(*args)

def svn_ra_invoke_check_tunnel_func(_obj, tunnel_baton, tunnel_name):
    r"""svn_ra_invoke_check_tunnel_func(svn_ra_check_tunnel_func_t _obj, void * tunnel_baton, char const * tunnel_name) -> svn_boolean_t"""
    return _ra.svn_ra_invoke_check_tunnel_func(_obj, tunnel_baton, tunnel_name)

def svn_ra_invoke_close_tunnel_func(_obj, close_baton, tunnel_baton):
    r"""svn_ra_invoke_close_tunnel_func(svn_ra_close_tunnel_func_t _obj, void * close_baton, void * tunnel_baton)"""
    return _ra.svn_ra_invoke_close_tunnel_func(_obj, close_baton, tunnel_baton)

def svn_ra_invoke_open_tunnel_func(*args):
    r"""svn_ra_invoke_open_tunnel_func(svn_ra_open_tunnel_func_t _obj, void * tunnel_baton, char const * tunnel_name, char const * user, char const * hostname, int port, svn_cancel_func_t cancel_func, apr_pool_t pool) -> svn_error_t"""
    return _ra.svn_ra_invoke_open_tunnel_func(*args)

def svn_ra_invoke_init_func(*args):
    r"""svn_ra_invoke_init_func(svn_ra_init_func_t _obj, int abi_version, apr_pool_t pool, apr_hash_t hash) -> svn_error_t"""
    return _ra.svn_ra_invoke_init_func(*args)
class svn_ra_get_wc_prop_func_t(object):
    r"""Proxy of C svn_ra_get_wc_prop_func_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_ra_invoke_get_wc_prop_func(self, *args)


# Register svn_ra_get_wc_prop_func_t in _ra:
_ra.svn_ra_get_wc_prop_func_t_swigregister(svn_ra_get_wc_prop_func_t)
class svn_ra_set_wc_prop_func_t(object):
    r"""Proxy of C svn_ra_set_wc_prop_func_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_ra_invoke_set_wc_prop_func(self, *args)


# Register svn_ra_set_wc_prop_func_t in _ra:
_ra.svn_ra_set_wc_prop_func_t_swigregister(svn_ra_set_wc_prop_func_t)
class svn_ra_push_wc_prop_func_t(object):
    r"""Proxy of C svn_ra_push_wc_prop_func_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_ra_invoke_push_wc_prop_func(self, *args)


# Register svn_ra_push_wc_prop_func_t in _ra:
_ra.svn_ra_push_wc_prop_func_t_swigregister(svn_ra_push_wc_prop_func_t)
class svn_ra_invalidate_wc_props_func_t(object):
    r"""Proxy of C svn_ra_invalidate_wc_props_func_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_ra_invoke_invalidate_wc_props_func(self, *args)


# Register svn_ra_invalidate_wc_props_func_t in _ra:
_ra.svn_ra_invalidate_wc_props_func_t_swigregister(svn_ra_invalidate_wc_props_func_t)
class svn_ra_get_wc_contents_func_t(object):
    r"""Proxy of C svn_ra_get_wc_contents_func_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_ra_invoke_get_wc_contents_func(self, *args)


# Register svn_ra_get_wc_contents_func_t in _ra:
_ra.svn_ra_get_wc_contents_func_t_swigregister(svn_ra_get_wc_contents_func_t)
class svn_ra_get_latest_revnum_func_t(object):
    r"""Proxy of C svn_ra_get_latest_revnum_func_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_ra_invoke_get_latest_revnum_func(self, *args)


# Register svn_ra_get_latest_revnum_func_t in _ra:
_ra.svn_ra_get_latest_revnum_func_t_swigregister(svn_ra_get_latest_revnum_func_t)
class svn_ra_get_client_string_func_t(object):
    r"""Proxy of C svn_ra_get_client_string_func_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_ra_invoke_get_client_string_func(self, *args)


# Register svn_ra_get_client_string_func_t in _ra:
_ra.svn_ra_get_client_string_func_t_swigregister(svn_ra_get_client_string_func_t)
class svn_ra_file_rev_handler_t(object):
    r"""Proxy of C svn_ra_file_rev_handler_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_ra_invoke_file_rev_handler(self, *args)


# Register svn_ra_file_rev_handler_t in _ra:
_ra.svn_ra_file_rev_handler_t_swigregister(svn_ra_file_rev_handler_t)
class svn_ra_lock_callback_t(object):
    r"""Proxy of C svn_ra_lock_callback_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_ra_invoke_lock_callback(self, *args)


# Register svn_ra_lock_callback_t in _ra:
_ra.svn_ra_lock_callback_t_swigregister(svn_ra_lock_callback_t)
class svn_ra_progress_notify_func_t(object):
    r"""Proxy of C svn_ra_progress_notify_func_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_ra_invoke_progress_notify_func(self, *args)


# Register svn_ra_progress_notify_func_t in _ra:
_ra.svn_ra_progress_notify_func_t_swigregister(svn_ra_progress_notify_func_t)
class svn_ra_replay_revstart_callback_t(object):
    r"""Proxy of C svn_ra_replay_revstart_callback_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_ra_invoke_replay_revstart_callback(self, *args)


# Register svn_ra_replay_revstart_callback_t in _ra:
_ra.svn_ra_replay_revstart_callback_t_swigregister(svn_ra_replay_revstart_callback_t)
class svn_ra_replay_revfinish_callback_t(object):
    r"""Proxy of C svn_ra_replay_revfinish_callback_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_ra_invoke_replay_revfinish_callback(self, *args)


# Register svn_ra_replay_revfinish_callback_t in _ra:
_ra.svn_ra_replay_revfinish_callback_t_swigregister(svn_ra_replay_revfinish_callback_t)
class svn_ra_check_tunnel_func_t(object):
    r"""Proxy of C svn_ra_check_tunnel_func_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_ra_invoke_check_tunnel_func(self, *args)


# Register svn_ra_check_tunnel_func_t in _ra:
_ra.svn_ra_check_tunnel_func_t_swigregister(svn_ra_check_tunnel_func_t)
class svn_ra_close_tunnel_func_t(object):
    r"""Proxy of C svn_ra_close_tunnel_func_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_ra_invoke_close_tunnel_func(self, *args)


# Register svn_ra_close_tunnel_func_t in _ra:
_ra.svn_ra_close_tunnel_func_t_swigregister(svn_ra_close_tunnel_func_t)
class svn_ra_open_tunnel_func_t(object):
    r"""Proxy of C svn_ra_open_tunnel_func_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_ra_invoke_open_tunnel_func(self, *args)


# Register svn_ra_open_tunnel_func_t in _ra:
_ra.svn_ra_open_tunnel_func_t_swigregister(svn_ra_open_tunnel_func_t)
class svn_ra_init_func_t(object):
    r"""Proxy of C svn_ra_init_func_t struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def set_parent_pool(self, parent_pool=None):
      """Create a new proxy object for TYPE"""
      import libsvn.core, weakref
      self.__dict__["_parent_pool"] = \
        parent_pool or libsvn.core.application_pool;
      if self.__dict__["_parent_pool"]:
        self.__dict__["_is_valid"] = weakref.ref(
          self.__dict__["_parent_pool"]._is_valid)

    def assert_valid(self):
      """Assert that this object is using valid pool memory"""
      if "_is_valid" in self.__dict__:
        assert self.__dict__["_is_valid"](), "Variable has already been deleted"

    def _retrieve_swig_value(self, name, value):
    # If we got back a different object than we have cached, we need to copy
    # all our metadata into it, so that it looks identical to the one
    # originally set.
      members = self.__dict__.get('_members')
      if members is not None and name in members:
        _copy_metadata_deep(value, members[name])

    # Verify that the new object is good
      _assert_valid_deep(value)

      return value

    # Attribute access must be intercepted to ensure that objects coming from
    # read attribute access match those that are set with write attribute access.
    # Specifically the metadata, such as the associated apr_pool object, should
    # match the originally assigned object.
    #
    # For classic classes it is enough to use __getattr__ to intercept swig
    # derived attributes. However, with new style classes SWIG makes use of
    # descriptors which mean that __getattr__ is never called. Therefore,
    # __getattribute__ must be used for the interception.

    if _newclass:
      def __getattribute__(self, name):
        """Manage access to all attributes of this object."""

    # Start by mimicing __getattr__ behavior: immediately return __dict__ or
    # items directly present in __dict__
        mydict = object.__getattribute__(self, '__dict__')

        if name == "__dict__":
          return mydict

        if name in mydict:
          return mydict[name]

        object.__getattribute__(self, 'assert_valid')()

        value = _get_instance_attr(self, name)
        fn = object.__getattribute__(self, '_retrieve_swig_value')
        return fn(name, value)
    else:
      def __getattr__(self, name):
        """Get an attribute from this object"""
        self.assert_valid()

        value = _swig_getattr(self, self.__class__, name)

        return self._retrieve_swig_value(name, value)

    def __setattr__(self, name, value):
      """Set an attribute on this object"""
      self.assert_valid()

    # Save a copy of the object, so that the garbage
    # collector won't kill the object while it's in
    # SWIG-land
      self.__dict__.setdefault("_members",{})[name] = value

      return _set_instance_attr(self, name, value)


    def __call__(self, *args):
      return svn_ra_invoke_init_func(self, *args)


# Register svn_ra_init_func_t in _ra:
_ra.svn_ra_init_func_t_swigregister(svn_ra_init_func_t)


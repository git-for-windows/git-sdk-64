#! /usr/bin/env sh
## DO NOT EDIT - This file generated from libtoolize
##               by inline-source v2019-02-19.15

# Prepare a package to use libtool.
# Written by Gary V. Vaughan <gary@gnu.org>, 2003

# Copyright (C) 2003-2019, 2021-2024 Free Software Foundation, Inc.
# This is free software; see the source for copying conditions.  There is NO
# warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

# Libtoolize is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# Libtoolize is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.


## ------ ##
## Usage. ##
## ------ ##

# Run './libtoolize --help' for help with using this script from the
# command line.


## ------------------------------- ##
## User overridable command paths. ##
## ------------------------------- ##

# After configure completes, it has a better idea of some of the
# shell tools we need than the defaults used by the functions shared
# with bootstrap, so set those here where they can still be over-
# ridden by the user, but otherwise take precedence.

: ${AUTOCONF="autoconf"}
: ${AUTOMAKE="automake"}
: ${EGREP="/usr/bin/grep -E"}
: ${FGREP="/usr/bin/grep -F"}
: ${GREP="/usr/bin/grep"}
: ${LN_S="cp -pR"}
: ${SED="/usr/bin/sed"}


## -------------------------- ##
## Source external libraries. ##
## -------------------------- ##

# Much of our low-level functionality needs to be sourced from external
# libraries, which are installed to $pkgauxdir under normal use, though
# we also need to be able to find them in $srcdir during testing, or if
# executed directly from the build tree.

# Set a version string for this script.
scriptversion=2019-02-19.15; # UTC

# General shell script boiler plate, and helper functions.
# Written by Gary V. Vaughan, 2004

# This is free software.  There is NO warranty; not even for
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
#
# Copyright (C) 2004-2019, 2021, 2023-2024 Bootstrap Authors
#
# This file is dual licensed under the terms of the MIT license
# <https://opensource.org/licenses/MIT>, and GPL version 2 or later
# <https://www.gnu.org/licenses/gpl-2.0.html>.  You must apply one of
# these licenses when using or redistributing this software or any of
# the files within it.  See the URLs above, or the file `LICENSE`
# included in the Bootstrap distribution for the full license texts.

# Please report bugs or propose patches to:
# <https://github.com/gnulib-modules/bootstrap/issues>


## ------ ##
## Usage. ##
## ------ ##

# Evaluate this file near the top of your script to gain access to
# the functions and variables defined here:
#
#   . `echo "$0" | ${SED-sed} 's|[^/]*$||'`/build-aux/funclib.sh
#
# If you need to override any of the default environment variable
# settings, do that before evaluating this file.


## -------------------- ##
## Shell normalisation. ##
## -------------------- ##

# Some shells need a little help to be as Bourne compatible as possible.
# Before doing anything else, make sure all that help has been provided!

DUALCASE=1; export DUALCASE # for MKS sh
if test -n "${ZSH_VERSION+set}" && (emulate sh) >/dev/null 2>&1; then :
  emulate sh
  NULLCMD=:
  # Pre-4.2 versions of Zsh do word splitting on ${1+"$@"}, which
  # is contrary to our usage.  Disable this feature.
  alias -g '${1+"$@"}'='"$@"'
  setopt NO_GLOB_SUBST
else
  case `(set -o) 2>/dev/null` in *posix*) set -o posix ;; esac
fi

# NLS nuisances: We save the old values in case they are required later.
_G_user_locale=
_G_safe_locale=
for _G_var in LANG LANGUAGE LC_ALL LC_CTYPE LC_COLLATE LC_MESSAGES
do
  eval "if test set = \"\${$_G_var+set}\"; then
          save_$_G_var=\$$_G_var
          $_G_var=C
	  export $_G_var
	  _G_user_locale=\"$_G_var=\\\$save_\$_G_var; \$_G_user_locale\"
	  _G_safe_locale=\"$_G_var=C; \$_G_safe_locale\"
	fi"
done
# These NLS vars are set unconditionally (bootstrap issue #24).  Unset those
# in case the environment reset is needed later and the $save_* variant is not
# defined (see the code above).
LC_ALL=C
LANGUAGE=C
export LANGUAGE LC_ALL

# Make sure IFS has a sensible default
sp=' '
nl='
'
IFS="$sp	$nl"

# There are apparently some systems that use ';' as a PATH separator!
if test "${PATH_SEPARATOR+set}" != set; then
  PATH_SEPARATOR=:
  (PATH='/bin;/bin'; FPATH=$PATH; sh -c :) >/dev/null 2>&1 && {
    (PATH='/bin:/bin'; FPATH=$PATH; sh -c :) >/dev/null 2>&1 ||
      PATH_SEPARATOR=';'
  }
fi


# func_unset VAR
# --------------
# Portably unset VAR.
# In some shells, an 'unset VAR' statement leaves a non-zero return
# status if VAR is already unset, which might be problematic if the
# statement is used at the end of a function (thus poisoning its return
# value) or when 'set -e' is active (causing even a spurious abort of
# the script in this case).
func_unset ()
{
    { eval $1=; (eval unset $1) >/dev/null 2>&1 && eval unset $1 || : ; }
}


# Make sure CDPATH doesn't cause `cd` commands to output the target dir.
func_unset CDPATH

# Make sure ${,E,F}GREP behave sanely.
func_unset GREP_OPTIONS


## ------------------------- ##
## Locate command utilities. ##
## ------------------------- ##


# func_executable_p FILE
# ----------------------
# Check that FILE is an executable regular file.
func_executable_p ()
{
    test -f "$1" && test -x "$1"
}


# func_path_progs PROGS_LIST CHECK_FUNC [PATH]
# --------------------------------------------
# Search for either a program that responds to --version with output
# containing "GNU", or else returned by CHECK_FUNC otherwise, by
# trying all the directories in PATH with each of the elements of
# PROGS_LIST.
#
# CHECK_FUNC should accept the path to a candidate program, and
# set $func_check_prog_result if it truncates its output less than
# $_G_path_prog_max characters.
func_path_progs ()
{
    _G_progs_list=$1
    _G_check_func=$2
    _G_PATH=${3-"$PATH"}

    _G_path_prog_max=0
    _G_path_prog_found=false
    _G_save_IFS=$IFS; IFS=${PATH_SEPARATOR-:}
    for _G_dir in $_G_PATH; do
      IFS=$_G_save_IFS
      test -z "$_G_dir" && _G_dir=.
      for _G_prog_name in $_G_progs_list; do
        for _exeext in '' .EXE; do
          _G_path_prog=$_G_dir/$_G_prog_name$_exeext
          func_executable_p "$_G_path_prog" || continue
          case `"$_G_path_prog" --version 2>&1` in
            *GNU*) func_path_progs_result=$_G_path_prog _G_path_prog_found=: ;;
            *)     $_G_check_func $_G_path_prog
		   func_path_progs_result=$func_check_prog_result
		   ;;
          esac
          $_G_path_prog_found && break 3
        done
      done
    done
    IFS=$_G_save_IFS
    test -z "$func_path_progs_result" && {
      echo "no acceptable sed could be found in \$PATH" >&2
      exit 1
    }
}


# We want to be able to use the functions in this file before configure
# has figured out where the best binaries are kept, which means we have
# to search for them ourselves - except when the results are already set
# where we skip the searches.

# Unless the user overrides by setting SED, search the path for either GNU
# sed, or the sed that truncates its output the least.
test -z "$SED" && {
  _G_sed_script=s/aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa/bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb/
  for _G_i in 1 2 3 4 5 6 7; do
    _G_sed_script=$_G_sed_script$nl$_G_sed_script
  done
  echo "$_G_sed_script" 2>/dev/null | sed 99q >conftest.sed
  _G_sed_script=

  func_check_prog_sed ()
  {
    _G_path_prog=$1

    _G_count=0
    printf 0123456789 >conftest.in
    while :
    do
      cat conftest.in conftest.in >conftest.tmp
      mv conftest.tmp conftest.in
      cp conftest.in conftest.nl
      echo '' >> conftest.nl
      "$_G_path_prog" -f conftest.sed <conftest.nl >conftest.out 2>/dev/null || break
      diff conftest.out conftest.nl >/dev/null 2>&1 || break
      _G_count=`expr $_G_count + 1`
      if test "$_G_count" -gt "$_G_path_prog_max"; then
        # Best one so far, save it but keep looking for a better one
        func_check_prog_result=$_G_path_prog
        _G_path_prog_max=$_G_count
      fi
      # 10*(2^10) chars as input seems more than enough
      test 10 -lt "$_G_count" && break
    done
    rm -f conftest.in conftest.tmp conftest.nl conftest.out
  }

  func_path_progs "sed gsed" func_check_prog_sed "$PATH:/usr/xpg4/bin"
  rm -f conftest.sed
  SED=$func_path_progs_result
}


# Unless the user overrides by setting GREP, search the path for either GNU
# grep, or the grep that truncates its output the least.
test -z "$GREP" && {
  func_check_prog_grep ()
  {
    _G_path_prog=$1

    _G_count=0
    _G_path_prog_max=0
    printf 0123456789 >conftest.in
    while :
    do
      cat conftest.in conftest.in >conftest.tmp
      mv conftest.tmp conftest.in
      cp conftest.in conftest.nl
      echo 'GREP' >> conftest.nl
      "$_G_path_prog" -e 'GREP$' -e '-(cannot match)-' <conftest.nl >conftest.out 2>/dev/null || break
      diff conftest.out conftest.nl >/dev/null 2>&1 || break
      _G_count=`expr $_G_count + 1`
      if test "$_G_count" -gt "$_G_path_prog_max"; then
        # Best one so far, save it but keep looking for a better one
        func_check_prog_result=$_G_path_prog
        _G_path_prog_max=$_G_count
      fi
      # 10*(2^10) chars as input seems more than enough
      test 10 -lt "$_G_count" && break
    done
    rm -f conftest.in conftest.tmp conftest.nl conftest.out
  }

  func_path_progs "grep ggrep" func_check_prog_grep "$PATH:/usr/xpg4/bin"
  GREP=$func_path_progs_result
}


## ------------------------------- ##
## User overridable command paths. ##
## ------------------------------- ##

# All uppercase variable names are used for environment variables.  These
# variables can be overridden by the user before calling a script that
# uses them if a suitable command of that name is not already available
# in the command search PATH.

: ${CP="cp -f"}
: ${ECHO="printf %s\n"}
: ${EGREP="$GREP -E"}
: ${FGREP="$GREP -F"}
: ${LN_S="ln -s"}
: ${MAKE="make"}
: ${MKDIR="mkdir"}
: ${MV="mv -f"}
: ${RM="rm -f"}
: ${SHELL="${CONFIG_SHELL-/bin/sh}"}


## -------------------- ##
## Useful sed snippets. ##
## -------------------- ##

sed_dirname='s|/[^/]*$||'
sed_basename='s|^.*/||'

# Sed substitution that helps us do robust quoting.  It backslashifies
# metacharacters that are still active within double-quoted strings.
sed_quote_subst='s|\([`"$\\]\)|\\\1|g'

# Same as above, but do not quote variable references.
sed_double_quote_subst='s/\(["`\\]\)/\\\1/g'

# Sed substitution that turns a string into a regex matching for the
# string literally.
sed_make_literal_regex='s|[].[^$\\*\/]|\\&|g'

# Sed substitution that converts a w32 file name or path
# that contains forward slashes, into one that contains
# (escaped) backslashes.  A very naive implementation.
sed_naive_backslashify='s|\\\\*|\\|g;s|/|\\|g;s|\\|\\\\|g'

# Re-'\' parameter expansions in output of sed_double_quote_subst that
# were '\'-ed in input to the same.  If an odd number of '\' preceded a
# '$' in input to sed_double_quote_subst, that '$' was protected from
# expansion.  Since each input '\' is now two '\'s, look for any number
# of runs of four '\'s followed by two '\'s and then a '$'.  '\' that '$'.
_G_bs='\\'
_G_bs2='\\\\'
_G_bs4='\\\\\\\\'
_G_dollar='\$'
sed_double_backslash="\
  s/$_G_bs4/&\\
/g
  s/^$_G_bs2$_G_dollar/$_G_bs&/
  s/\\([^$_G_bs]\\)$_G_bs2$_G_dollar/\\1$_G_bs2$_G_bs$_G_dollar/g
  s/\n//g"

# require_check_ifs_backslash
# ---------------------------
# Check if we can use backslash as IFS='\' separator, and set
# $check_ifs_backshlash_broken to ':' or 'false'.
require_check_ifs_backslash=func_require_check_ifs_backslash
func_require_check_ifs_backslash ()
{
  _G_save_IFS=$IFS
  IFS='\'
  _G_check_ifs_backshlash='a\\b'
  for _G_i in $_G_check_ifs_backshlash
  do
  case $_G_i in
  a)
    check_ifs_backshlash_broken=false
    ;;
  '')
    break
    ;;
  *)
    check_ifs_backshlash_broken=:
    break
    ;;
  esac
  done
  IFS=$_G_save_IFS
  require_check_ifs_backslash=:
}


## ----------------- ##
## Global variables. ##
## ----------------- ##

# Except for the global variables explicitly listed below, the following
# functions in the '^func_' namespace, and the '^require_' namespace
# variables initialised in the 'Resource management' section, sourcing
# this file will not pollute your global namespace with anything
# else. There's no portable way to scope variables in Bourne shell
# though, so actually running these functions will sometimes place
# results into a variable named after the function, and often use
# temporary variables in the '^_G_' namespace. If you are careful to
# avoid using those namespaces casually in your sourcing script, things
# should continue to work as you expect. And, of course, you can freely
# overwrite any of the functions or variables defined here before
# calling anything to customize them.

EXIT_SUCCESS=0
EXIT_FAILURE=1
EXIT_MISMATCH=63  # $? = 63 is used to indicate version mismatch to missing.
EXIT_SKIP=77	  # $? = 77 is used to indicate a skipped test to automake.

# Allow overriding, eg assuming that you follow the convention of
# putting '$debug_cmd' at the start of all your functions, you can get
# bash to show function call trace with:
#
#    debug_cmd='eval echo "${FUNCNAME[0]} $*" >&2' bash your-script-name
debug_cmd=${debug_cmd-":"}
exit_cmd=:

# By convention, finish your script with:
#
#    exit $exit_status
#
# so that you can set exit_status to non-zero if you want to indicate
# something went wrong during execution without actually bailing out at
# the point of failure.
exit_status=$EXIT_SUCCESS

# Work around backward compatibility issue on IRIX 6.5. On IRIX 6.4+, sh
# is ksh but when the shell is invoked as "sh" and the current value of
# the _XPG environment variable is not equal to 1 (one), the special
# positional parameter $0, within a function call, is the name of the
# function.
progpath=$0

# The name of this program.
progname=`$ECHO "$progpath" |$SED "$sed_basename"`

# Make sure we have an absolute progpath for reexecution:
case $progpath in
  [\\/]*|[A-Za-z]:\\*) ;;
  *[\\/]*)
     progdir=`$ECHO "$progpath" |$SED "$sed_dirname"`
     progdir=`cd "$progdir" && pwd`
     progpath=$progdir/$progname
     ;;
  *)
     _G_IFS=$IFS
     IFS=${PATH_SEPARATOR-:}
     for progdir in $PATH; do
       IFS=$_G_IFS
       test -x "$progdir/$progname" && break
     done
     IFS=$_G_IFS
     test -n "$progdir" || progdir=`pwd`
     progpath=$progdir/$progname
     ;;
esac


## ----------------- ##
## Standard options. ##
## ----------------- ##

# The following options affect the operation of the functions defined
# below, and should be set appropriately depending on run-time para-
# meters passed on the command line.

opt_dry_run=false
opt_quiet=false
opt_verbose=false

# Categories 'all' and 'none' are always available.  Append any others
# you will pass as the first argument to func_warning from your own
# code.
warning_categories=

# By default, display warnings according to 'opt_warning_types'.  Set
# 'warning_func'  to ':' to elide all warnings, or func_fatal_error to
# treat the next displayed warning as a fatal error.
warning_func=func_warn_and_continue

# Set to 'all' to display all warnings, 'none' to suppress all
# warnings, or a space delimited list of some subset of
# 'warning_categories' to display only the listed warnings.
opt_warning_types=all


## -------------------- ##
## Resource management. ##
## -------------------- ##

# This section contains definitions for functions that each ensure a
# particular resource (a file, or a non-empty configuration variable for
# example) is available, and if appropriate to extract default values
# from pertinent package files. Call them using their associated
# 'require_*' variable to ensure that they are executed, at most, once.
#
# It's entirely deliberate that calling these functions can set
# variables that don't obey the namespace limitations obeyed by the rest
# of this file, in order that that they be as useful as possible to
# callers.


# require_term_colors
# -------------------
# Allow display of bold text on terminals that support it.
require_term_colors=func_require_term_colors
func_require_term_colors ()
{
    $debug_cmd

    test -t 1 && {
      # COLORTERM and USE_ANSI_COLORS environment variables take
      # precedence, because most terminfo databases neglect to describe
      # whether color sequences are supported.
      test -n "${COLORTERM+set}" && : ${USE_ANSI_COLORS="1"}

      if test 1 = "$USE_ANSI_COLORS"; then
        # Standard ANSI escape sequences
        tc_reset='[0m'
        tc_bold='[1m';   tc_standout='[7m'
        tc_red='[31m';   tc_green='[32m'
        tc_blue='[34m';  tc_cyan='[36m'
      else
        # Otherwise trust the terminfo database after all.
        test -n "`tput sgr0 2>/dev/null`" && {
          tc_reset=`tput sgr0`
          test -n "`tput bold 2>/dev/null`" && tc_bold=`tput bold`
          tc_standout=$tc_bold
          test -n "`tput smso 2>/dev/null`" && tc_standout=`tput smso`
          test -n "`tput setaf 1 2>/dev/null`" && tc_red=`tput setaf 1`
          test -n "`tput setaf 2 2>/dev/null`" && tc_green=`tput setaf 2`
          test -n "`tput setaf 4 2>/dev/null`" && tc_blue=`tput setaf 4`
          test -n "`tput setaf 5 2>/dev/null`" && tc_cyan=`tput setaf 5`
        }
      fi
    }

    require_term_colors=:
}


## ----------------- ##
## Function library. ##
## ----------------- ##

# This section contains a variety of useful functions to call in your
# scripts. Take note of the portable wrappers for features provided by
# some modern shells, which will fall back to slower equivalents on
# less featureful shells.


# func_append VAR VALUE
# ---------------------
# Append VALUE onto the existing contents of VAR.

  # We should try to minimise forks, especially on Windows where they are
  # unreasonably slow, so skip the feature probes when bash or zsh are
  # being used:
  if test set = "${BASH_VERSION+set}${ZSH_VERSION+set}"; then
    : ${_G_HAVE_ARITH_OP="yes"}
    : ${_G_HAVE_XSI_OPS="yes"}
    # The += operator was introduced in bash 3.1
    case $BASH_VERSION in
      [12].* | 3.0 | 3.0*) ;;
      *)
        : ${_G_HAVE_PLUSEQ_OP="yes"}
        ;;
    esac
  fi

  # _G_HAVE_PLUSEQ_OP
  # Can be empty, in which case the shell is probed, "yes" if += is
  # usable or anything else if it does not work.
  test -z "$_G_HAVE_PLUSEQ_OP" \
    && (eval 'x=a; x+=" b"; test "a b" = "$x"') 2>/dev/null \
    && _G_HAVE_PLUSEQ_OP=yes

if test yes = "$_G_HAVE_PLUSEQ_OP"
then
  # This is an XSI compatible shell, allowing a faster implementation...
  eval 'func_append ()
  {
    $debug_cmd

    eval "$1+=\$2"
  }'
else
  # ...otherwise fall back to using expr, which is often a shell builtin.
  func_append ()
  {
    $debug_cmd

    eval "$1=\$$1\$2"
  }
fi


# func_append_quoted VAR VALUE
# ----------------------------
# Quote VALUE and append to the end of shell variable VAR, separated
# by a space.
if test yes = "$_G_HAVE_PLUSEQ_OP"; then
  eval 'func_append_quoted ()
  {
    $debug_cmd

    func_quote_arg pretty "$2"
    eval "$1+=\\ \$func_quote_arg_result"
  }'
else
  func_append_quoted ()
  {
    $debug_cmd

    func_quote_arg pretty "$2"
    eval "$1=\$$1\\ \$func_quote_arg_result"
  }
fi


# func_append_uniq VAR VALUE
# --------------------------
# Append unique VALUE onto the existing contents of VAR, assuming
# entries are delimited by the first character of VALUE.  For example:
#
#   func_append_uniq options " --another-option option-argument"
#
# will only append to $options if " --another-option option-argument "
# is not already present somewhere in $options already (note spaces at
# each end implied by leading space in second argument).
func_append_uniq ()
{
    $debug_cmd

    eval _G_current_value='`$ECHO $'$1'`'
    _G_delim=`expr "$2" : '\(.\)'`

    case $_G_delim$_G_current_value$_G_delim in
      *"$2$_G_delim"*) ;;
      *) func_append "$@" ;;
    esac
}


# func_arith TERM...
# ------------------
# Set func_arith_result to the result of evaluating TERMs.
  test -z "$_G_HAVE_ARITH_OP" \
    && (eval 'test 2 = $(( 1 + 1 ))') 2>/dev/null \
    && _G_HAVE_ARITH_OP=yes

if test yes = "$_G_HAVE_ARITH_OP"; then
  eval 'func_arith ()
  {
    $debug_cmd

    func_arith_result=$(( $* ))
  }'
else
  func_arith ()
  {
    $debug_cmd

    func_arith_result=`expr "$@"`
  }
fi


# func_basename FILE
# ------------------
# Set func_basename_result to FILE with everything up to and including
# the last / stripped.
if test yes = "$_G_HAVE_XSI_OPS"; then
  # If this shell supports suffix pattern removal, then use it to avoid
  # forking. Hide the definitions single quotes in case the shell chokes
  # on unsupported syntax...
  _b='func_basename_result=${1##*/}'
  _d='case $1 in
        */*) func_dirname_result=${1%/*}$2 ;;
        *  ) func_dirname_result=$3        ;;
      esac'

else
  # ...otherwise fall back to using sed.
  _b='func_basename_result=`$ECHO "$1" |$SED "$sed_basename"`'
  _d='func_dirname_result=`$ECHO "$1"  |$SED "$sed_dirname"`
      if test "X$func_dirname_result" = "X$1"; then
        func_dirname_result=$3
      else
        func_append func_dirname_result "$2"
      fi'
fi

eval 'func_basename ()
{
    $debug_cmd

    '"$_b"'
}'


# func_dirname FILE APPEND NONDIR_REPLACEMENT
# -------------------------------------------
# Compute the dirname of FILE.  If nonempty, add APPEND to the result,
# otherwise set result to NONDIR_REPLACEMENT.
eval 'func_dirname ()
{
    $debug_cmd

    '"$_d"'
}'


# func_dirname_and_basename FILE APPEND NONDIR_REPLACEMENT
# --------------------------------------------------------
# Perform func_basename and func_dirname in a single function
# call:
#   dirname:  Compute the dirname of FILE.  If nonempty,
#             add APPEND to the result, otherwise set result
#             to NONDIR_REPLACEMENT.
#             value returned in "$func_dirname_result"
#   basename: Compute filename of FILE.
#             value returned in "$func_basename_result"
# For efficiency, we do not delegate to the functions above but instead
# duplicate the functionality here.
eval 'func_dirname_and_basename ()
{
    $debug_cmd

    '"$_b"'
    '"$_d"'
}'


# func_echo ARG...
# ----------------
# Echo program name prefixed message.
func_echo ()
{
    $debug_cmd

    _G_message=$*

    func_echo_IFS=$IFS
    IFS=$nl
    for _G_line in $_G_message; do
      IFS=$func_echo_IFS
      $ECHO "$progname: $_G_line"
    done
    IFS=$func_echo_IFS
}


# func_echo_all ARG...
# --------------------
# Invoke $ECHO with all args, space-separated.
func_echo_all ()
{
    $ECHO "$*"
}


# func_echo_infix_1 INFIX ARG...
# ------------------------------
# Echo program name, followed by INFIX on the first line, with any
# additional lines not showing INFIX.
func_echo_infix_1 ()
{
    $debug_cmd

    $require_term_colors

    _G_infix=$1; shift
    _G_indent=$_G_infix
    _G_prefix="$progname: $_G_infix: "
    _G_message=$*

    # Strip color escape sequences before counting printable length
    for _G_tc in "$tc_reset" "$tc_bold" "$tc_standout" "$tc_red" "$tc_green" "$tc_blue" "$tc_cyan"
    do
      test -n "$_G_tc" && {
        _G_esc_tc=`$ECHO "$_G_tc" | $SED "$sed_make_literal_regex"`
        _G_indent=`$ECHO "$_G_indent" | $SED "s|$_G_esc_tc||g"`
      }
    done
    _G_indent="$progname: "`echo "$_G_indent" | $SED 's|.| |g'`"  " ## exclude from sc_prohibit_nested_quotes

    func_echo_infix_1_IFS=$IFS
    IFS=$nl
    for _G_line in $_G_message; do
      IFS=$func_echo_infix_1_IFS
      $ECHO "$_G_prefix$tc_bold$_G_line$tc_reset" >&2
      _G_prefix=$_G_indent
    done
    IFS=$func_echo_infix_1_IFS
}


# func_error ARG...
# -----------------
# Echo program name prefixed message to standard error.
func_error ()
{
    $debug_cmd

    $require_term_colors

    func_echo_infix_1 "  $tc_standout${tc_red}error$tc_reset" "$*" >&2
}


# func_fatal_error ARG...
# -----------------------
# Echo program name prefixed message to standard error, and exit.
func_fatal_error ()
{
    $debug_cmd

    func_error "$*"
    exit $EXIT_FAILURE
}


# func_grep EXPRESSION FILENAME
# -----------------------------
# Check whether EXPRESSION matches any line of FILENAME, without output.
func_grep ()
{
    $debug_cmd

    $GREP "$1" "$2" >/dev/null 2>&1
}


# func_len STRING
# ---------------
# Set func_len_result to the length of STRING. STRING may not
# start with a hyphen.
  test -z "$_G_HAVE_XSI_OPS" \
    && (eval 'x=a/b/c;
      test 5aa/bb/cc = "${#x}${x%%/*}${x%/*}${x#*/}${x##*/}"') 2>/dev/null \
    && _G_HAVE_XSI_OPS=yes

if test yes = "$_G_HAVE_XSI_OPS"; then
  eval 'func_len ()
  {
    $debug_cmd

    func_len_result=${#1}
  }'
else
  func_len ()
  {
    $debug_cmd

    func_len_result=`expr "$1" : ".*" 2>/dev/null || echo $max_cmd_len`
  }
fi


# func_mkdir_p DIRECTORY-PATH
# ---------------------------
# Make sure the entire path to DIRECTORY-PATH is available.
func_mkdir_p ()
{
    $debug_cmd

    _G_directory_path=$1
    _G_dir_list=

    if test -n "$_G_directory_path" && test : != "$opt_dry_run"; then

      # Protect directory names starting with '-'
      case $_G_directory_path in
        -*) _G_directory_path=./$_G_directory_path ;;
      esac

      # While some portion of DIR does not yet exist...
      while test ! -d "$_G_directory_path"; do
        # ...make a list in topmost first order.  Use a colon delimited
	# list in case some portion of path contains whitespace.
        _G_dir_list=$_G_directory_path:$_G_dir_list

        # If the last portion added has no slash in it, the list is done
        case $_G_directory_path in */*) ;; *) break ;; esac

        # ...otherwise throw away the child directory and loop
        _G_directory_path=`$ECHO "$_G_directory_path" | $SED -e "$sed_dirname"`
      done
      _G_dir_list=`$ECHO "$_G_dir_list" | $SED 's|:*$||'`

      func_mkdir_p_IFS=$IFS; IFS=:
      for _G_dir in $_G_dir_list; do
	IFS=$func_mkdir_p_IFS
        # mkdir can fail with a 'File exist' error if two processes
        # try to create one of the directories concurrently.  Don't
        # stop in that case!
        $MKDIR "$_G_dir" 2>/dev/null || :
      done
      IFS=$func_mkdir_p_IFS

      # Bail out if we (or some other process) failed to create a directory.
      test -d "$_G_directory_path" || \
        func_fatal_error "Failed to create '$1'"
    fi
}


# func_mktempdir [BASENAME]
# -------------------------
# Make a temporary directory that won't clash with other running
# libtool processes, and avoids race conditions if possible.  If
# given, BASENAME is the basename for that directory.
func_mktempdir ()
{
    $debug_cmd

    _G_template=${TMPDIR-/tmp}/${1-$progname}

    if test : = "$opt_dry_run"; then
      # Return a directory name, but don't create it in dry-run mode
      _G_tmpdir=$_G_template-$$
    else

      # If mktemp works, use that first and foremost
      _G_tmpdir=`mktemp -d "$_G_template-XXXXXXXX" 2>/dev/null`

      if test ! -d "$_G_tmpdir"; then
        # Failing that, at least try and use $RANDOM to avoid a race
        _G_tmpdir=$_G_template-${RANDOM-0}$$

        func_mktempdir_umask=`umask`
        umask 0077
        $MKDIR "$_G_tmpdir"
        umask $func_mktempdir_umask
      fi

      # If we're not in dry-run mode, bomb out on failure
      test -d "$_G_tmpdir" || \
        func_fatal_error "cannot create temporary directory '$_G_tmpdir'"
    fi

    $ECHO "$_G_tmpdir"
}


# func_normal_abspath PATH
# ------------------------
# Remove doubled-up and trailing slashes, "." path components,
# and cancel out any ".." path components in PATH after making
# it an absolute path.
func_normal_abspath ()
{
    $debug_cmd

    # These SED scripts presuppose an absolute path with a trailing slash.
    _G_pathcar='s|^/\([^/]*\).*$|\1|'
    _G_pathcdr='s|^/[^/]*||'
    _G_removedotparts=':dotsl
		s|/\./|/|g
		t dotsl
		s|/\.$|/|'
    _G_collapseslashes='s|/\{1,\}|/|g'
    _G_finalslash='s|/*$|/|'

    # Start from root dir and reassemble the path.
    func_normal_abspath_result=
    func_normal_abspath_tpath=$1
    func_normal_abspath_altnamespace=
    case $func_normal_abspath_tpath in
      "")
        # Empty path, that just means $cwd.
        func_stripname '' '/' "`pwd`"
        func_normal_abspath_result=$func_stripname_result
        return
        ;;
      # The next three entries are used to spot a run of precisely
      # two leading slashes without using negated character classes;
      # we take advantage of case's first-match behaviour.
      ///*)
        # Unusual form of absolute path, do nothing.
        ;;
      //*)
        # Not necessarily an ordinary path; POSIX reserves leading '//'
        # and for example Cygwin uses it to access remote file shares
        # over CIFS/SMB, so we conserve a leading double slash if found.
        func_normal_abspath_altnamespace=/
        ;;
      /*)
        # Absolute path, do nothing.
        ;;
      *)
        # Relative path, prepend $cwd.
        func_normal_abspath_tpath=`pwd`/$func_normal_abspath_tpath
        ;;
    esac

    # Cancel out all the simple stuff to save iterations.  We also want
    # the path to end with a slash for ease of parsing, so make sure
    # there is one (and only one) here.
    func_normal_abspath_tpath=`$ECHO "$func_normal_abspath_tpath" | $SED \
          -e "$_G_removedotparts" -e "$_G_collapseslashes" -e "$_G_finalslash"`
    while :; do
      # Processed it all yet?
      if test / = "$func_normal_abspath_tpath"; then
        # If we ascended to the root using ".." the result may be empty now.
        if test -z "$func_normal_abspath_result"; then
          func_normal_abspath_result=/
        fi
        break
      fi
      func_normal_abspath_tcomponent=`$ECHO "$func_normal_abspath_tpath" | $SED \
          -e "$_G_pathcar"`
      func_normal_abspath_tpath=`$ECHO "$func_normal_abspath_tpath" | $SED \
          -e "$_G_pathcdr"`
      # Figure out what to do with it
      case $func_normal_abspath_tcomponent in
        "")
          # Trailing empty path component, ignore it.
          ;;
        ..)
          # Parent dir; strip last assembled component from result.
          func_dirname "$func_normal_abspath_result"
          func_normal_abspath_result=$func_dirname_result
          ;;
        *)
          # Actual path component, append it.
          func_append func_normal_abspath_result "/$func_normal_abspath_tcomponent"
          ;;
      esac
    done
    # Restore leading double-slash if one was found on entry.
    func_normal_abspath_result=$func_normal_abspath_altnamespace$func_normal_abspath_result
}


# func_notquiet ARG...
# --------------------
# Echo program name prefixed message only when not in quiet mode.
func_notquiet ()
{
    $debug_cmd

    $opt_quiet || func_echo ${1+"$@"}

    # A bug in bash halts the script if the last line of a function
    # fails when set -e is in force, so we need another command to
    # work around that:
    :
}


# func_relative_path SRCDIR DSTDIR
# --------------------------------
# Set func_relative_path_result to the relative path from SRCDIR to DSTDIR.
func_relative_path ()
{
    $debug_cmd

    func_relative_path_result=
    func_normal_abspath "$1"
    func_relative_path_tlibdir=$func_normal_abspath_result
    func_normal_abspath "$2"
    func_relative_path_tbindir=$func_normal_abspath_result

    # Ascend the tree starting from libdir
    while :; do
      # check if we have found a prefix of bindir
      case $func_relative_path_tbindir in
        $func_relative_path_tlibdir)
          # found an exact match
          func_relative_path_tcancelled=
          break
          ;;
        $func_relative_path_tlibdir*)
          # found a matching prefix
          func_stripname "$func_relative_path_tlibdir" '' "$func_relative_path_tbindir"
          func_relative_path_tcancelled=$func_stripname_result
          if test -z "$func_relative_path_result"; then
            func_relative_path_result=.
          fi
          break
          ;;
        *)
          func_dirname $func_relative_path_tlibdir
          func_relative_path_tlibdir=$func_dirname_result
          if test -z "$func_relative_path_tlibdir"; then
            # Have to descend all the way to the root!
            func_relative_path_result=../$func_relative_path_result
            func_relative_path_tcancelled=$func_relative_path_tbindir
            break
          fi
          func_relative_path_result=../$func_relative_path_result
          ;;
      esac
    done

    # Now calculate path; take care to avoid doubling-up slashes.
    func_stripname '' '/' "$func_relative_path_result"
    func_relative_path_result=$func_stripname_result
    func_stripname '/' '/' "$func_relative_path_tcancelled"
    if test -n "$func_stripname_result"; then
      func_append func_relative_path_result "/$func_stripname_result"
    fi

    # Normalisation. If bindir is libdir, return '.' else relative path.
    if test -n "$func_relative_path_result"; then
      func_stripname './' '' "$func_relative_path_result"
      func_relative_path_result=$func_stripname_result
    fi

    test -n "$func_relative_path_result" || func_relative_path_result=.

    :
}


# func_quote_portable EVAL ARG
# ----------------------------
# Internal function to portably implement func_quote_arg.  Note that we still
# keep attention to performance here so we as much as possible try to avoid
# calling sed binary (so far O(N) complexity as long as func_append is O(1)).
func_quote_portable ()
{
    $debug_cmd

    $require_check_ifs_backslash

    func_quote_portable_result=$2

    # one-time-loop (easy break)
    while true
    do
      if $1; then
        func_quote_portable_result=`$ECHO "$2" | $SED \
          -e "$sed_double_quote_subst" -e "$sed_double_backslash"`
        break
      fi

      # Quote for eval.
      case $func_quote_portable_result in
        *[\\\`\"\$]*)
          # Fallback to sed for $func_check_bs_ifs_broken=:, or when the string
          # contains the shell wildcard characters.
          case $check_ifs_backshlash_broken$func_quote_portable_result in
            :*|*[\[\*\?]*)
              func_quote_portable_result=`$ECHO "$func_quote_portable_result" \
                  | $SED "$sed_quote_subst"`
              break
              ;;
          esac

          func_quote_portable_old_IFS=$IFS
          for _G_char in '\' '`' '"' '$'
          do
            # STATE($1) PREV($2) SEPARATOR($3)
            set start "" ""
            func_quote_portable_result=dummy"$_G_char$func_quote_portable_result$_G_char"dummy
            IFS=$_G_char
            for _G_part in $func_quote_portable_result
            do
              case $1 in
              quote)
                func_append func_quote_portable_result "$3$2"
                set quote "$_G_part" "\\$_G_char"
                ;;
              start)
                set first "" ""
                func_quote_portable_result=
                ;;
              first)
                set quote "$_G_part" ""
                ;;
              esac
            done
          done
          IFS=$func_quote_portable_old_IFS
          ;;
        *) ;;
      esac
      break
    done

    func_quote_portable_unquoted_result=$func_quote_portable_result
    case $func_quote_portable_result in
      # double-quote args containing shell metacharacters to delay
      # word splitting, command substitution and variable expansion
      # for a subsequent eval.
      # many bourne shells cannot handle close brackets correctly
      # in scan sets, so we specify it separately.
      *[\[\~\#\^\&\*\(\)\{\}\|\;\<\>\?\'\ \	]*|*]*|"")
        func_quote_portable_result=\"$func_quote_portable_result\"
        ;;
    esac
}


# func_quotefast_eval ARG
# -----------------------
# Quote one ARG (internal).  This is equivalent to 'func_quote_arg eval ARG',
# but optimized for speed.  Result is stored in $func_quotefast_eval.
if test xyes = `(x=; printf -v x %q yes; echo x"$x") 2>/dev/null`; then
  printf -v _GL_test_printf_tilde %q '~'
  if test '\~' = "$_GL_test_printf_tilde"; then
    func_quotefast_eval ()
    {
      printf -v func_quotefast_eval_result %q "$1"
    }
  else
    # Broken older Bash implementations.  Make those faster too if possible.
    func_quotefast_eval ()
    {
      case $1 in
        '~'*)
          func_quote_portable false "$1"
          func_quotefast_eval_result=$func_quote_portable_result
          ;;
        *)
          printf -v func_quotefast_eval_result %q "$1"
          ;;
      esac
    }
  fi
else
  func_quotefast_eval ()
  {
    func_quote_portable false "$1"
    func_quotefast_eval_result=$func_quote_portable_result
  }
fi


# func_quote_arg MODEs ARG
# ------------------------
# Quote one ARG to be evaled later.  MODEs argument may contain zero or more
# specifiers listed below separated by ',' character.  This function returns two
# values:
#   i) func_quote_arg_result
#      double-quoted (when needed), suitable for a subsequent eval
#  ii) func_quote_arg_unquoted_result
#      has all characters that are still active within double
#      quotes backslashified.  Available only if 'unquoted' is specified.
#
# Available modes:
# ----------------
# 'eval' (default)
#       - escape shell special characters
# 'expand'
#       - the same as 'eval';  but do not quote variable references
# 'pretty'
#       - request aesthetic output, i.e. '"a b"' instead of 'a\ b'.  This might
#         be used later in func_quote to get output like: 'echo "a b"' instead
#         of 'echo a\ b'.  This is slower than default on some shells.
# 'unquoted'
#       - produce also $func_quote_arg_unquoted_result which does not contain
#         wrapping double-quotes.
#
# Examples for 'func_quote_arg pretty,unquoted string':
#
#   string      | *_result              | *_unquoted_result
#   ------------+-----------------------+-------------------
#   "           | \"                    | \"
#   a b         | "a b"                 | a b
#   "a b"       | "\"a b\""             | \"a b\"
#   *           | "*"                   | *
#   z="${x-$y}" | "z=\"\${x-\$y}\""     | z=\"\${x-\$y}\"
#
# Examples for 'func_quote_arg pretty,unquoted,expand string':
#
#   string        |   *_result          |  *_unquoted_result
#   --------------+---------------------+--------------------
#   z="${x-$y}"   | "z=\"${x-$y}\""     | z=\"${x-$y}\"
func_quote_arg ()
{
    _G_quote_expand=false
    case ,$1, in
      *,expand,*)
        _G_quote_expand=:
        ;;
    esac

    case ,$1, in
      *,pretty,*|*,expand,*|*,unquoted,*)
        func_quote_portable $_G_quote_expand "$2"
        func_quote_arg_result=$func_quote_portable_result
        func_quote_arg_unquoted_result=$func_quote_portable_unquoted_result
        ;;
      *)
        # Faster quote-for-eval for some shells.
        func_quotefast_eval "$2"
        func_quote_arg_result=$func_quotefast_eval_result
        ;;
    esac
}


# func_quote MODEs ARGs...
# ------------------------
# Quote all ARGs to be evaled later and join them into single command.  See
# func_quote_arg's description for more info.
func_quote ()
{
    $debug_cmd
    _G_func_quote_mode=$1 ; shift
    func_quote_result=
    while test 0 -lt $#; do
      func_quote_arg "$_G_func_quote_mode" "$1"
      if test -n "$func_quote_result"; then
        func_append func_quote_result " $func_quote_arg_result"
      else
        func_append func_quote_result "$func_quote_arg_result"
      fi
      shift
    done
}


# func_stripname PREFIX SUFFIX NAME
# ---------------------------------
# strip PREFIX and SUFFIX from NAME, and store in func_stripname_result.
# PREFIX and SUFFIX must not contain globbing or regex special
# characters, hashes, percent signs, but SUFFIX may contain a leading
# dot (in which case that matches only a dot).
if test yes = "$_G_HAVE_XSI_OPS"; then
  eval 'func_stripname ()
  {
    $debug_cmd

    # pdksh 5.2.14 does not do ${X%$Y} correctly if both X and Y are
    # positional parameters, so assign one to ordinary variable first.
    func_stripname_result=$3
    func_stripname_result=${func_stripname_result#"$1"}
    func_stripname_result=${func_stripname_result%"$2"}
  }'
else
  func_stripname ()
  {
    $debug_cmd

    case $2 in
      .*) func_stripname_result=`$ECHO "$3" | $SED -e "s%^$1%%" -e "s%\\\\$2\$%%"`;;
      *)  func_stripname_result=`$ECHO "$3" | $SED -e "s%^$1%%" -e "s%$2\$%%"`;;
    esac
  }
fi


# func_show_eval CMD [FAIL_EXP]
# -----------------------------
# Unless opt_quiet is true, then output CMD.  Then, if opt_dryrun is
# not true, evaluate CMD.  If the evaluation of CMD fails, and FAIL_EXP
# is given, then evaluate it.
func_show_eval ()
{
    $debug_cmd

    _G_cmd=$1
    _G_fail_exp=${2-':'}

    func_quote_arg pretty,expand "$_G_cmd"
    eval "func_notquiet $func_quote_arg_result"

    $opt_dry_run || {
      eval "$_G_cmd"
      _G_status=$?
      if test 0 -ne "$_G_status"; then
	eval "(exit $_G_status); $_G_fail_exp"
      fi
    }
}


# func_show_eval_locale CMD [FAIL_EXP]
# ------------------------------------
# Unless opt_quiet is true, then output CMD.  Then, if opt_dryrun is
# not true, evaluate CMD.  If the evaluation of CMD fails, and FAIL_EXP
# is given, then evaluate it.  Use the saved locale for evaluation.
func_show_eval_locale ()
{
    $debug_cmd

    _G_cmd=$1
    _G_fail_exp=${2-':'}

    $opt_quiet || {
      func_quote_arg expand,pretty "$_G_cmd"
      eval "func_echo $func_quote_arg_result"
    }

    $opt_dry_run || {
      eval "$_G_user_locale
	    $_G_cmd"
      _G_status=$?
      eval "$_G_safe_locale"
      if test 0 -ne "$_G_status"; then
	eval "(exit $_G_status); $_G_fail_exp"
      fi
    }
}


# func_tr_sh
# ----------
# Turn $1 into a string suitable for a shell variable name.
# Result is stored in $func_tr_sh_result.  All characters
# not in the set a-zA-Z0-9_ are replaced with '_'. Further,
# if $1 begins with a digit, a '_' is prepended as well.
func_tr_sh ()
{
    $debug_cmd

    case $1 in
    [0-9]* | *[!a-zA-Z0-9_]*)
      func_tr_sh_result=`$ECHO "$1" | $SED -e 's/^\([0-9]\)/_\1/' -e 's/[^a-zA-Z0-9_]/_/g'`
      ;;
    * )
      func_tr_sh_result=$1
      ;;
    esac
}


# func_verbose ARG...
# -------------------
# Echo program name prefixed message in verbose mode only.
func_verbose ()
{
    $debug_cmd

    $opt_verbose && func_echo "$*"

    :
}


# func_warn_and_continue ARG...
# -----------------------------
# Echo program name prefixed warning message to standard error.
func_warn_and_continue ()
{
    $debug_cmd

    $require_term_colors

    func_echo_infix_1 "${tc_red}warning$tc_reset" "$*" >&2
}


# func_warning CATEGORY ARG...
# ----------------------------
# Echo program name prefixed warning message to standard error. Warning
# messages can be filtered according to CATEGORY, where this function
# elides messages where CATEGORY is not listed in the global variable
# 'opt_warning_types'.
func_warning ()
{
    $debug_cmd

    # CATEGORY must be in the warning_categories list!
    case " $warning_categories " in
      *" $1 "*) ;;
      *) func_internal_error "invalid warning category '$1'" ;;
    esac

    _G_category=$1
    shift

    case " $opt_warning_types " in
      *" $_G_category "*) $warning_func ${1+"$@"} ;;
    esac
}


# func_sort_ver VER1 VER2
# -----------------------
# 'sort -V' is not generally available.
# Note this deviates from the version comparison in automake
# in that it treats 1.5 < 1.5.0, and treats 1.4.4a < 1.4-p3a
# but this should suffice as we won't be specifying old
# version formats or redundant trailing .0 in bootstrap.conf.
# If we did want full compatibility then we should probably
# use m4_version_compare from autoconf.
func_sort_ver ()
{
    $debug_cmd

    printf '%s\n%s\n' "$1" "$2" \
      | sort -t. -k 1,1n -k 2,2n -k 3,3n -k 4,4n -k 5,5n -k 6,6n -k 7,7n -k 8,8n -k 9,9n
}

# func_lt_ver PREV CURR
# ---------------------
# Return true if PREV and CURR are in the correct order according to
# func_sort_ver, otherwise false.  Use it like this:
#
#  func_lt_ver "$prev_ver" "$proposed_ver" || func_fatal_error "..."
func_lt_ver ()
{
    $debug_cmd

    test "x$1" = x`func_sort_ver "$1" "$2" | $SED 1q`
}


# Local variables:
# mode: shell-script
# sh-indentation: 2
# eval: (add-hook 'before-save-hook 'time-stamp)
# time-stamp-pattern: "10/scriptversion=%:y-%02m-%02d.%02H; # UTC"
# time-stamp-time-zone: "UTC"
# End:
#! /bin/sh

# A portable, pluggable option parser for Bourne shell.
# Written by Gary V. Vaughan, 2010

# This is free software.  There is NO warranty; not even for
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
#
# Copyright (C) 2010-2019, 2021, 2023-2024 Bootstrap Authors
#
# This file is dual licensed under the terms of the MIT license
# <https://opensource.org/licenses/MIT>, and GPL version 2 or later
# <https://www.gnu.org/licenses/gpl-2.0.html>.  You must apply one of
# these licenses when using or redistributing this software or any of
# the files within it.  See the URLs above, or the file `LICENSE`
# included in the Bootstrap distribution for the full license texts.

# Please report bugs or propose patches to:
# <https://github.com/gnulib-modules/bootstrap/issues>

# Set a version string for this script.
scriptversion=2019-02-19.15; # UTC


## ------ ##
## Usage. ##
## ------ ##

# This file is a library for parsing options in your shell scripts along
# with assorted other useful supporting features that you can make use
# of too.
#
# For the simplest scripts you might need only:
#
#   #!/bin/sh
#   . relative/path/to/funclib.sh
#   . relative/path/to/options-parser
#   scriptversion=1.0
#   func_options ${1+"$@"}
#   eval set dummy "$func_options_result"; shift
#   ...rest of your script...
#
# In order for the '--version' option to work, you will need to have a
# suitably formatted comment like the one at the top of this file
# starting with '# Written by ' and ending with '# Copyright'.
#
# For '-h' and '--help' to work, you will also need a one line
# description of your script's purpose in a comment directly above the
# '# Written by ' line, like the one at the top of this file.
#
# The default options also support '--debug', which will turn on shell
# execution tracing (see the comment above debug_cmd below for another
# use), and '--verbose' and the func_verbose function to allow your script
# to display verbose messages only when your user has specified
# '--verbose'.
#
# After sourcing this file, you can plug in processing for additional
# options by amending the variables from the 'Configuration' section
# below, and following the instructions in the 'Option parsing'
# section further down.

## -------------- ##
## Configuration. ##
## -------------- ##

# You should override these variables in your script after sourcing this
# file so that they reflect the customisations you have added to the
# option parser.

# The usage line for option parsing errors and the start of '-h' and
# '--help' output messages. You can embed shell variables for delayed
# expansion at the time the message is displayed, but you will need to
# quote other shell meta-characters carefully to prevent them being
# expanded when the contents are evaled.
usage='$progpath [OPTION]...'

# Short help message in response to '-h' and '--help'.  Add to this or
# override it after sourcing this library to reflect the full set of
# options your script accepts.
usage_message="\
       --debug        enable verbose shell tracing
   -W, --warnings=CATEGORY
                      report the warnings falling in CATEGORY [all]
   -v, --verbose      verbosely report processing
       --version      print version information and exit
   -h, --help         print short or long help message and exit
"

# Additional text appended to 'usage_message' in response to '--help'.
long_help_message="
Warning categories include:
       'all'          show all warnings
       'none'         turn off all the warnings
       'error'        warnings are treated as fatal errors"

# Help message printed before fatal option parsing errors.
fatal_help="Try '\$progname --help' for more information."



## ------------------------- ##
## Hook function management. ##
## ------------------------- ##

# This section contains functions for adding, removing, and running hooks
# in the main code.  A hook is just a list of function names that can be
# run in order later on.

# func_hookable FUNC_NAME
# -----------------------
# Declare that FUNC_NAME will run hooks added with
# 'func_add_hook FUNC_NAME ...'.
func_hookable ()
{
    $debug_cmd

    func_append hookable_fns " $1"
}


# func_add_hook FUNC_NAME HOOK_FUNC
# ---------------------------------
# Request that FUNC_NAME call HOOK_FUNC before it returns.  FUNC_NAME must
# first have been declared "hookable" by a call to 'func_hookable'.
func_add_hook ()
{
    $debug_cmd

    case " $hookable_fns " in
      *" $1 "*) ;;
      *) func_fatal_error "'$1' does not accept hook functions." ;;
    esac

    eval func_append ${1}_hooks '" $2"'
}


# func_remove_hook FUNC_NAME HOOK_FUNC
# ------------------------------------
# Remove HOOK_FUNC from the list of hook functions to be called by
# FUNC_NAME.
func_remove_hook ()
{
    $debug_cmd

    eval ${1}_hooks='`$ECHO "\$'$1'_hooks" |$SED "s| '$2'||"`'
}


# func_propagate_result FUNC_NAME_A FUNC_NAME_B
# ---------------------------------------------
# If the *_result variable of FUNC_NAME_A _is set_, assign its value to
# *_result variable of FUNC_NAME_B.
func_propagate_result ()
{
    $debug_cmd

    func_propagate_result_result=:
    if eval "test \"\${${1}_result+set}\" = set"
    then
      eval "${2}_result=\$${1}_result"
    else
      func_propagate_result_result=false
    fi
}


# func_run_hooks FUNC_NAME [ARG]...
# ---------------------------------
# Run all hook functions registered to FUNC_NAME.
# It's assumed that the list of hook functions contains nothing more
# than a whitespace-delimited list of legal shell function names, and
# no effort is wasted trying to catch shell meta-characters or preserve
# whitespace.
func_run_hooks ()
{
    $debug_cmd

    case " $hookable_fns " in
      *" $1 "*) ;;
      *) func_fatal_error "'$1' does not support hook functions." ;;
    esac

    eval _G_hook_fns=\$$1_hooks; shift

    for _G_hook in $_G_hook_fns; do
      func_unset "${_G_hook}_result"
      eval $_G_hook '${1+"$@"}'
      func_propagate_result $_G_hook func_run_hooks
      if $func_propagate_result_result; then
        eval set dummy "$func_run_hooks_result"; shift
      fi
    done
}



## --------------- ##
## Option parsing. ##
## --------------- ##

# In order to add your own option parsing hooks, you must accept the
# full positional parameter list from your hook function.  You may remove
# or edit any options that you action, and then pass back the remaining
# unprocessed options in '<hooked_function_name>_result', escaped
# suitably for 'eval'.
#
# The '<hooked_function_name>_result' variable is automatically unset
# before your hook gets called; for best performance, only set the
# *_result variable when necessary (i.e. don't call the 'func_quote'
# function unnecessarily because it can be an expensive operation on some
# machines).
#
# Like this:
#
#    my_options_prep ()
#    {
#        $debug_cmd
#
#        # Extend the existing usage message.
#        usage_message=$usage_message'
#      -s, --silent       don'\''t print informational messages
#    '
#        # No change in '$@' (ignored completely by this hook).  Leave
#        # my_options_prep_result variable intact.
#    }
#    func_add_hook func_options_prep my_options_prep
#
#
#    my_silent_option ()
#    {
#        $debug_cmd
#
#        args_changed=false
#
#        # Note that, for efficiency, we parse as many options as we can
#        # recognise in a loop before passing the remainder back to the
#        # caller on the first unrecognised argument we encounter.
#        while test $# -gt 0; do
#          opt=$1; shift
#          case $opt in
#            --silent|-s) opt_silent=:
#                         args_changed=:
#                         ;;
#            # Separate non-argument short options:
#            -s*)         func_split_short_opt "$_G_opt"
#                         set dummy "$func_split_short_opt_name" \
#                             "-$func_split_short_opt_arg" ${1+"$@"}
#                         shift
#                         args_changed=:
#                         ;;
#            *)           # Make sure the first unrecognised option "$_G_opt"
#                         # is added back to "$@" in case we need it later,
#                         # if $args_changed was set to 'true'.
#                         set dummy "$_G_opt" ${1+"$@"}; shift; break ;;
#          esac
#        done
#
#        # Only call 'func_quote' here if we processed at least one argument.
#        if $args_changed; then
#          func_quote eval ${1+"$@"}
#          my_silent_option_result=$func_quote_result
#        fi
#    }
#    func_add_hook func_parse_options my_silent_option
#
#
#    my_option_validation ()
#    {
#        $debug_cmd
#
#        $opt_silent && $opt_verbose && func_fatal_help "\
#    '--silent' and '--verbose' options are mutually exclusive."
#    }
#    func_add_hook func_validate_options my_option_validation
#
# You'll also need to manually amend $usage_message to reflect the extra
# options you parse.  It's preferable to append if you can, so that
# multiple option parsing hooks can be added safely.


# func_options_finish [ARG]...
# ----------------------------
# Finishing the option parse loop (call 'func_options' hooks ATM).
func_options_finish ()
{
    $debug_cmd

    func_run_hooks func_options ${1+"$@"}
    func_propagate_result func_run_hooks func_options_finish
}


# func_options [ARG]...
# ---------------------
# All the functions called inside func_options are hookable. See the
# individual implementations for details.
func_hookable func_options
func_options ()
{
    $debug_cmd

    _G_options_quoted=false

    for my_func in options_prep parse_options validate_options options_finish
    do
      func_unset func_${my_func}_result
      func_unset func_run_hooks_result
      eval func_$my_func '${1+"$@"}'
      func_propagate_result func_$my_func func_options
      if $func_propagate_result_result; then
        eval set dummy "$func_options_result"; shift
        _G_options_quoted=:
      fi
    done

    $_G_options_quoted || {
      # As we (func_options) are top-level options-parser function and
      # nobody quoted "$@" for us yet, we need to do it explicitly for
      # caller.
      func_quote eval ${1+"$@"}
      func_options_result=$func_quote_result
    }
}


# func_options_prep [ARG]...
# --------------------------
# All initialisations required before starting the option parse loop.
# Note that when calling hook functions, we pass through the list of
# positional parameters.  If a hook function modifies that list, and
# needs to propagate that back to rest of this script, then the complete
# modified list must be put in 'func_run_hooks_result' before returning.
func_hookable func_options_prep
func_options_prep ()
{
    $debug_cmd

    # Option defaults:
    opt_verbose=false
    opt_warning_types=

    func_run_hooks func_options_prep ${1+"$@"}
    func_propagate_result func_run_hooks func_options_prep
}


# func_parse_options [ARG]...
# ---------------------------
# The main option parsing loop.
func_hookable func_parse_options
func_parse_options ()
{
    $debug_cmd

    _G_parse_options_requote=false
    # this just eases exit handling
    while test $# -gt 0; do
      # Defer to hook functions for initial option parsing, so they
      # get priority in the event of reusing an option name.
      func_run_hooks func_parse_options ${1+"$@"}
      func_propagate_result func_run_hooks func_parse_options
      if $func_propagate_result_result; then
        eval set dummy "$func_parse_options_result"; shift
        # Even though we may have changed "$@", we passed the "$@" array
        # down into the hook and it quoted it for us (because we are in
        # this if-branch).  No need to quote it again.
        _G_parse_options_requote=false
      fi

      # Break out of the loop if we already parsed every option.
      test $# -gt 0 || break

      # We expect that one of the options parsed in this function matches
      # and thus we remove _G_opt from "$@" and need to re-quote.
      _G_match_parse_options=:
      _G_opt=$1
      shift
      case $_G_opt in
        --debug|-x)   debug_cmd='set -x'
                      func_echo "enabling shell trace mode" >&2
                      $debug_cmd
                      ;;

        --no-warnings|--no-warning|--no-warn)
                      set dummy --warnings none ${1+"$@"}
                      shift
		      ;;

        --warnings|--warning|-W)
                      if test $# = 0 && func_missing_arg $_G_opt; then
                        _G_parse_options_requote=:
                        break
                      fi
                      case " $warning_categories $1" in
                        *" $1 "*)
                          # trailing space prevents matching last $1 above
                          func_append_uniq opt_warning_types " $1"
                          ;;
                        *all)
                          opt_warning_types=$warning_categories
                          ;;
                        *none)
                          opt_warning_types=none
                          warning_func=:
                          ;;
                        *error)
                          opt_warning_types=$warning_categories
                          warning_func=func_fatal_error
                          ;;
                        *)
                          func_fatal_error \
                             "unsupported warning category: '$1'"
                          ;;
                      esac
                      shift
                      ;;

        --verbose|-v) opt_verbose=: ;;
        --version)    func_version ;;
        -\?|-h)       func_usage ;;
        --help)       func_help ;;

	# Separate optargs to long options (plugins may need this):
	--*=*)        func_split_equals "$_G_opt"
	              set dummy "$func_split_equals_lhs" \
                          "$func_split_equals_rhs" ${1+"$@"}
                      shift
                      ;;

       # Separate optargs to short options:
        -W*)
                      func_split_short_opt "$_G_opt"
                      set dummy "$func_split_short_opt_name" \
                          "$func_split_short_opt_arg" ${1+"$@"}
                      shift
                      ;;

        # Separate non-argument short options:
        -\?*|-h*|-v*|-x*)
                      func_split_short_opt "$_G_opt"
                      set dummy "$func_split_short_opt_name" \
                          "-$func_split_short_opt_arg" ${1+"$@"}
                      shift
                      ;;

        --)           _G_parse_options_requote=: ; break ;;
        -*)           func_fatal_help "unrecognised option: '$_G_opt'" ;;
        *)            set dummy "$_G_opt" ${1+"$@"}; shift
                      _G_match_parse_options=false
                      break
                      ;;
      esac

      if $_G_match_parse_options; then
        _G_parse_options_requote=:
      fi
    done

    if $_G_parse_options_requote; then
      # save modified positional parameters for caller
      func_quote eval ${1+"$@"}
      func_parse_options_result=$func_quote_result
    fi
}


# func_validate_options [ARG]...
# ------------------------------
# Perform any sanity checks on option settings and/or unconsumed
# arguments.
func_hookable func_validate_options
func_validate_options ()
{
    $debug_cmd

    # Display all warnings if -W was not given.
    test -n "$opt_warning_types" || opt_warning_types=" $warning_categories"

    func_run_hooks func_validate_options ${1+"$@"}
    func_propagate_result func_run_hooks func_validate_options

    # Bail if the options were screwed!
    $exit_cmd $EXIT_FAILURE
}



## ----------------- ##
## Helper functions. ##
## ----------------- ##

# This section contains the helper functions used by the rest of the
# hookable option parser framework in ascii-betical order.


# func_fatal_help ARG...
# ----------------------
# Echo program name prefixed message to standard error, followed by
# a help hint, and exit.
func_fatal_help ()
{
    $debug_cmd

    eval \$ECHO \""Usage: $usage"\"
    eval \$ECHO \""$fatal_help"\"
    func_error ${1+"$@"}
    exit $EXIT_FAILURE
}


# func_help
# ---------
# Echo long help message to standard output and exit.
func_help ()
{
    $debug_cmd

    func_usage_message
    $ECHO "$long_help_message"
    exit 0
}


# func_missing_arg ARGNAME
# ------------------------
# Echo program name prefixed message to standard error and set global
# exit_cmd.
func_missing_arg ()
{
    $debug_cmd

    func_error "Missing argument for '$1'."
    exit_cmd=exit
}


# func_split_equals STRING
# ------------------------
# Set func_split_equals_lhs and func_split_equals_rhs shell variables
# after splitting STRING at the '=' sign.
test -z "$_G_HAVE_XSI_OPS" \
    && (eval 'x=a/b/c;
      test 5aa/bb/cc = "${#x}${x%%/*}${x%/*}${x#*/}${x##*/}"') 2>/dev/null \
    && _G_HAVE_XSI_OPS=yes

if test yes = "$_G_HAVE_XSI_OPS"
then
  # This is an XSI compatible shell, allowing a faster implementation...
  eval 'func_split_equals ()
  {
      $debug_cmd

      func_split_equals_lhs=${1%%=*}
      func_split_equals_rhs=${1#*=}
      if test "x$func_split_equals_lhs" = "x$1"; then
        func_split_equals_rhs=
      fi
  }'
else
  # ...otherwise fall back to using expr, which is often a shell builtin.
  func_split_equals ()
  {
      $debug_cmd

      func_split_equals_lhs=`expr "x$1" : 'x\([^=]*\)'`
      func_split_equals_rhs=
      test "x$func_split_equals_lhs=" = "x$1" \
        || func_split_equals_rhs=`expr "x$1" : 'x[^=]*=\(.*\)$'`
  }
fi #func_split_equals


# func_split_short_opt SHORTOPT
# -----------------------------
# Set func_split_short_opt_name and func_split_short_opt_arg shell
# variables after splitting SHORTOPT after the 2nd character.
if test yes = "$_G_HAVE_XSI_OPS"
then
  # This is an XSI compatible shell, allowing a faster implementation...
  eval 'func_split_short_opt ()
  {
      $debug_cmd

      func_split_short_opt_arg=${1#??}
      func_split_short_opt_name=${1%"$func_split_short_opt_arg"}
  }'
else
  # ...otherwise fall back to using expr, which is often a shell builtin.
  func_split_short_opt ()
  {
      $debug_cmd

      func_split_short_opt_name=`expr "x$1" : 'x\(-.\)'`
      func_split_short_opt_arg=`expr "x$1" : 'x-.\(.*\)$'`
  }
fi #func_split_short_opt


# func_usage
# ----------
# Echo short help message to standard output and exit.
func_usage ()
{
    $debug_cmd

    func_usage_message
    $ECHO "Run '$progname --help |${PAGER-more}' for full usage"
    exit 0
}


# func_usage_message
# ------------------
# Echo short help message to standard output.
func_usage_message ()
{
    $debug_cmd

    eval \$ECHO \""Usage: $usage"\"
    echo
    $SED -n 's|^# ||
        /^Written by/{
          x;p;x
        }
	h
	/^Written by/q' < "$progpath"
    echo
    eval \$ECHO \""$usage_message"\"
}


# func_version
# ------------
# Echo version message to standard output and exit.
# The version message is extracted from the calling file's header
# comments, with leading '# ' stripped:
#   1. First display the progname and version
#   2. Followed by the header comment line matching  /^# Written by /
#   3. Then a blank line followed by the first following line matching
#      /^# Copyright /
#   4. Immediately followed by any lines between the previous matches,
#      except lines preceding the intervening completely blank line.
# For example, see the header comments of this file.
func_version ()
{
    $debug_cmd

    printf '%s\n' "$progname $scriptversion"
    $SED -n '
        /^# Written by /!b
        s|^# ||; p; n

        :fwd2blnk
        /./ {
          n
          b fwd2blnk
        }
        p; n

        :holdwrnt
        s|^# ||
        s|^# *$||
        /^Copyright /!{
          /./H
          n
          b holdwrnt
        }

        s|\((C)\)[ 0-9,-]*[ ,-]\([1-9][0-9]* \)|\1 \2|
        G
        s|\(\n\)\n*|\1|g
        p; q' < "$progpath"

    exit $?
}


# Local variables:
# mode: shell-script
# sh-indentation: 2
# eval: (add-hook 'before-save-hook 'time-stamp)
# time-stamp-pattern: "30/scriptversion=%:y-%02m-%02d.%02H; # UTC"
# time-stamp-time-zone: "UTC"
# End:
#! /bin/sh

# Extract macro arguments from autotools input with GNU M4.
# Written by Gary V. Vaughan, 2010
#
# This is free software.  There is NO warranty; not even for
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
#
# Copyright (C) 2010-2019, 2021, 2023-2024 Bootstrap Authors
#
# This file is dual licensed under the terms of the MIT license
# <https://opensource.org/licenses/MIT>, and GPL version 2 or later
# <https://www.gnu.org/licenses/gpl-2.0.html>.  You must apply one of
# these licenses when using or redistributing this software or any of
# the files within it.  See the URLs above, or the file `LICENSE`
# included in the Bootstrap distribution for the full license texts.

# Please report bugs or propose patches to:
# <https://github.com/gnulib-modules/bootstrap/issues>

# Make sure we've evaluated scripts we depend on.
test -z "$progpath" && . `echo "$0" |${SED-sed} 's|[^/]*$||'`/funclib.sh
test extract-trace = "$progname" && . `echo "$0" |${SED-sed} 's|[^/]*$||'`/options-parser

# Set a version string.
scriptversion=2019-02-19.15; # UTC


## ------ ##
## Usage. ##
## ------ ##

# Run './extract-trace --help' for help with using this script from the
# command line.
#
# Or source first 'options-parser' and then this file into your own
# scripts in order to make use of the function and variable framework
# they define, and also to avoid the overhead of forking to run this
# script in its own process on every call.



## ----------------- ##
## Helper functions. ##
## ----------------- ##

# This section contains the helper functions used by the rest of
# 'extract-trace'.


# func_autoconf_configure MAYBE-CONFIGURE-FILE
# --------------------------------------------
# Ensure that MAYBE-CONFIGURE-FILE is the name of a file in the current
# directory that contains an uncommented call to AC_INIT.
func_autoconf_configure ()
{
    $debug_cmd

    _G_sed_no_comment='
      s|#.*$||
      s|^dnl .*$||
      s| dnl .*$||'
    _G_ac_init=

    # If we were passed a genuine file, make sure it calls AC_INIT.
    test -f "$1" \
      && _G_ac_init=`$SED "$_G_sed_no_comment" "$1" |$GREP AC_INIT`

    # Otherwise it is not a genuine Autoconf input file.
    test -n "$_G_ac_init"
    _G_status=$?

    test 0 -ne "$_G_status" \
      && func_verbose "'$1' not using Autoconf"

    (exit $_G_status)
}


# func_tool_version_output CMD [FATAL-ERROR-MSG]
# ----------------------------------------------
# Attempt to run 'CMD --version', discarding errors.  The output can be
# ignored by redirecting stdout, and this function used simply to test
# whether the command exists and exits normally when passed a
# '--version' argument.
# When FATAL-ERROR-MSG is given, then this function will display the
# message and exit if running 'CMD --version' returns a non-zero exit
# status.
func_tool_version_output ()
{
    $debug_cmd

    _G_cmd=$1
    _G_fatal_error_msg=$2

    # Some tools, like 'git2cl' produce thousands of lines of output
    # unless stdin is /dev/null - in that case we want to return
    # successfully without saving all of that output.  Other tools,
    # such as 'help2man' exit with a non-zero status when stdin comes
    # from /dev/null, so we re-execute without /dev/null if that
    # happens.  This means that occasionally, the output from both calls
    # ends up in the result, but the alternative would be to discard the
    # output from one call, and hope the other produces something useful.
    { $_G_cmd --version </dev/null || $_G_cmd --version; } 2>/dev/null
    _G_status=$?

    test 0 -ne "$_G_status" && test -n "$_G_fatal_error_msg" \
        && func_fatal_error "$_G_fatal_error_msg"

    (exit $_G_status)
}


# func_tool_version_number CMD [FATAL-ERROR-MSG]
# ----------------------------------------------
# Pass arguments to func_tool_version_output, but set
# $func_tool_version_number_result to the last dot delimited digit string
# on the first line of output.
func_tool_version_number ()
{
    $debug_cmd

    _G_verout=`func_tool_version_output "$@"`
    _G_status=$?

    # A version number starts with a digit following a space on the first
    # line of output from `--version`.
    _G_verout=`echo "$_G_verout" |sed 1q`
    if test -n "$_G_verout"; then
      _G_vernum=`expr "$_G_verout" : '.* \([0-9][^ ]*\)'`
    fi

    if test -n "$_G_vernum"; then
      printf '%s\n' "$_G_vernum"
    else
      printf '%s\n' "$_G_verout"
    fi

    (exit $_G_status)
}


# func_find_tool ENVVAR NAMES...
# ------------------------------
# Search for a required program.  Use the value of ENVVAR, if set,
# otherwise find the first of the NAMES that can be run (i.e.,
# supports --version).  If found, set ENVVAR to the program name,
# die otherwise.
func_find_tool ()
{
    $debug_cmd

    _G_find_tool_envvar=$1
    shift
    _G_find_tool_names=$@
    eval "_G_find_tool_res=\$$_G_find_tool_envvar"
    if test -n "$_G_find_tool_res"; then
      _G_find_tool_error_prefix="\$$find_tool_envvar: "
    else
      _G_find_tool_res=
      _G_bestver=
      for _G_prog
      do
        _G_find_tool_save_IFS=$IFS
        IFS=${PATH_SEPARATOR-:}
	for _G_dir in $PATH; do
	  IFS=$_G_find_tool_save_IFS
	  _G_progpath=$_G_dir/$_G_prog
          test -r "$_G_progpath" && {
            _G_curver=`func_tool_version_number $_G_progpath`
	    case $_G_bestver,$_G_curver in
	    ,)
	      # first non--version responsive prog sticks!
              test -n "$_G_progpath" || _G_find_tool_res=$_G_progpath
              ;;
            ,*)
	      # first --version responsive prog beats non--version responsive!
	      _G_find_tool_res=$_G_progpath
	      _G_bestver=$_G_curver
	      ;;
	    *,*)
	      # another --version responsive prog must be newer to beat previous one!
	      test "x$_G_curver" = "x$_G_bestver" \
		|| func_lt_ver "$_G_curver" "$_G_bestver" \
		|| {
		     _G_find_tool_res=$_G_progpath
		     _G_bestver=$_G_curver
	           }
	      ;;
	    esac
          }
	done
	IFS=$_G_find_tool_save_IFS
      done
    fi
    if test -n "$_G_find_tool_res"; then
      func_tool_version_number >/dev/null $_G_find_tool_res "\
${_G_find_tool_error_prefix}Cannot run '$_G_find_tool_res --version'"

      # Make sure the result is exported to the environment for children
      # to use.
      eval "$_G_find_tool_envvar=\$_G_find_tool_res"
      eval "export $_G_find_tool_envvar"
    else
      func_error "\
One of these is required:
       $_G_find_tool_names"
    fi
}



## -------------------- ##
## Resource management. ##
## -------------------- ##

# This section contains definitions for functions that each ensure a
# particular resource (a file, or a non-empty configuration variable for
# example) is available, and if appropriate to extract default values
# from pertinent package files.  Where a variable already has a non-
# empty value (as set by the package's 'bootstrap.conf'), that value is
# used in preference to deriving the default. Call them using their
# associated 'require_*' variable to ensure that they are executed, at
# most, once.
#
# It's entirely deliberate that calling these functions can set
# variables that don't obey the namespace limitations obeyed by the rest
# of this file, in order that that they be as useful as possible to
# callers.


# require_configure_ac
# --------------------
# Ensure that there is a 'configure.ac' or 'configure.in' file in the
# current directory that contains an uncommented call to AC_INIT, and
# that '$configure_ac' contains its name.
require_configure_ac=func_require_configure_ac
func_require_configure_ac ()
{
    $debug_cmd

    test -z "$configure_ac" \
      && func_autoconf_configure configure.ac && configure_ac=configure.ac
    test -z "$configure_ac" \
      && func_autoconf_configure configure.in && configure_ac=configure.in
    test -z "$configure_ac" \
      || func_verbose "found '$configure_ac'"

    require_configure_ac=:
}


# require_gnu_m4
# --------------
# Search for GNU M4, and export it in $M4.
require_gnu_m4=func_require_gnu_m4
func_require_gnu_m4 ()
{
    $debug_cmd

    test -n "$M4" || {
      # Find the first m4 binary that responds to --version.
      func_find_tool M4 gm4 gnum4 m4
    }

    test -n "$M4" || func_fatal_error "\
Please install GNU M4, or 'export M4=/path/to/gnu/m4'."

    func_verbose "export M4='$M4'"

    # Make sure the search result is visible to subshells
    export M4

    require_gnu_m4=:
}


## --------------- ##
## Core functions. ##
## --------------- ##

# This section contains the high level functions used when calling this
# file as a script. 'func_extract_trace' is probably the only one that you
# won't want to replace if you source this file into your own script.


# func_extract_trace MACRO_NAMES [FILENAME]...
# --------------------------------------------
# set '$func_extract_trace_result' to a colon delimited list of arguments
# to any of the comma separated list of MACRO_NAMES in FILENAME. If no
# FILENAME is given, then '$configure_ac' is assumed.
func_extract_trace ()
{
    $debug_cmd

    $require_configure_ac
    $require_gnu_m4

    _G_m4_traces=`$ECHO "--trace=$1" |$SED 's%,% --trace=%g'`
    _G_re_macros=`$ECHO "($1)" |$SED 's%,%|%g'`
    _G_macros="$1"; shift
    test $# -gt 0 || {
      set dummy $configure_ac
      shift
    }

    # Generate an error if the first file is missing
    <"$1"

    # Sadly, we can't use 'autom4te' tracing to extract macro arguments,
    # because it complains about things we want to ignore at bootstrap
    # time - like missing m4_include files; AC_PREREQ being newer than
    # the installed autoconf; and returns nothing when tracing
    # 'AM_INIT_AUTOMAKE' when aclocal hasn't been generated yet.
    #
    # The following tries to emulate a less persnickety version of (and
    # due to not having to wait for Perl startup on every invocation,
    # it's probably faster too):
    #
    #    autom4te --language=Autoconf --trace=$my_macro:\$% "$@"
    #
    # First we give a minimal set of macro declarations to M4 to prime
    # it for reading Autoconf macros, while still providing some of the
    # functionality generally used at m4-time to supply dynamic
    # arguments to Autocof functions, but without following
    # 'm4_s?include' files.
    _G_mini='
        dnl  Initialisation.
        m4_changequote([,])
        m4_define([m4_copy],   [m4_define([$2], m4_defn([$1]))])
        m4_define([m4_rename], [m4_copy([$1], [$2])m4_undefine([$1])])

        dnl  Replace macros which may abort m4 with a no-op variant.
        m4_pushdef([m4_assert])
        m4_pushdef([m4_exit])
        m4_pushdef([m4_fatal])
        m4_pushdef([m4_m4exit])

        dnl  Replace macros that might break stderr of m4.
        m4_pushdef([m4_errprint])
        m4_pushdef([m4_errprintn])
        m4_pushdef([m4_include])
        m4_pushdef([m4_warn])

        dnl  Avoid side-effects of tracing by extract-trace.
        m4_pushdef([m4_maketemp])
        m4_pushdef([m4_mkstemp])

        dnl  TODO: reasons for this
        m4_pushdef([m4_dnl])
        m4_pushdef([m4_m4wrap])

        dnl  Copy and rename macros not handled by "m4 --prefix".
        m4_define([dnl],         [m4_builtin([dnl])])
        m4_copy([m4_define],     [m4_defun])
        m4_rename([m4_ifelse],   [m4_if])
        m4_rename([m4_patsubst], [m4_bpatsubst])
        m4_rename([m4_regexp],   [m4_bregexp])

        dnl  "m4sugar.mini" - useful m4-time macros for dynamic arguments.
        dnl  If we discover packages that need more m4 macros defined in
        dnl  order to bootstrap correctly, add them here:
        m4_define([m4_bmatch],
            [m4_if([$#], 0, [], [$#], 1, [], [$#], 2, [$2],
                   [m4_if(m4_bregexp([$1], [$2]), -1,
                          [$0([$1], m4_shift3($@))], [$3])])])
        m4_define([m4_ifndef], [m4_ifdef([$1], [$3], [$2])])
        m4_define([m4_ifset],
            [m4_ifdef([$1], [m4_ifval(m4_defn([$1]), [$2], [$3])], [$3])])
        m4_define([m4_require], [$1])
        m4_define([m4_shift3], [m4_shift(m4shift(m4shift($@)))])

        dnl  "autoconf.mini" - things from autoconf macros we care about.
        m4_copy([m4_defun], [AC_DEFUN])

        dnl  Dummy definitions for the macros we want to trace.
        dnl  AM_INIT_AUTOMAKE at least produces no trace without this.
    '

    _G_save=$IFS
    IFS=,
    for _G_macro in $_G_macros; do
      IFS=$_G_save
      func_append _G_mini "AC_DEFUN([$_G_macro])$nl"
    done
    IFS=$_G_save

    # We discard M4's stdout, but the M4 trace output from reading our
    # "autoconf.mini" followed by any other files passed to this
    # function is then scanned by sed to transform it into a colon
    # delimited argument list assigned to a shell variable.
    _G_transform='s|#.*$||; s|^dnl .*$||; s| dnl .*$||;'

    # Unfortunately, alternation in regexp addresses doesn't work in at
    # least BSD (and hence Mac OS X) sed, so we have to append a capture
    # and print block for each traced macro to the sed transform script.
    _G_save=$IFS
    IFS=,
    for _G_macro in $_G_macros; do
      IFS=$_G_save
      func_append _G_transform '
        /^m4trace: -1- '"$_G_macro"'/ {
          s|^m4trace: -1- '"$_G_macro"'[([]*||
          s|], [[]|:|g
          s|[])]*$|:|
          s|\(.\):$|\1|
          p
        }'
    done
    IFS=$_G_save

    # Save the command pipeline results for further use by callers of
    # this function.
    func_extract_trace_result=`$ECHO "$_G_mini" \
      |$M4 -daq --prefix $_G_m4_traces - "$@" 2>&1 1>/dev/null \
      |$SED -n -e "$_G_transform"`
}


# func_extract_trace_first MACRO_NAMES [FILENAME]...
# --------------------------------------------------
# Exactly like func_extract_trace, except that only the first argument
# to the first invocation of one of the comma separated MACRO_NAMES is
# returned in '$func_extract_trace_first_result'.
func_extract_trace_first ()
{
    $debug_cmd

    func_extract_trace ${1+"$@"}
    func_extract_trace_first_result=`$ECHO "$func_extract_trace_result" \
      |$SED -e 's|:.*$||g' -e 1q`
}


# func_main [ARG]...
# ------------------
func_main ()
{
    $debug_cmd

    # Configuration.
    usage='$progname MACRO_NAME FILE [...]'

    long_help_message='
The first argument to this program is the name of an autotools macro
whose arguments you want to extract by examining the files listed in the
remaining arguments using the same tool that Autoconf and Automake use,
GNU M4.

The arguments are returned separated by colons, with each traced call
on a separate line.'

    # Option processing.
    func_options "$@"
    eval set dummy "$func_options_result"; shift

    # Validate remaining non-option arguments.
    test $# -gt 1 \
        || func_fatal_help "not enough arguments"

    # Pass non-option arguments to extraction function.
    func_extract_trace "$@"

    # Display results.
    test -n "$func_extract_trace_result" \
        && $ECHO "$func_extract_trace_result"

    # The End.
    exit $EXIT_SUCCESS
}


## --------------------------- ##
## Actually perform the trace. ##
## --------------------------- ##

# Only call 'func_main' if this script was called directly.
test extract-trace = "$progname" && func_main "$@"

# Local variables:
# mode: shell-script
# sh-indentation: 2
# eval: (add-hook 'before-save-hook 'time-stamp)
# time-stamp-pattern: "50/scriptversion=%:y-%02m-%02d.%02H; # UTC"
# time-stamp-time-zone: "UTC"
# End:

# Set a version string.
scriptversion='(GNU libtool) 2.5.4'

# func_version
# ------------
# Echo version message to standard output and exit.
func_version ()
{
    $debug_cmd

	year=`date +%Y`

	cat <<EOF
$progname $scriptversion
Copyright (C) $year Free Software Foundation, Inc.
License GPLv2+: GNU GPL version 2 or later <https://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.

Written by Gary V. Vaughan <gary@gnu.org>, 2003
EOF

    exit $?
}

## ---------------- ##
## Options parsing. ##
## ---------------- ##

# Hook in the functions to make sure our own options are parsed during
# the option parsing loop.

usage='$progpath [OPTION]...'

# Short help message in response to '-h'.
usage_message="Options:
   -c, --copy          copy files rather than symlinking them
       --debug         enable verbose shell tracing
   -n, --dry-run       print commands rather than running them
   -f, --force         replace existing files
   -i, --install       copy missing auxiliary files
       --ltdl[=DIR]    install libltdl sources [default: libltdl]
       --no-warnings   equivalent to '-Wnone'
       --nonrecursive  prepare ltdl for non-recursive make
   -q, --quiet         work silently
       --recursive     prepare ltdl for recursive make
       --subproject    prepare ltdl to configure and build independently
   -v, --verbose       verbosely report processing
       --version       print version information and exit
   -W, --warnings=CATEGORY
                       report the warnings falling in CATEGORY [all]
   -h, --help          print short or long help message
"

# Additional text appended to 'usage_message' in response to '--help'.
func_help ()
{
    $debug_cmd

    func_usage_message
    $ECHO "$long_help_message
       'environment'   show warnings about LIBTOOLIZE_OPTIONS content
       'file'          show warnings about file copying and linking

The following space or comma delimited options can be passed to $progname
via the environment variable LIBTOOLIZE_OPTIONS, unknown environment
options are ignored:

       --debug         enable verbose shell tracing
       --no-warnings   don't display warning messages
       --quiet         work silently
       --verbose       verbosely report processing

You must 'cd' to the top directory of your package before you run
'$progname'.

When reporting a bug, please describe a test case to reproduce it and
include the following information:

       host-triplet:   x86_64-pc-msys
       version:        $progname $scriptversion
       automake:       `($AUTOMAKE --version) 2>/dev/null |$SED 1q`
       autoconf:       `($AUTOCONF --version) 2>/dev/null |$SED 1q`

Report bugs to <bug-libtool@gnu.org>.
GNU libtool home page: <https://www.gnu.org/software/libtool/>.
General help using GNU software: <https://www.gnu.org/gethelp/>."
    exit 0
}

warning_categories='environment file'


# libtoolize_environment_options [ARG]...
# ---------------------------------------
# Parse environment options.
libtoolize_environment_options ()
{
    $debug_mode

    my_sed_env_opt='1s/^\([^,:; ]*\).*$/\1/;q'
    my_sed_env_rest='1s/^[^,:; ]*[,:; ]*\(.*\)$/\1/;q'

    while test -n "$LIBTOOLIZE_OPTIONS"; do
      opt=`echo "$LIBTOOLIZE_OPTIONS" | $SED "$my_sed_env_opt"`
      LIBTOOLIZE_OPTIONS=`echo "$LIBTOOLIZE_OPTIONS" | $SED "$my_sed_env_rest"`

      case $opt in
        --debug|--no-warn|--no-warning|--no-warnings|--quiet|--verbose)
		envopts="${envopts+$envopts }$opt"			  ;;
        --*)	env_warning="${env_warning+$env_warning
}unrecognized environment option '$opt'"				  ;;
        *)	func_fatal_help "garbled LIBTOOLIZE_OPTIONS near '$opt'"  ;;
      esac
    done

    # Pass back the updated list of options.
    if test -n "$envopts"; then
      func_quote eval "$envopts" ${1+"$@"}
    else
      func_quote eval ${1+"$@"}
    fi
    libtoolize_environment_options_result=$func_quote_result
}
func_add_hook func_options_prep libtoolize_environment_options


# libtoolize_options_prep [ARG]...
# --------------------------------
# Preparation for options parsed by libtoolize.
libtoolize_options_prep ()
{
    $debug_cmd

    # Option defaults:
    opt_copy=false
    opt_dry_run=false
    opt_force=false
    opt_install=false
    opt_ltdl=false
    opt_nonrecursive=false
    opt_quiet=false
    opt_recursive=false
    opt_subproject=false

    ltdl_mode=
}
func_add_hook func_options_prep libtoolize_options_prep


# libtoolize_parse_options [ARG]...
# ---------------------------------
# Provide handling for libtoolize specific options.
libtoolize_parse_options ()
{
    $debug_cmd

    # Perform our own loop to consume as many options as possible in
    # each iteration.
    while test $# -gt 0; do
      _G_opt=$1
      shift
      case $_G_opt in
        --copy|-c)	opt_copy=: ;;

        --dry-run|--dryrun|-n)
			$opt_dry_run || {
			  opt_dry_run=:
			  CP="func_echo_all $CP"
			  test -n "$LN_S" && LN_S="func_echo_all $LN_S"
			  MKDIR="func_echo_all $MKDIR"
			  RM="func_echo_all $RM"
			}
			;;

        --force|-f)	opt_force=: ;;

        --install|-i)	opt_install=: ;;

        --ltdl)		opt_ltdl=:
			if test 0 -lt $#; then
			  case $1 in
			    -*) ;;
			    *)  ltdl_dir=`$ECHO "$1" | $SED 's|/*$||'`
			        shift
			        ;;
			  esac
			fi
			;;

        --nonrecursive|--non-recursive)
			opt_nonrecursive=:
			;;

        --quiet|--automake|-q) # --automake is for 1.5 compatibility
			opt_quiet=: ;;

        --recursive)	opt_recursive=: ;;

        --subproject)	opt_subproject=: ;;

        # Separate non-argument short options:
        -c*|-f*|-i*|-n*|-q*)
			func_split_short_opt "$_G_opt"
			set dummy "$func_split_short_opt_name" \
			    "-$func_split_short_opt_arg" ${1+"$@"}
			shift
			;;

	# An option not handled by this hook function:
        *)		set dummy "$_G_opt" ${1+"$@"}; shift; break ;;
      esac
    done

    # save modified positional parameters for caller
    func_quote eval ${1+"$@"}
    libtoolize_parse_options_result=$func_quote_result
}
func_add_hook func_parse_options libtoolize_parse_options


# libtoolize_validate_options [ARG]...
# ------------------------------------
# Perform any sanity checks on option settings and/or unconsumed
# arguments.
libtoolize_validate_options ()
{
    # show any warnings saved by LIBTOOLIZE_OPTIONS parsing
    test -n "$env_warning" && func_warning environment "$env_warning"

    # validate $opt_nonrecursive, $opt_recursive and $opt_subproject
    if $opt_nonrecursive; then
      if $opt_recursive || $opt_subproject; then
        func_error "you can have at most one of --non-recursive, --recursive and --subproject"
      fi
      ltdl_mode=nonrecursive
    elif $opt_recursive; then
      $opt_subproject &&
        func_error "you can have at most one of --non-recursive, --recursive and --subproject"
      ltdl_mode=recursive
    elif $opt_subproject; then
      ltdl_mode=subproject
    fi

    # any remaining arguments are an error
    test 0 -lt $# &&
      func_fatal_help "unknown additional arguments: '${1+$@}'"

    # Pass back the empty argument list
    func_quote eval ${1+"$@"}
    libtoolize_validate_options_result=$func_quote_result
}
func_add_hook func_validate_options libtoolize_validate_options


# Process options as early as possible so that --help and --version
# can return quickly.
func_options ${1+"$@"}
eval set dummy "$func_options_result"; shift


# func_notquiet_once MSG_VAR
# --------------------------
# Call func_notquiet with the value of MSG_VAR, and then set MSG_VAR='' so
# that subsequent calls will have no effect.
func_notquiet_once ()
{
    $debug_cmd

    if test -n "$1"; then
      eval my_msg=\$$1

      if test -n "$my_msg"; then
        func_notquiet "$my_msg"
        eval $1=
      fi
    fi
}


# func_notquiet_hdr MSG_VAR ARG...
# --------------------------------
# With at least 1 non-empty ARG, call func_notquiet_once with MSG_VAR,
# and then func_notquiet with the remaining arguments.
func_notquiet_hdr ()
{
    $debug_cmd

    my_msg_var=$1; shift
    test -n "$*" || return

    func_notquiet_once "$my_msg_var"
    func_notquiet "$*"
}


# func_notquiet_error_hdr MSG_VAR ARG...
# --------------------------------------
# Much the same as func_notquiet_header, but for (non-fatal) error
# messages.
func_notquiet_error_hdr ()
{
    $debug_cmd

    my_msg_var=$1; shift
    test -n "$*" || return

    func_notquiet_once "$my_msg_var"
    func_error "$*"

    exit_status=$EXIT_FAILURE
}


# func_copy FILENAME SRCDIR DESTDIR [MSG_VAR [FILTER]]
# ----------------------------------------------------
# If option '--copy' was specified, or soft-linking SRCFILE to DESTFILE
# fails, then try to copy SRCFILE to DESTFILE (making sure to update the
# timestamp so that a series of files with dependencies can be copied
# in the right order that their timestamps won't trigger rebuilds). If
# FILTER is non-empty, it is a sed script to apply to SRCFILE as it is
# copied.  MSG_VAR names a variable for use with func_notquiet_hdr.
func_copy ()
{
    $debug_cmd

    my_filename=$1
    my_srcdir=$2
    my_destdir=$3
    my_msg_var=$4
    my_filter=$5

    my_srcfile=$my_srcdir/$my_filename
    my_destfile=$my_destdir/$my_filename

    # Libtool is probably misinstalled if this happens:
    test -f "$my_srcfile" || {
      func_notquiet_error_hdr "$my_msg_var" "'$my_srcfile' not found"
      return 1
    }

    # Require --force to remove existing $my_destfile.
    $opt_force && $RM "$my_destfile"
    test -f "$my_destfile" && {
      func_notquiet_error_hdr "$my_msg_var" \
        "'$my_destfile' exists: use '--force' to overwrite"
      return 1
    }

    # Be careful to support 'func_copy dir/target srcbase destbase'.
    func_dirname "$my_destfile"
    func_mkdir_p "$func_dirname_result"

    # Filters always take priority.
    if test -n "$my_filter"; then
      if $opt_dry_run || $SED -e "$my_filter" "$my_srcfile" > "$my_destfile" 2>/dev/null
      then
        func_notquiet_once "$my_msg_var"
        if $opt_verbose; then
          func_notquiet "$SED -e '$my_filter' $my_srcfile > $my_destfile"
         else
          func_notquiet "creating file '$my_destfile'"
         fi
      else
        func_notquiet_error_hdr "$my_msg_var" "creating '$my_destfile' from '$my_srcfile' failed"
        return 1
      fi
      return 0
    fi

    # Otherwise copy or link according to '--copy' option.
    if $opt_copy; then
      my_copycmd=$CP
      my_copy_type=copying
    else
      my_copycmd=$LN_S
      my_copy_type=linking
    fi
    my_copy_msg="$my_copy_type file '$my_destfile'"
    $opt_verbose && my_copy_msg="$my_copycmd $my_srcfile $my_destdir"

    if $opt_dry_run || $my_copycmd "$my_srcfile" "$my_destfile" 2>/dev/null
    then
      func_notquiet_hdr "$my_msg_var" "$my_copy_msg"
    else
      func_notquiet_error_hdr "$my_msg_var" \
        "$my_copy_type '$my_srcdir/$my_filename' to '$my_destdir/' failed"
      return 1
    fi
}


# func_included_files SEARCHFILE
# ------------------------------
# Output INCLUDEFILE if SEARCHFILE m4_includes it, else output SEARCHFILE.
func_included_files ()
{
    $debug_cmd

    my_searchfile=$1

    my_include_regex=
    my_sed_include='
        /^m4_include(\[.*\])$/ {
	    s|^m4_include(\[\(.*\)\])$|\1|
	    p
	}
        d'

    if test -f "$my_searchfile"; then
      $ECHO "$my_searchfile"

      # Only recurse when we don't care if all the variables we use get
      # trashed, since they are in global scope.
      for my_filename in `$SED "$my_sed_include" "$my_searchfile"`; do
	func_included_files $my_filename
      done
    fi
}


# func_serial FILENAME [MACRO_REGEX]
# ----------------------------------
# Output the value of the serial number comment in FILENAME, where the
# comment line must also match MACRO_REGEX, if given.
func_serial ()
{
    $debug_cmd

    my_filename=$1
    my_macro_regex=$2
    my_sed_serial='
	/^# serial [1-9][0-9.]*[	 ]*'"$my_macro_regex"'[	 ]*$/ {
	    s|^# serial \([1-9][0-9.]*\).*$|\1|
	    q
	}
	d'

    # Search FILENAME and all the files it m4_includes for a serial number
    # in the file that AC_DEFUNs MACRO_REGEX.
    my_serial=
    func_dirname_and_basename "$my_filename"
    my_filebase=$func_basename_result
    for my_file in `func_included_files "$my_filename"`; do
      if test -z "$my_macro_regex" ||
         test aclocal.m4 = "$my_filename" ||
         test "X$my_macro_regex" = "X$my_filebase" ||
         func_grep '^AC_DEFUN(\['"$my_macro_regex" "$my_file"
      then
        my_serial=`$SED -e "$my_sed_serial" "$my_file"`
	break
      fi
    done

    # If the file has no serial number, we assume it's ancient.
    test -n "$my_serial" || my_serial=0

    $ECHO "$my_serial"
}


# func_serial_max SERIAL1 SERIAL2
# -------------------------------
# Compare (possibly multi-part, '.' delimited) serial numbers, and
# return the largest in $func_serial_max_result.  If they are the
# same, func_serial_max_result will be empty.
func_serial_max ()
{
    $debug_cmd

    my_serial1=$1
    my_serial2=$2

    my_sed_dot='s/\..*$//g'
    my_sed_rest='s/^[0-9][1-9]*\.*//'
    my_sed_digits='s/[^0-9.]//g'

    # In case they turn out to be the same, we'll set it to empty
    func_serial_max_result=

    test "X$1$2" = X`$ECHO "$1$2" | $SED "$my_sed_digits"` || {
      func_error "serial numbers '$1' or '$2' contain non-digit chars"
      return
    }

    while test -n "$my_serial1$my_serial2"; do
      my_serial1_part=`$ECHO "$my_serial1" | $SED "$my_sed_dot"`
      my_serial2_part=`$ECHO "$my_serial2" | $SED "$my_sed_dot"`

      test -z "$my_serial1_part$my_serial2_part" \
        && break

      test -z "$my_serial1_part" \
        && { func_serial_max_result=$2; break; }

      test -z "$my_serial2_part" \
        && { func_serial_max_result=$1; break; }

      test "$my_serial1_part" -gt "$my_serial2_part" \
        && { func_serial_max_result=$1; break; }

      test "$my_serial2_part" -gt "$my_serial1_part" \
        && { func_serial_max_result=$2; break; }

      my_serial1=`$ECHO "$my_serial1" | $SED "$my_sed_rest"`
      my_serial2=`$ECHO "$my_serial2" | $SED "$my_sed_rest"`
    done
}


# func_serial_update_check SRCFILE SRC_SERIAL DESTFILE DEST_SERIAL
# ----------------------------------------------------------------
# Unless SRC_SERIAL is newer than DEST_SERIAL set $func_serial_update_check
# to 'false'.
func_serial_update_check ()
{
    $debug_cmd

    $require_ac_ltdl_dir
    $require_ac_macro_dir

    my_srcfile=$1
    my_src_serial=$2
    my_destfile=$3
    my_dest_serial=$4
    my_update_p=:

    if test -f "$my_destfile"; then
      test 0 = "$my_src_serial" && {
        func_warning file "no serial number on '$my_srcfile', not copying."
	return
      }

      # Determine whether the destination has an older serial.
      func_serial_max "$my_src_serial" "$my_dest_serial"
      test "X$my_src_serial" = "X$func_serial_max_result" || my_update_p=false

      test "X$my_src_serial" = "X$func_serial_max_result" \
        && func_verbose "'$my_srcfile' is serial $my_src_serial, greater than $my_dest_serial in '$my_destfile'"

      if test "X$my_dest_serial" = "X$func_serial_max_result"; then
        func_verbose "'$my_srcfile' is serial $my_src_serial, less than $my_dest_serial in '$my_destfile'"
	$opt_force || if test -n "$ac_macro_dir$ac_ltdl_dir"; then
           func_error "'$my_destfile' is newer: use '--force' to overwrite"
        fi
      fi
    fi

    func_serial_update_check_result=$my_update_p
}


# func_aclocal_update_check FILENAME
# ----------------------------------
# Unless serial number of FILENAME is newer than the matching serial number
# in aclocal.m4, set $func_aclocal_update_check to 'false'.
func_aclocal_update_check ()
{
    $debug_cmd

    my_filename=$1

    my_srcfile=$aclocaldir/$1
    my_destfile=aclocal.m4

    case $my_filename in
      libtool.m4)
	my_src_serial=`func_serial "$my_srcfile" LT_INIT`
	my_dest_serial=`func_serial "$my_destfile" LT_INIT`

	# Strictly, this libtoolize ought not to have to deal with ancient
	# serial formats, but we accept them here to be complete:
	test 0 = "$my_src_serial" &&
	  my_src_serial=`func_serial "$my_srcfile" 'A[CM]_PROG_LIBTOOL'`
	test 0 = "$my_dest_serial" &&
	  my_dest_serial=`func_serial "$my_destfile" 'A[CM]_PROG_LIBTOOL'`
	;;
      ltdl.m4)
	my_src_serial=`func_serial "$my_srcfile" LTDL_INIT`
	my_dest_serial=`func_serial "$my_destfile" LTDL_INIT`
	;;
      *)
	my_src_serial=`func_serial "$my_srcfile" "$my_filename"`
	my_dest_serial=`func_serial "$my_destfile" "$my_filename"`
	;;
    esac

    func_serial_update_check \
      "$my_srcfile" "$my_src_serial" "$my_destfile" "$my_dest_serial"

    func_aclocal_update_check_result=$func_serial_update_check_result
}


# func_serial_update FILENAME SRCDIR DESTDIR [MSG_VAR] [MACRO_RE] [OLD_MACRO_RE]
# ------------------------------------------------------------------------------
# Copy the FILENAME from a SRCDIR to DESTDIR provided that either FILENAME
# has a newer serial number, or DESTFILE does not yet exist, or the user
# specified '--force' at the command line.  If given, MACRO_REGEX or
# OLD_MACRO_REGEX must match any text after "# serial N" in both files.
func_serial_update ()
{
    $debug_cmd

    my_filename=$1
    my_srcdir=$2
    my_destdir=$3
    my_msg_var=$4
    my_macro_regex=$5
    my_old_macro_regex=$6

    my_serial_update_p=:
    my_return_status=1
    my_srcfile=$my_srcdir/$my_filename
    my_destfile=$my_destdir/$my_filename

    test -f "$my_srcfile" || func_fatal_error "'$my_srcfile' does not exist."

    my_src_serial=
    my_dest_serial=
    if test -f "$my_destfile"; then
      my_src_serial=`func_serial "$my_srcfile" "$my_macro_regex"`
      my_dest_serial=`func_serial "$my_destfile" "$my_macro_regex"`

      # Strictly, this libtoolize ought not to have to deal with ancient
      # serial formats, but we accept them here to be complete:
      test 0 = "$my_src_serial" &&
        my_src_serial=`func_serial "$my_srcfile" "$my_old_macro_regex"`

      test 0 = "$my_dest_serial" &&
        my_dest_serial=`func_serial "$my_destfile" "$my_old_macro_regex"`

      func_serial_update_check \
        "$my_srcfile" "$my_src_serial" "$my_destfile" "$my_dest_serial"
      my_serial_update_p=$func_serial_update_check_result
    fi

    if $my_serial_update_p || $opt_force; then
      $RM "$my_destfile"
      func_copy "$my_filename" "$my_srcdir" "$my_destdir" "$my_msg_var"
      my_return_status=$?
    elif $opt_force && test "X$my_dest_serial" = "X$my_src_serial"; then
      func_notquiet_hdr "$my_msg_var" "'$my_destfile' is already up to date."
    fi

    # Do this after the copy for hand maintained 'aclocal.m4', in case
    # it has 'm4_include([DESTFILE])', so the copy effectively already
    # updated 'aclocal.m4'.
    my_included_files=`func_included_files aclocal.m4`
    case `echo " "$my_included_files" "` in

      # Skip included files:
      *" $my_destfile "*) ;;

      # Otherwise compare to aclocal.m4 serial number (func_serial
      # returns 0 for older macro serial numbers before we provided
      # serial tags, so the update message will be correctly given
      # if aclocal.m4 contains an untagged --i.e older-- macro file):
      *)
        if test -f aclocal.m4 && test '' != "$my_src_serial"; then
          func_serial_max \
              "$my_src_serial" `func_serial aclocal.m4 "$my_macro_regex"`
          if test "X$my_src_serial" = "X$func_serial_max_result"; then
	      func_notquiet_hdr "$my_msg_var" \
                "You should add the contents of '$my_destfile' to 'aclocal.m4'."
          fi
        fi
        ;;
    esac
    return $my_return_status
}


# func_keyword_update FILENAME SRCDIR DESTDIR SED_SCRIPT [MSG_VAR]
# ----------------------------------------------------------------
# Copy the FILENAME from a SRCDIR to DESTDIR provided that either FILENAME
# has a newer revision according to the serial number extracted by
# SED_SCRIPT, or DESTFILE does not yet exist, or the user specified
# '--force' at the command line.
func_keyword_update ()
{
    $debug_cmd

    my_filename=$1
    my_srcdir=$2
    my_destdir=$3
    my_sed_script=$4
    my_msg_var=$5

    my_srcfile=$my_srcdir/$my_filename
    my_destfile=$my_destdir/$my_filename

    my_keyword_update_p=:

    test -f "$my_srcfile" || func_fatal_error "'$my_srcfile' does not exist."

    if test -f "$my_destfile"; then
      my_src_serial=`$SED -e "$my_sed_script" "$my_srcfile"`
      test -z "$my_src_serial" && {
        func_warning file "no serial number in '$my_srcfile', not copying."
	return
      }

      my_dest_serial=`$SED -e "$my_sed_script" "$my_destfile"`
      test -n "$my_dest_serial" || my_dest_serial=0

      func_serial_update_check \
         "$my_srcfile" "$my_src_serial" "$my_destfile" "$my_dest_serial"
      my_keyword_update_p=$func_serial_update_check_result
    fi

    if $my_keyword_update_p || $opt_force; then
      $RM "$my_destfile"
      func_copy "$my_filename" "$my_srcdir" "$my_destdir" "$my_msg_var"
    elif $opt_verbose || $opt_force && test "X$my_dest_serial" = "X$my_src_serial"; then
      func_notquiet_hdr "$my_msg_var" "'$my_destfile' is already up to date."
    fi
}


# func_ltmain_update FILENAME SRCDIR DESTDIR [MSG_VAR]
# ----------------------------------------------------
# Copy the FILENAME from a SRCDIR to DESTDIR provided that either FILENAME
# has a newer revision, or DESTFILE does not yet exist, or the user
# specified '--force' at the command line.
func_ltmain_update ()
{
    $debug_cmd

    my_sed_ltmain='
	/^package_revision='\''*[0-9][1-9.]*'\''*/ {
	    s|^package_revision='\''*\([0-9.]*\)'\''*[	 ]*$|\1|
	    p
	}
	d'

    func_keyword_update "$1" "$2" "$3" "$my_sed_ltmain" "$4"

    return $my_return_status
}


# func_config_update FILENAME SRCDIR DESTDIR [MSG_VAR]
# ----------------------------------------------------
# Copy the FILENAME from a SRCDIR to DESTDIR provided that either FILENAME
# has a newer timestamp, or DESTFILE does not yet exist, or the user
# specified '--force' at the command line.
func_config_update ()
{
    $debug_cmd

    my_sed_config='
	/^timestamp='\''*[0-9][1-9-]*'\''*/ {
	    s|^timestamp='\''*\([0-9-]*\)'\''*|\1|
	    s|-|.|g
	    p
	}
	d'

    func_keyword_update "$1" "$2" "$3" "$my_sed_config" "$4"

    return $my_return_status
}


# func_install_update FILENAME SRCDIR DESTDIR [MSG_VAR]
# -----------------------------------------------------
# Copy the FILENAME from a SRCDIR to DESTDIR provided that either FILENAME
# has a newer timestamp, or DESTFILE does not yet exist, or the user
# specified '--force' at the command line.
func_install_update ()
{
    $debug_cmd

    my_sed_install='
	/^scriptversion='\''*[0-9][1-9.-]*'\''*/ {
	    s|[#;].*||
	    s|^scriptversion='\''*\([0-9.-]*\)'\''*|\1|
	    s|-|.|g
	    p
	}
	d'

    func_keyword_update "$1" "$2" "$3" "$my_sed_install" "$4"

    return $my_return_status
}


# func_install_pkgmacro_files
# ---------------------------
# Install copies of the libtool and libltdl m4 macros into this package.
func_install_pkgmacro_files ()
{
    $debug_cmd

    $require_ac_macro_dir
    $require_am_macro_dir
    $require_ltdl_mode
    $require_macro_dir

    $opt_ltdl || test -n "$ac_macro_dir$am_macro_dir" || return

    # Remove any lingering files that my have been installed by some
    # previous libtoolize release:
    $opt_force && for file in $all_pkgmacro_files; do
      test -f "$macro_dir/$file" && func_verbose "rm -f '$macro_dir/$file'"
      rm -f "$macro_dir/$file"
    done

    # Install the libltdl autoconf macros to this project's source tree.
    $opt_quiet || if test -n "$ac_macro_dir"; then
      my_pkgmacro_header="putting macros in AC_CONFIG_MACRO_DIRS, '$ac_macro_dir'."
    else
      my_pkgmacro_header="putting macros in '$macro_dir'."
    fi

    for file in $pkgmacro_files; do
      case $file in
        libtool.m4)
          func_serial_update "$file" "$aclocaldir" "$macro_dir" \
            my_pkgmacro_header LT_INIT 'A[CM]_PROG_LIBTOOL'
          ;;
        ltdl.m4)
          if $opt_ltdl; then
            func_serial_update "$file" "$aclocaldir" "$macro_dir" \
              my_pkgmacro_header 'LTDL_INIT'
          else
            func_verbose "Not copying '$macro_dir/$file', libltdl not used."
          fi
          ;;
        ltoptions.m4|ltsugar.m4|ltversion.m4|lt~obsolete.m4)
          func_serial_update "$file" "$aclocaldir" "$macro_dir" \
            my_pkgmacro_header "$file"
          ;;
        *)
          if $opt_ltdl; then
            func_serial_update "$file" "$aclocaldir" "$macro_dir" \
              my_pkgmacro_header "$file"
          else
            func_verbose "Not copying '$macro_dir/$file', libltdl not used."
          fi
          ;;
      esac
    done
}


# func_install_pkgltdl_files
# --------------------------
# Install copies of the libltdl files into this package.  Any auxiliary
# or m4 macro files needed in the libltdl tree will also be copied by
# func_install_pkgaux_files and func_install_pkgmacro_files resp.
func_install_pkgltdl_files ()
{
    $debug_cmd

    $opt_ltdl || return

    $require_ac_ltdl_dir
    $require_ltdl_dir
    $require_ltdl_mode

    # Remove any lingering files that my have been installed by some
    # previous libtoolize release:
    $opt_force && for file in $all_pkgltdl_files; do
      test -f "$ltdl_dir/$file" && func_verbose "rm -f '$ltdl_dir/$file'"
      rm -f "$ltdl_dir/$file"
    done

    # Copy all the files from installed libltdl to this project, if the
    # user specified '--ltdl'.
    $opt_quiet || if test -n "$ac_ltdl_dir"; then
      pkgltdl_header="putting libltdl files in LT_CONFIG_LTDL_DIR, '$ac_ltdl_dir'."
    else
      pkgltdl_header="putting libltdl files in '$ltdl_dir'."
    fi

    $require_filter_Makefile_am
    $require_filter_ltdl_mk

    # Copy ltdl sources appropriate to the requested ltdl_mode.
    for file in $pkgltdl_files; do
      my_copy_filter=
      case $file in
        Makefile.am|Makefile.in)
          test nonrecursive = "$ltdl_mode" && continue
          my_copy_filter=$filter_Makefile_am
          ;;

        ltdl.mk)
          test nonrecursive = "$ltdl_mode" || continue
          my_copy_filter=$filter_ltdl_mk
          ;;

        aclocal.m4)
          test subproject = "$ltdl_mode" && {
            $require_filter_aclocal_m4

            # Always copy aclocal.m4, otherwise regenerating it can
            # overwrite the destination if it is symlinked.
            ( opt_copy=:
              func_copy "$file" "$pkgltdldir" "$ltdl_dir" \
                pkgltdl_header "$filter_aclocal_m4"
            )
          }
          continue
	  ;;

        config-h.in)
          test subproject = "$ltdl_mode" && {
            # Always copy config-h.in, otherwise automake's autoheader rules
            # will change the destination's timestamp if it is symlinked.
            ( opt_copy=:
              func_copy "$file" "$pkgltdldir" "$ltdl_dir" \
                pkgltdl_header "$my_copy_filter"
            )
          }
          continue
          ;;

        configure)
          test subproject = "$ltdl_mode" && {
            $require_filter_configure_ac

            # Always copy configure, otherwise regenerating it can
            # overwrite the destination if it is symlinked.
            ( opt_copy=:
              func_copy "$file" "$pkgltdldir" "$ltdl_dir" \
                pkgltdl_header "$filter_configure_ac"
            )
          }
          continue
	  ;;

        configure.ac)
          test subproject = "$ltdl_mode" || continue
          $require_filter_configure_ac
          my_copy_filter=$filter_configure_ac
          ;;
      esac

      # Still here?  Copy the file then, with selected filters.
      func_copy "$file" "$pkgltdldir" "$ltdl_dir" \
        pkgltdl_header "$my_copy_filter"

      # FIXME: Remove in 2013
      #        (along with deprecation warning in func_check_macros)
      test ltdl.mk = "$file" \
        && func_grep "^-\?include $ltdl_dir/Makefile.inc\$" Makefile.am \
        && mv "$ltdl_dir/$file" "$ltdl_dir/Makefile.inc" \
        && func_notquiet "renaming file '$ltdl_dir/Makefile.inc'"
    done
}


# func_install_pkgaux_files
# -------------------------
# Install copies of the auxiliary files into this package according to
# the whether libltdl is included as a subproject, and whether the parent
# shares the AC_CONFIG_AUX_DIR setting.
func_install_pkgaux_files ()
{
    $debug_cmd

    $require_ac_aux_dir
    $require_aux_dir
    $require_configure_ac
    $require_ltdl_mode

    # Remove any lingering files that my have been installed by some
    # previous libtoolize release:
    $opt_force && for file in $all_pkgaux_files; do
      test -f "$aux_dir/$file" && func_verbose "rm -f '$aux_dir/$file'"
      rm -f "$aux_dir/$file"
    done

    if test -n "$ac_aux_dir"; then
      pkgaux_header="putting auxiliary files in AC_CONFIG_AUX_DIR, '$ac_aux_dir'."
    else
      pkgaux_header="putting auxiliary files in '$aux_dir'."
    fi

    for file in $pkgaux_files; do
      case $file in
        config.guess|config.sub)
          $opt_install || test subproject = "$ltdl_mode" || continue
          func_config_update "$file" "$pkgauxdir" "$aux_dir" pkgaux_header
          ;;
        install-sh)
          $opt_install || test subproject = "$ltdl_mode" || continue
          func_install_update "$file" "$pkgauxdir" "$aux_dir" pkgaux_header
          ;;
        ltmain.sh)
          func_ltmain_update "$file" "$pkgauxdir" "$aux_dir" pkgaux_header
          ;;
        *)
          test subproject = "$ltdl_mode" || continue
          func_copy "$file" "$pkgauxdir" "$aux_dir" pkgaux_header
          ;;
      esac
    done

    # If the parent project is using Autoconf and linking with Libtool,
    # even if subproject libltdl already has a copy, the parent project
    # will still need to build libtool for its own purposes, and might
    # need another copy of ltmain.sh if the parent didn't declare an
    # AC_CONFIG_AUX_DIR.
    pkgaux_hdr="putting another copy of auxiliary files in '.'"
    test -f "$configure_ac" \
      && test -z "$ac_aux_dir" \
      && test subproject = "$ltdl_mode" \
      && test "$aux_dir" = "$ltdl_dir" \
      && func_ltmain_update "$file" "$pkgauxdir" . pkgaux_hdr

    # FIXME: Remove in 2013.
    # Very old parent projects using 'libtoolize --install --ltdl', and
    # a top-level $configure_ac to build the ltdl subproject, but not
    # using Automake themselves, might still be relying on the old
    # behaviour of libtoolize to put a second copy of some 'Auxiliary
    # Programs' needed by the top-level configure (instead of using
    # the recommended method: 'automake --add-missing').
    test -f "$configure_ac" \
      && test subproject = "$ltdl_mode" \
      && test "$aux_dir" = "$ltdl_dir" \
      && func_config_update config.guess "$pkgauxdir" . pkgaux_hdr \
      && func_config_update config.sub "$pkgauxdir" . pkgaux_hdr \
      && func_install_update install-sh "$pkgauxdir" . pkgaux_hdr
}


# func_nonemptydir_p DIRVAR
# -------------------------
# DIRVAR is the name of a variable to evaluate.  Unless DIRVAR names
# a directory that exists and is non-empty abort with a diagnostic.
func_nonemptydir_p ()
{
    $debug_cmd

    my_dirvar=$1
    my_dir=`eval echo "\\\$$my_dirvar"`

    # Is it a directory at all?
    test -d "$my_dir" \
      || func_fatal_error "\$$my_dirvar is not a directory: '$my_dir'"

    # check that the directories contents can be ls'ed
    test -n "`{ cd $my_dir && ls; } 2>/dev/null`" \
        || func_fatal_error "cannot list files: '$my_dir'"
}


# func_check_macros
# -----------------
# Sanity check macros from aclocal.m4 against installed versions.
func_check_macros ()
{
    $debug_cmd

    $require_ac_ltdl_dir
    $require_ac_macro_dir
    $require_am_macro_dir
    $require_aux_dir
    $require_configure_ac
    $require_ltdl_dir
    $require_ltdl_mode
    $require_macro_dir
    $require_seen_ltdl
    $require_seen_libtool

    $opt_quiet && return
    test -n "$configure_ac" || return

    ac_config_macro_dir_advised=false

    if test -z "$ac_macro_dir$am_macro_dir"; then
      my_missing=
      for file in $pkgmacro_files; do
        case $file in
          ltargz.m4|ltdl.m4) $opt_ltdl || continue ;;
        esac
        if test -f "aclocal.m4"; then
          func_aclocal_update_check $file
          $func_aclocal_update_check_result || continue
        fi
        my_missing="$my_missing $file"
      done

      if test -n "$my_missing"; then
        func_echo "You should add the contents of the following files to 'aclocal.m4':"
        for need in $my_missing; do
	  func_echo "  '$aclocaldir/$need'"
        done
      fi
    fi

    ## ---------------------------------------------------------- ##
    ## Since we return early here when --no-warn was given:       ##
    ## DO NOT PUT ANYTHING BUT UPGRADE ADVICE MESSAGES BELOW HERE ##
    ## ---------------------------------------------------------- ##

    test " none" = "$opt_warning_types" && return

    $seen_libtool ||
      func_echo "Remember to add 'LT_INIT' to $configure_ac."

    # Suggest using LTDL_INIT if appropriate:
    $opt_ltdl && if test : != "$seen_ltdl"; then
      case $ltdl_mode in
	subproject) ltdl_init_args=                 ;;
	*)          ltdl_init_args="([$ltdl_mode])" ;;
      esac
      func_echo "Remember to add 'LTDL_INIT$ltdl_init_args' to $configure_ac."
    fi

    if $opt_ltdl; then
      # Remind the user to call LT_CONFIG_LTDL_DIR:
      test -n "$ac_ltdl_dir" ||
        func_echo "Remember to add 'LT_CONFIG_LTDL_DIR([$ltdl_dir])' to '$configure_ac'."

      # For nonrecursive mode, warn about continued use of Makefile.inc:
      # FIXME: Remove in 2013
      #        (along with last minute rename in func_install_pkgltdl_files)
      if test nonrecursive = "$ltdl_mode"; then
	if func_grep "^-\?include $ltdl_dir/Makefile.inc\$" Makefile.am;
	then
	  func_error "Use of 'include $ltdl_dir/Makefile.inc' is deprecated!"
	  func_echo "Consider updating to use of 'include $ltdl_dir/ltdl.mk' in Makefile.am."
	fi
      fi
    fi

    # Suggest modern idioms for storing autoconf macros:
    $ac_config_macro_dir_advised || if test -z "$macro_dir" || test . = "$macro_dir"; then
      func_echo "Consider adding 'AC_CONFIG_MACRO_DIRS([m4])' to $configure_ac and"
      func_echo "rerunning $progname, to keep the correct libtool macros in-tree."
      ac_config_macro_dir_advised=:

    elif test -z "$ac_macro_dir"; then
      func_echo "Consider adding 'AC_CONFIG_MACRO_DIRS([$macro_dir])' to $configure_ac,"
      func_echo "and rerunning $progname and aclocal."
      ac_config_macro_dir_advised=:
    fi

    if test -z "$am_macro_dir$ac_macro_dir"; then
      func_echo "Consider adding '-I m4' to ACLOCAL_AMFLAGS in Makefile.am."

    elif test -z "$am_macro_dir"; then
      func_echo "Consider adding '-I $macro_dir' to ACLOCAL_AMFLAGS in Makefile.am."
    fi

    # Don't trace for this, we're just checking the user didn't invoke it
    # directly from configure.ac.
    $SED 's|dnl .*$||; s|# .*$||' "$configure_ac" | $GREP AC_PROG_RANLIB >/dev/null &&
      func_echo "'AC_PROG_RANLIB' is rendered obsolete by 'LT_INIT'"

    # FIXME: Ensure ltmain.sh, libtool.m4 and ltdl.m4 are from the same release
}



## ------------------##
## Helper functions. ##
## ------------------##

# This section contains the helper functions used by the rest of
# this script.


# func_autoconf_configure MAYBE-CONFIGURE-FILE
# --------------------------------------------
# Ensure that MAYBE-CONFIGURE-FILE is the name of a file in the current
# directory that contains an uncommented call to AC_INIT.
func_autoconf_configure ()
{
    $debug_cmd

    _G_sed_no_comment='s|#.*$||; s|^dnl .*$||; s| dnl .*$||;'
    _G_ac_init=

    # If we were passed a genuine file, make sure it calls AC_INIT.
    test -f "$1" \
      && _G_ac_init=`$SED "$_G_sed_no_comment" "$1" |$GREP AC_INIT`

    # Otherwise it is not a genuine Autoconf input file.
    test -n "$_G_ac_init"
    _G_status=$?

    test 0 -ne "$_G_status" \
      && func_verbose "'$1' not using Autoconf"

    (exit $_G_status)
}


# func_make_relative_dir_filter CURRDIR SRCDIR DESTDIR [PREFIX [SUFFIX]]
# ----------------------------------------------------------------------
# Make a sed script suitable for appending to a copy filter, which will
# replace occurrences of CURRDIR with the relative path from SRCDIR to
# DESTDIR if they are different, otherwise the result is the empty
# string:
#
#    func_make_relative_dir_filter ltdl config ../build-aux
#      => 's|\.\./build-aux|../config|g'
#    func_make_relative_dir_filter ltdl ltdl/m4 ../m4
#      => 's|\.\./m4|m4|g'
#    func_make_relative_dir_filter libltdl build-aux ../build-aux
#      => ''
#
# If PREFIX (and SUFFIX) are passed they are prepended (and appended)
# to the match and replacement expressions literally:
#
#    func_make_relative_dir_filter ltdl ltdl/m4 ../m4 '-I ' ' '
#      => 's|-I \.\./m4 |-I m4 |g'
func_make_relative_dir_filter ()
{
    $debug_cmd

    my_currdir=$1
    my_srcdir=$2
    my_destdir=$3

    func_relative_path "$my_srcdir" "$my_destdir"

    if test "$my_currdir" = "$func_relative_path_result"; then
      func_make_relative_dir_filter_result=
    else
      my_match_currdir=`$ECHO "$my_currdir" |$SED "$sed_make_literal_regex"`

      # Avoid substituting with 'dir/./file' when current dir is '.'.
      if test . = "$my_currdir"; then
        func_make_relative_dir_filter_result="
          s|$4$my_match_currdir/$5|$4$5|g"
      else
        func_make_relative_dir_filter_result="
          s|$4$my_match_currdir$5|$4$func_relative_path_result$5|g"
      fi
    fi
}

# func_make_relative_ltdl_filter CURRDIR DESTDIR [PREFIX [SUFFIX]]
# ----------------------------------------------------------------
# As 'func_make_relative_dir_filter' optimised for the common case where
# SRCDIR is '$ltdl_dir'.
func_make_relative_ltdl_filter ()
{
    $debug_cmd

    $require_ltdl_dir

    func_make_relative_dir_filter "$1" "$ltdl_dir" "$2" "$3" "$4"
    func_make_relative_ltdl_filter_result=$func_make_relative_dir_filter_result
}


## -------------------- ##
## Resource management. ##
## -------------------- ##

# This section contains definitions for functions that each ensure a
# particular resource (a file, or a non-empty configuration variable for
# example) is available, and if appropriate to extract default values
# from pertinent package files.  Where a variable already has a non-
# empty value (as set by the package's 'bootstrap.conf'), that value is
# used in preference to deriving the default. Call them using their
# associated 'require_*' variable to ensure that they are executed, at
# most, once.
#
# Some of the require functions are very similar, so we generate those
# as this file is sourced. They look complicated, but they are the same
# as normal function declarations wrapped in "eval '<definition>'", so
# that embedded single quotes need to be escaped, and wherever a symbol
# is generated, we drop out of the single quotes and expand a variable
# that holds the symbol.
#
# After that, the rest appear in asciibetical order.

for base in '' ltdl_; do
  if test ltdl_ = "$base"; then p='$pkgltdldir/'; else p=; fi

  # require_Makefile_am
  # require_ltdl_Makefile_am
  # ------------------------
  # If not already set, set Makefile_am to 'Makefile.am' if that file is
  # present in the current directory, and similarly for
  # '$pkgltdldir/Makefile.am'.
  r=${base}Makefile_am
  v=require_$r
  f=func_$v
  eval $v'='$f'
  '$f' ()
  {
    $debug_cmd

    test -n "$'$r'" || '$r'='$p'Makefile.am

    if test -f "$'$r'"; then
      func_verbose "found '\'\$$r\''"
    else
      '$r'=
    fi

    '$v'=:
  }'
  o=$r


  # require_aclocal_amflags
  # require_ltdl_aclocal_amflags
  # ----------------------------
  # Extract '$aclocal_amflags' from 'Makefile.am' if present, and
  # similarly for 'libltdl/Makefile.am'.
  r=${base}aclocal_amflags
  v=require_$r
  f=func_$v
  eval $v'='$f'
  '$f' ()
  {
    $debug_cmd

    $require_'$o'

    test -n "$'$o'" && {
      _G_sed_extract_aclocal_amflags='\''s|#.*$||
        /^[	 ]*ACLOCAL_AMFLAGS[	 ]*=/ {
            s|^.*=[	 ]*\(.*\)|'$r'="\1"|
            p
        }'\''

      _G_aclocal_flags_cmd=`$SED -n "$_G_sed_extract_aclocal_amflags" \
          "$'$o'"`
      eval "$_G_aclocal_flags_cmd"

      test -n "$'$r'" && func_verbose "'$r'='\$$r\''"
    }

    '$v'=:
  }'
  o=$r


  # require_am_macro_dir
  # require_ltdl_am_macro_dir
  # -------------------------
  # Set am_macro_dir to the first directory specified in
  # ACLOCAL_AMFLAGS from 'Makefile.am', and similarly for
  # 'libltdl/Makefile.am'.
  r=${base}am_macro_dir
  v=require_$r
  f=func_$v
  eval $v'='$f'
  '$f' ()
  {
    $debug_cmd

    $require_'$o'

    _G_minus_I_seen=false
    for _G_arg in $'$o'; do
      case $_G_minus_I_seen,$_G_arg in
        :,*)   '$r'=$_G_arg; break ;;
        *,-I)  _G_minus_I_seen=: ;;
        *,-I*) '$r'=`expr x$_G_arg : '\''x-I\(.*\)$'\''`; break ;;
      esac
    done

    test -n "$'$r'" && func_verbose "'$r'='\'\$$r\''"

    '$v'=:
  }'
  o=$r

done


# require_ac_aux_dir
# ------------------
# Extract ac_aux_dir from AC_CONFIG_AUX_DIR.
require_ac_aux_dir=func_require_ac_aux_dir
func_require_ac_aux_dir ()
{
    $debug_cmd

    $require_configure_ac

    test -n "$configure_ac" && {
      func_extract_trace_first AC_CONFIG_AUX_DIR
      ac_aux_dir=$func_extract_trace_first_result

      case $ac_aux_dir in
        *\$*)
          func_fatal_error "\
cannot expand unknown variable in AC_CONFIG_AUX_DIR argument."
          ;;
      esac
    }

    test -n "$ac_aux_dir" && func_verbose "ac_aux_dir='$ac_aux_dir'"

    require_ac_aux_dir=:
}


# require_ac_ltdl_dir
# -------------------
# Extract ac_ltdl_dir from LT_CONFIG_LTDL_DIR.
require_ac_ltdl_dir=func_require_ac_ltdl_dir
func_require_ac_ltdl_dir ()
{
    $debug_cmd

    $require_configure_ac

    if test -n "$configure_ac"; then
      func_extract_trace_first LT_CONFIG_LTDL_DIR
      ac_ltdl_dir=$func_extract_trace_first_result

      case $ac_ltdl_dir in
        *\$*)
          func_fatal_error "\
cannot expand unknown variable in LT_CONFIG_LTDL_DIR argument."
          ;;
      esac
    fi

    # Strip trailing slashes.
    ac_ltdl_dir=`echo "$ac_ltdl_dir" |$SED 's|/*$||'`

    require_ac_ltdl_dir=:
}


# require_ac_ltdl_mode
# --------------------
# Extract mode name from LTDL_INIT options.
require_ac_ltdl_mode=func_require_ac_ltdl_mode
func_require_ac_ltdl_mode ()
{
    $debug_cmd

    $require_ac_ltdl_options

    case " $ac_ltdl_options " in
      *" nonrecursive "*) ac_ltdl_mode=nonrecursive ;;
      *" recursive "*)    ac_ltdl_mode=recursive    ;;
      *" subproject "*)   ac_ltdl_mode=subproject   ;;
    esac

    require_ac_ltdl_mode=:
}


# require_ac_ltdl_options
# -----------------------
# Extract ac_ltdl_options from LTDL_INIT.
require_ac_ltdl_options=func_require_ac_ltdl_options
func_require_ac_ltdl_options ()
{
    $debug_cmd

    $require_configure_ac

    if test -n "$configure_ac"; then
      func_extract_trace_first LTDL_INIT
      ac_ltdl_options=$func_extract_trace_first_result

      case $ac_ltdl_options in
        *\$*)
          func_fatal_error "\
cannot expand unknown variable in LTDL_INIT argument."
          ;;
      esac
    fi

    require_ac_ltdl_mode=:
}


# require_ac_macro_dir
# --------------------
# Extract ac_macro_dir from AC_CONFIG_MACRO_DIRS.
require_ac_macro_dir=func_require_ac_macro_dir
func_require_ac_macro_dir ()
{
    $debug_cmd

    $require_configure_ac

    if test -n "$configure_ac"; then
      func_extract_trace_first AC_CONFIG_MACRO_DIRS
      ac_macro_dir=`expr "x$func_extract_trace_first_result" : 'x\([^	 ]*\)'`

      test -n "$ac_macro_dir" || {
        func_extract_trace_first AC_CONFIG_MACRO_DIR
	ac_macro_dir=$func_extract_trace_first_result
      }
    fi

    require_ac_macro_dir=:
}


# require_aux_dir
# ---------------
# Set aux_dir according to AC_CONFIG_AUX_DIR or else use the same
# heuristics as Autoconf to intuit an appropriate setting.
require_aux_dir=func_require_aux_dir
func_require_aux_dir ()
{
    $debug_cmd

    $require_ac_aux_dir

    test -z "$aux_dir" && aux_dir=$ac_aux_dir

    # Subproject ltdl without $configure_ac keeps pkgauxfiles in
    # specified --ltdl optarg directory.
    test -z "$aux_dir" && $opt_ltdl && {
      $require_configure_ac

      test -n "$configure_ac" || {
        $require_ltdl_dir
        $require_ltdl_mode

        test subproject = "$ltdl_mode" && aux_dir=$ltdl_dir
      }
    }

    test -z "$aux_dir" && {
      # Try to intuit aux_dir using the same heuristic as Autoconf.
      for _G_dir in . .. ../..; do
        if test -f "$_G_dir/install-sh" || test -f "$_G_dir/install.sh"
        then
          aux_dir=$_G_dir
          break
        fi
      done
    }

    # Use the current directory if all else fails.
    test -z "$aux_dir" && aux_dir=.

    require_aux_dir=:
}


# require_configure_ac
# --------------------
# Ensure that there is a 'configure.ac' or 'configure.in' file in this
# directory, and that '$configure_ac' contains its name.
require_configure_ac=func_require_configure_ac
func_require_configure_ac ()
{
    $debug_cmd

    test -z "$configure_ac" \
      && func_autoconf_configure configure.ac && configure_ac=configure.ac
    test -z "$configure_ac" \
      && func_autoconf_configure configure.in && configure_ac=configure.in
    test -z "$configure_ac" \
      || func_verbose "found '$configure_ac'"

    require_configure_ac=:
}


# require_filter_Makefile_am
# --------------------------
# Set 'filter_Makefile_am' ready for passing to func_copy when libltdl's
# stock Makefile.am contents need to be filtered to work in recursive
# mode.
require_filter_Makefile_am=func_require_filter_Makefile_am
func_require_filter_Makefile_am ()
{
    $debug_cmd

    $require_ltdl_mode

    case $ltdl_mode in
      recursive)
        filter_Makefile_am='
            /^[^#]/{
              s|(LIBOBJS)|(ltdl_LIBOBJS)|g
              s|(LTLIBOBJS)|(ltdl_LTLIBOBJS)|g
            }'
        ;;

      subproject)
        # Adjust default relative macro_dir paths.
        $require_ltdl_am_macro_dir

        func_make_relative_ltdl_filter "$ltdl_am_macro_dir" "$macro_dir" '-I '
        test -z "$func_make_relative_ltdl_filter_result" || {
          func_append filter_Makefile_am "
              /^ACLOCAL_AMFLAGS = /{
                $func_make_relative_ltdl_filter_result
              }"
        }
        func_make_relative_ltdl_filter "$ltdl_am_macro_dir" "$macro_dir" 'dir)'
        func_append filter_Makefile_am "$func_make_relative_ltdl_filter_result"

        # Adjust default relative aux_dir paths.
        $require_ltdl_ac_aux_dir
        func_make_relative_ltdl_filter "$ltdl_ac_aux_dir" "$aux_dir"
        func_append filter_Makefile_am "$func_make_relative_ltdl_filter_result"
        ;;
    esac

    require_filter_Makefile_am=:
}


# require_filter_aclocal_m4
# -------------------------
# Set 'filter_aclocal_m4' ready for passing to func_copy when libltdl's
# stock aclocal.m4 contents need to be filtered to work in recursive
# mode.
require_filter_aclocal_m4=func_require_filter_aclocal_m4
func_require_filter_aclocal_m4 ()
{
    $debug_cmd

    $require_ltdl_am_macro_dir

    func_make_relative_ltdl_filter "$ltdl_am_macro_dir" "$macro_dir"

    test -z "$func_make_relative_ltdl_filter_result" || {
      func_append filter_aclocal_m4 "
          /^[m]4_include(/{
            $func_make_relative_ltdl_filter_result
          }"
    }

    require_filter_aclocal_m4=:
}


# require_filter_configure_ac
# ---------------------------
# Set 'filter_configure_ac' ready for passing to func_copy when
# libltdl's stock configure.ac contents need to be filtered to work in
# subproject mode.
require_filter_configure_ac=func_require_filter_configure_ac
func_require_filter_configure_ac ()
{
    $debug_cmd

    $require_ltdl_ac_aux_dir

    func_make_relative_ltdl_filter "$ltdl_ac_aux_dir" "$aux_dir"
    func_append filter_configure_ac "$func_make_relative_ltdl_filter_result"

    require_filter_configure_ac=:
}


# require_filter_ltdl_mk
# ----------------------
# Set 'filter_ltdl_mk' ready for passing to func_copy in order for the
# contents of ltdl.mk to match the nonrecursive libltdl directory into
# which it is copied.
require_filter_ltdl_mk=func_require_filter_ltdl_mk
func_require_filter_ltdl_mk ()
{
    $debug_cmd

    $require_ltdl_dir

    # Note that we strip comments right here, rather than rely on
    # using a $SED that allows comments.
    my_uscore=`$ECHO "$ltdl_dir" | $SED 's|[/.+-]|_|g'`
    filter_ltdl_mk=`$ECHO '
      /^[^#]/{

        # Use only libltdl conditional objects.
        s|(LIBOBJS)|(ltdl_LIBOBJS)|g
        s|(LTLIBOBJS)|(ltdl_LTLIBOBJS)|g

        # Convert libltdl path and variable sections to $ltdl_dir.
        s|libltdl_|@my_uscore@_|
        s|libltdl/|@ltdl_dir@/|
        s|: libltdl/|: @ltdl_dir@/|
        s| -Ilibltdl | -I@ltdl_dir@ |
        s|\$(libltdl_|\$(@my_uscore@_|
        s|)/libltdl |)/@ltdl_dir@ |
        s|@my_uscore@|'"$my_uscore"'|g
        s|@ltdl_dir@|'"$ltdl_dir"'|g

      }' | $SED '/^[	 ]*#/d;/^$/d'`

    require_filter_ltdl_mk=:
}


# require_ltdl_ac_aux_dir
# -----------------------
# This needs to work in subproject mode, when GNU M4 may not be
# available and hence extract-trace can't be used.  But since we
# installed libltdl/configure.ac, then we already know what value
# we used.
require_ltdl_ac_aux_dir=func_require_ltdl_ac_aux_dir
func_require_ltdl_ac_aux_dir ()
{
    $debug_cmd

    ltdl_ac_aux_dir="../build-aux"
    func_verbose "ltdl_ac_aux_dir='$ltdl_ac_aux_dir'"

    require_ltdl_ac_aux_dir=:
}


# require_ltdl_dir
# ----------------
# If both are specified, ensure both --ltdl=LTDL_DIR and
# LT_CONFIG_LTDL_DIR agree, and set ltdl_dir to the value of either.
require_ltdl_dir=func_require_ltdl_dir
func_require_ltdl_dir ()
{
    $debug_cmd

    $require_ac_ltdl_dir

    test -z "$ltdl_dir" && ltdl_dir=$ac_ltdl_dir
    test -z "$ltdl_dir" && $opt_ltdl && ltdl_dir=libltdl

    if test -n "$ac_ltdl_dir"; then
      test "$ac_ltdl_dir" = "$ltdl_dir" || func_fatal_error "\
--ltdl='$ltdl_dir' does not match LT_CONFIG_LTDL_DIR($ac_ltdl_dir)"
    fi

    require_ltdl_dir=:
}


# require_ltdl_mode
# -----------------
# If both are specified, ensure both command line setting and LTDL_INIT
# option agree, and set ltdl_mode to the value of either.
require_ltdl_mode=func_require_ltdl_mode
func_require_ltdl_mode ()
{
    $debug_cmd

    $require_ac_ltdl_mode

    test -z "$ltdl_mode" && ltdl_mode=$ac_ltdl_mode
    test -z "$ltdl_mode" && {
      $require_ltdl_dir

      test -n "$ltdl_dir" && ltdl_mode=subproject
    }

    if test -n "$ac_ltdl_mode"; then
      test "$ac_ltdl_mode" = "$ltdl_mode" || func_fatal_error "\
--$ltdl_mode does not match LTDL_INIT($ac_ltdl_mode)"
    fi

    func_verbose "ltdl mode='$ltdl_mode'"

    require_ltdl_mode=:
}


# require_macro_dir
# -----------------
# If both are specified, ensure both ACLOCAL_AMFLAGS and
# AC_CONFIG_MACRO_DIRS agree, and set macro_dir to the value of either.
require_macro_dir=func_require_macro_dir
func_require_macro_dir ()
{
    $debug_cmd

    $require_ac_macro_dir
    $require_am_macro_dir

    # AC_CONFIG_MACRO_DIRS takes precedence.
    macro_dir=$ac_macro_dir

    # Followed by first -I optarg from ACLOCAL_AMFLAGS.
    test -z "$macro_dir" && macro_dir=$am_macro_dir

    # Subproject ltdl without either of the above keeps macros in
    # specified --ltdl optarg subdirectory.
    test -z "$macro_dir" && $opt_ltdl && {
      $require_ltdl_dir
      $require_ltdl_mode

      test subproject = "$ltdl_mode" && macro_dir=$ltdl_dir/m4
    }

    # Use ./m4 as the last resort.
    test -z "$macro_dir" && macro_dir=m4

    # Diagnose conflicts.
    if test -n "$ac_macro_dir" && test -n "$am_macro_dir"; then
      test "$ac_macro_dir" = "$am_macro_dir" || func_fatal_error "\
AC_CONFIG_MACRO_DIRS([$ac_macro_dir]) conflicts with ACLOCAL_AMFLAGS=-I $am_macro_dir."
    fi

    require_macro_dir=:
}


# require_seen_ltdl
# -----------------
# Determine from contents of $configure_ac whether this project contains
# libltdl.
require_seen_ltdl=func_require_seen_ltdl
func_require_seen_ltdl ()
{
    $debug_cmd

    $require_configure_ac

    if test -n "$configure_ac"; then
      func_extract_trace AC_LIB_LTDL,AC_WITH_LTDL,LT_WITH_LTDL,LTDL_INIT
      test -n "$func_extract_trace_result" && seen_ltdl=:
    fi
    test -n "$seen_ltdl" || seen_ltdl=false

    $seen_ltdl && func_verbose "found LTDL_INIT invocation"

    require_seen_ltdl=:
}


# require_seen_libtool
# --------------------
# Determine from contents of $configure_ac whether this project is using
# Libtool to compile (some of) its objects.
require_seen_libtool=func_require_seen_libtool
func_require_seen_libtool ()
{
    $debug_cmd

    $require_configure_ac

    if test -n "$configure_ac"; then
      func_extract_trace AM_PROG_LIBTOOL,AC_PROG_LIBTOOL,LT_INIT
      test -n "$func_extract_trace_result" && seen_libtool=:
    fi
    test -n "$seen_libtool" || seen_libtool=false

    $seen_libtool && func_verbose "found LT_INIT invocation"

    require_seen_libtool=:
}



## ----------- ##
##    Main.    ##
## ----------- ##

{
  # Lists of all files libtoolize has ever installed.  These are removed
  # before installing the latest files when --force was passed to help
  # ensure a clean upgrade.
  # Do not remove config.guess, config.sub or install-sh, we don't
  # install them without --install, and the project may not be using
  # Automake.  Similarly, do not remove Gnulib files.
  all_pkgaux_files="compile depcomp missing ltmain.sh"
  all_pkgmacro_files="libtool.m4 ltargz.m4 ltdl.m4 ltoptions.m4 ltsugar.m4 ltversion.in ltversion.m4 lt~obsolete.m4"
  all_pkgltdl_files="COPYING.LIB Makefile Makefile.in Makefile.inc Makefile.am README acinclude.m4 aclocal.m4 argz_.h argz.c config.h.in config-h.in configure configure.ac configure.in libltdl/lt__alloc.h libltdl/lt__argz.h libltdl/lt__dirent.h libltdl/lt__glibc.h libltdl/lt__private.h libltdl/lt__strl.h libltdl/lt_dlloader.h libltdl/lt_error.h libltdl/lt_system.h libltdl/slist.h loaders/dld_link.c loaders/dlopen.c loaders/dyld.c loaders/load_add_on.c loaders/loadlibrary.c loaders/preopen.c loaders/shl_load.c lt__alloc.c lt__argz.c lt__dirent.c lt__strl.c lt_dlloader.c lt_error.c ltdl.c ltdl.h ltdl.mk slist.c"

  # Files installed by func_install_*, some files are missing from these
  # lists deliberately because their respective func_install has to handle
  # the missing filenames specially.
  pkgaux_files="compile config.guess config.sub depcomp install-sh missing ltmain.sh"
  pkgltdl_files="COPYING.LIB Makefile.am README configure.ac aclocal.m4 Makefile.in config-h.in configure libltdl/lt__alloc.h libltdl/lt__argz_.h libltdl/lt__dirent.h libltdl/lt__glibc.h libltdl/lt__private.h libltdl/lt__strl.h libltdl/lt_dlloader.h libltdl/lt_error.h libltdl/lt_system.h libltdl/slist.h loaders/dld_link.c loaders/dlopen.c loaders/dyld.c loaders/load_add_on.c loaders/loadlibrary.c loaders/preopen.c loaders/shl_load.c lt__alloc.c lt__argz.c lt__dirent.c lt__strl.c lt_dlloader.c lt_error.c ltdl.c ltdl.h ltdl.mk slist.c"
  pkgmacro_files="libtool.m4 ltargz.m4 ltdl.m4 ltoptions.m4 ltsugar.m4 ltversion.m4 lt~obsolete.m4"

  # Locations for important files:
  prefix="/usr"
  datadir="/usr/share"
  pkgauxdir="/usr/share/libtool/build-aux"
  pkgltdldir="/usr/share/libtool"
  aclocaldir="/usr/share/aclocal"

  # Allow the user to override the master libtoolize repository:
  if test -n "$_lt_pkgdatadir"; then
    pkgauxdir=$_lt_pkgdatadir/build-aux
    pkgltdldir=$_lt_pkgdatadir/libltdl
    aclocaldir=$_lt_pkgdatadir/m4
  fi
  func_nonemptydir_p pkgauxdir
  func_nonemptydir_p pkgltdldir
  func_nonemptydir_p aclocaldir

  extract_trace=$pkgauxdir/extract-trace

  # :::BE CAREFUL HERE:::
  # func_check_macros needs to check whether --ltdl was specified when
  # LTDL_INIT was not seen, so we can't just use one variable for both
  # conditions, or that check will be impossible.   No need to clutter the
  # rest of the code with '$opt_ltdl || $seen_ltdl' though, because we CAN
  # safely set opt_ltdl to true if LTDL_INIT was seen:
  $require_seen_ltdl
  $seen_ltdl && opt_ltdl=:

  func_install_pkgaux_files
  func_install_pkgmacro_files
  func_install_pkgltdl_files

  func_check_macros
}

exit $exit_status

# Local Variables:
# mode:shell-script
# sh-indentation:2
# End:

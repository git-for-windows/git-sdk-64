Produced by GNU Guile 3.0.10 from `./libguile/guile-procedures.texi'.

acons

- Scheme Procedure: acons key value alist
     Add a new key-value pair to ALIST.  A new pair is created whose car
     is KEY and whose cdr is VALUE, and the pair is consed onto ALIST,
     and the new list is returned.  This function is _not_ destructive;
     ALIST is not modified.

sloppy-assq

- Scheme Procedure: sloppy-assq key alist
     Behaves like `assq' but does not do any error checking.  Recommended
     only for use in Guile internals.

sloppy-assv

- Scheme Procedure: sloppy-assv key alist
     Behaves like `assv' but does not do any error checking.  Recommended
     only for use in Guile internals.

sloppy-assoc

- Scheme Procedure: sloppy-assoc key alist
     Behaves like `assoc' but does not do any error checking.
     Recommended only for use in Guile internals.

assq

- Scheme Procedure: assq key alist




     Fetch the entry in ALIST that is associated with KEY.  To decide
     whether the argument KEY matches a particular entry in ALIST,
     `assq' compares keys with `eq?', `assv' uses `eqv?' and `assoc'
     uses `equal?'.  If KEY cannot be found in ALIST (according to
     whichever equality predicate is in use), then return `#f'.  These
     functions return the entire alist entry found (i.e.  both the key
     and the value).

assv

- Scheme Procedure: assv key alist
     Behaves like `assq' but uses `eqv?' for key comparison.

assoc

- Scheme Procedure: assoc key alist
     Behaves like `assq' but uses `equal?' for key comparison.

assq-ref

- Scheme Procedure: assq-ref alist key




     Like `assq', `assv' and `assoc', except that only the value
     associated with KEY in ALIST is returned.  These functions are
     equivalent to

          (let ((ent (ASSOCIATOR KEY ALIST)))
            (and ent (cdr ent)))

     where ASSOCIATOR is one of `assq', `assv' or `assoc'.

assv-ref

- Scheme Procedure: assv-ref alist key
     Behaves like `assq-ref' but uses `eqv?' for key comparison.

assoc-ref

- Scheme Procedure: assoc-ref alist key
     Behaves like `assq-ref' but uses `equal?' for key comparison.

assq-set!

- Scheme Procedure: assq-set! alist key val




     Reassociate KEY in ALIST with VAL: find any existing ALIST entry
     for KEY and associate it with the new VAL.  If ALIST does not
     contain an entry for KEY, add a new one.  Return the (possibly new)
     alist.

     These functions do not attempt to verify the structure of ALIST,
     and so may cause unusual results if passed an object that is not an
     association list.

assv-set!

- Scheme Procedure: assv-set! alist key val
     Behaves like `assq-set!' but uses `eqv?' for key comparison.

assoc-set!

- Scheme Procedure: assoc-set! alist key val
     Behaves like `assq-set!' but uses `equal?' for key comparison.

assq-remove!

- Scheme Procedure: assq-remove! alist key




     Delete the first entry in ALIST associated with KEY, and return the
     resulting alist.

assv-remove!

- Scheme Procedure: assv-remove! alist key
     Behaves like `assq-remove!' but uses `eqv?' for key comparison.

assoc-remove!

- Scheme Procedure: assoc-remove! alist key
     Behaves like `assq-remove!' but uses `equal?' for key comparison.

array-fill!

- Scheme Procedure: array-fill! ra fill
     Store FILL in every element of array RA.  The value returned is
     unspecified.

array-copy-in-order!

- Scheme Procedure: array-copy-in-order!
     implemented by the C function "scm_array_copy_x"

array-copy!

- Scheme Procedure: array-copy! src dst


     Copy every element from vector or array SRC to the corresponding
     element of DST.  DST must have the same rank as SRC, and be at
     least as large in each dimension.  The order is unspecified.

array-map-in-order!

- Scheme Procedure: array-map-in-order!
     implemented by the C function "scm_array_map_x"

array-map!

- Scheme Procedure: array-map! ra0 proc .  lra


     ARRAY1, ... must have the same number of dimensions as RA0 and have
     a range for each index which includes the range for the
     corresponding index in RA0.  PROC is applied to each tuple of
     elements of ARRAY1, ... and the result is stored as the
     corresponding element in RA0.  The value returned is unspecified.
     The order of application is unspecified.

array-for-each

- Scheme Procedure: array-for-each proc ra0 .  lra
     Apply PROC to each tuple of elements of RA0 ... in row-major order.
     The value returned is unspecified.

array-index-map!

- Scheme Procedure: array-index-map! ra proc
     Apply PROC to the indices of each element of RA in turn, storing
     the result in the corresponding element.  The value returned and
     the order of application are unspecified.

     One can implement ARRAY-INDEXES as

          (define (array-indexes array)
              (let ((ra (apply make-array #f (array-shape array))))
                (array-index-map! ra (lambda x x))
                ra))

     Another example:

          (define (apl:index-generator n)
              (let ((v (make-uniform-vector n 1)))
                (array-index-map! v (lambda (i) i))
                v))

array-equal?

- Scheme Procedure: array-equal? [ra0 [ra1 .  rest]]
     Return `#t' iff all arguments are arrays with the same shape, the
     same type, and have corresponding elements which are either
     `equal?' or `array-equal?'.  This function differs from `equal?' in
     that all arguments must be arrays.

array-slice-for-each

- Scheme Procedure: array-slice-for-each frame_rank op .  args
     Apply OP to each of the cells of rank rank(ARG)-FRAME_RANK of the
     arrays ARGS, in unspecified order.  The first FRAME_RANK dimensions
     of each ARG must match.  Rank-0 cells are passed as rank-0 arrays.

     The value returned is unspecified.

     For example:

          ;; Sort the rows of rank-2 array A.
          
          (array-slice-for-each 1 (lambda (x) (sort! x <)) a)
          
          ;; Compute the arguments of the (x y) vectors in the rows of rank-2
          ;; array XYS and store them in rank-1 array ANGLES. Inside OP,
          ;; XY is a rank-1 (2-1) array, and ANGLE is a rank-0 (1-1) array.
          
          (array-slice-for-each 1 
            (lambda (xy angle)
              (array-set! angle (atan (array-ref xy 1) (array-ref xy 0))))
            xys angles)

array-slice-for-each-in-order

- Scheme Procedure: array-slice-for-each-in-order frank op .  a
     Same as array-slice-for-each, but visit the cells sequentially and
     in row-major order.

array?

- Scheme Procedure: array? obj
     Return `#t' if the OBJ is an array, and `#f' if not.

typed-array?

- Scheme Procedure: typed-array? obj type
     Return `#t' if the OBJ is an array of type TYPE, and `#f' if not.

array-length

- Scheme Procedure: array-length array
     Return the length of an array: its first dimension.  It is an error
     to ask for the length of an array of rank 0.

array-dimensions

- Scheme Procedure: array-dimensions ra
     `array-dimensions' is similar to `array-shape' but replaces
     elements with a `0' minimum with one greater than the maximum.  So:

          (array-dimensions (make-array 'foo '(-1 3) 5)) ==> ((-1 3) 5)

array-type

- Scheme Procedure: array-type ra
array-type-code

- Scheme Procedure: array-type-code array
     Return the type of the elements in ARRAY, as an integer code.

array-in-bounds?

- Scheme Procedure: array-in-bounds? ra .  args
     Return `#t' if its arguments would be acceptable to `array-ref'.

array-ref

- Scheme Procedure: array-ref v [idx0 [idx1 .  idxN]]
     Return the element at the `(idx0, idx1, idxN...)' position in array
     V.

array-set!

- Scheme Procedure: array-set! v obj [idx0 [idx1 .  idxN]]
     Set the element at the `(idx0, idx1, idxN...)' position in the
     array V to OBJ.  The value returned by `array-set!' is unspecified.

array->list

- Scheme Procedure: array->list array
     Return a list representation of ARRAY.

     It is easiest to specify the behavior of this function by example:

          (array->list #0(a)) ==> 1
          (array->list #1(a b)) ==> (a b)
          (array->list #2((aa ab) (ba bb)) ==> ((aa ab) (ba bb))

array-rank

- Scheme Procedure: array-rank array
     Return the number of dimensions of the array ARRAY.

shared-array-root

- Scheme Procedure: shared-array-root ra
     Return the root vector of a shared array.

shared-array-offset

- Scheme Procedure: shared-array-offset ra
     Return the root vector index of the first element in the array.

shared-array-increments

- Scheme Procedure: shared-array-increments ra
     For each dimension, return the distance between elements in the
     root vector.

make-typed-array

- Scheme Procedure: make-typed-array type fill .  bounds
     Create and return an array of type TYPE.

make-array

- Scheme Procedure: make-array fill .  bounds
     Create and return an array.

make-shared-array

- Scheme Procedure: make-shared-array oldra mapfunc .  dims
     `make-shared-array' can be used to create shared subarrays of other
     arrays.  The MAPFUNC is a function that translates coordinates in
     the new array into coordinates in the old array.  A MAPFUNC must be
     linear, and its range must stay within the bounds of the old array,
     but it can be otherwise arbitrary.  A simple example:

          (define fred (make-array #f 8 8))
          (define freds-diagonal
            (make-shared-array fred (lambda (i) (list i i)) 8))
          (array-set! freds-diagonal 'foo 3)
          (array-ref fred 3 3) ==> foo
          (define freds-center
            (make-shared-array fred (lambda (i j) (list (+ 3 i) (+ 3 j))) 2 2))
          (array-ref freds-center 0 0) ==> foo

array-slice

- Scheme Procedure: array-slice ra .  indices
     Return the array slice RA[INDICES ..., ...] The rank of RA must
     equal to the number of indices or larger.

     See also `array-ref', `array-cell-ref', `array-cell-set!'.

     `array-slice' may return a rank-0 array.  For example:

          (array-slice #2((1 2 3) (4 5 6)) 1 1) ==> #0(5)
          (array-slice #2((1 2 3) (4 5 6)) 1) ==> #(4 5 6)
          (array-slice #2((1 2 3) (4 5 6))) ==> #2((1 2 3) (4 5 6))
          (array-slice #0(5) ==> #0(5).

array-cell-ref

- Scheme Procedure: array-cell-ref ra .  indices
     Return the element at the `(INDICES ...)' position in array RA, or
     the array slice RA[INDICES ..., ...] if the rank of RA is larger
     than the number of indices.

     See also `array-ref', `array-slice', `array-cell-set!'.

     `array-cell-ref' never returns a rank 0 array.  For example:

          (array-cell-ref #2((1 2 3) (4 5 6)) 1 1) ==> 5
          (array-cell-ref #2((1 2 3) (4 5 6)) 1) ==> #(4 5 6)
          (array-cell-ref #2((1 2 3) (4 5 6))) ==> #2((1 2 3) (4 5 6))
          (array-cell-ref #0(5) ==> 5.

array-cell-set!

- Scheme Procedure: array-cell-set! ra b .  indices
     Set the array slice RA[INDICES ..., ...] to B .Equivalent to
     `(array-copy! B (apply array-cell-ref RA INDICES))' if the number
     of indices is smaller than the rank of RA; otherwise equivalent to
     `(apply array-set! RA B INDICES)'.  This function returns the
     modified array RA.

     See also `array-ref', `array-cell-ref', `array-slice'.

     For example:

          (define A (list->array 2 '((1 2 3) (4 5 6))))
          (array-cell-set! A #0(99) 1 1) ==> #2((1 2 3) (4 #0(99) 6))
          (array-cell-set! A 99 1 1) ==> #2((1 2 3) (4 99 6))
          (array-cell-set! A #(a b c) 0) ==> #2((a b c) (4 99 6))
          (array-cell-set! A #2((x y z) (9 8 7))) ==> #2((x y z) (9 8 7))
          
          (define B (make-array 0))
          (array-cell-set! B 15) ==> #0(15)

transpose-array

- Scheme Procedure: transpose-array ra .  args
     Return an array sharing contents with RA, but with dimensions
     arranged in a different order.  There must be one DIM argument for
     each dimension of RA.  DIM0, DIM1, ... should be integers between 0
     and the rank of the array to be returned.  Each integer in that
     range must appear at least once in the argument list.

     The values of DIM0, DIM1, ... correspond to dimensions in the array
     to be returned, their positions in the argument list to dimensions
     of RA.  Several DIMs may have the same value, in which case the
     returned array will have smaller rank than RA.

          (transpose-array '#2((a b) (c d)) 1 0) ==> #2((a c) (b d))
          (transpose-array '#2((a b) (c d)) 0 0) ==> #1(a d)
          (transpose-array '#3(((a b c) (d e f)) ((1 2 3) (4 5 6))) 1 1 0) ==>
                          #2((a 4) (b 5) (c 6))

array-contents

- Scheme Procedure: array-contents ra [strict]
     If RA may be "unrolled" into a one dimensional shared array without
     changing their order (last subscript changing fastest), then
     `array-contents' returns that shared array, otherwise it returns
     `#f'.  All arrays made by `make-array' and `make-uniform-array' may
     be unrolled, some arrays made by `make-shared-array' may not be.  If
     the optional argument STRICT is provided, a shared array will be
     returned only if its elements are stored contiguously in memory.

list->typed-array

- Scheme Procedure: list->typed-array type shape lst
     Return an array of the type TYPE with elements the same as those of
     LST.

     The argument SHAPE determines the number of dimensions of the array
     and their shape.  It is either an exact integer, giving the number
     of dimensions directly, or a list whose length specifies the number
     of dimensions and each element specified the lower and optionally
     the upper bound of the corresponding dimension.  When the element
     is list of two elements, these elements give the lower and upper
     bounds.  When it is an exact integer, it gives only the lower
     bound.

list->array

- Scheme Procedure: list->array ndim lst
     Return an array with elements the same as those of LST.

system-async-mark

- Scheme Procedure: system-async-mark proc [thread]
     Mark PROC (a procedure with zero arguments) for future execution in
     THREAD.  If PROC has already been marked for THREAD but has not
     been executed yet, this call has no effect.  If THREAD is omitted,
     the thread that called `system-async-mark' is used.

     This procedure is not safe to be called from C signal handlers.  Use
     `scm_sigaction' or `scm_sigaction_for_thread' to install signal
     handlers.

noop

- Scheme Procedure: noop .  args
     Do nothing.  When called without arguments, return `#f', otherwise
     return the first argument.

call-with-blocked-asyncs

- Scheme Procedure: call-with-blocked-asyncs proc
     Call PROC with no arguments and block the execution of system
     asyncs by one level for the current thread while it is running.
     Return the value returned by PROC.

call-with-unblocked-asyncs

- Scheme Procedure: call-with-unblocked-asyncs proc
     Call PROC with no arguments and unblock the execution of system
     asyncs by one level for the current thread while it is running.
     Return the value returned by PROC.

make-atomic-box

- Scheme Procedure: make-atomic-box init
     Return an atomic box initialized to value INIT.

atomic-box?

- Scheme Procedure: atomic-box? obj
     Return `#t' if OBJ is an atomic-box object, else return `#f'.

atomic-box-ref

- Scheme Procedure: atomic-box-ref box
     Fetch the value stored in the atomic box BOX and return it.

atomic-box-set!

- Scheme Procedure: atomic-box-set! box val
     Store VAL into the atomic box BOX.

atomic-box-swap!

- Scheme Procedure: atomic-box-swap! box val
     Store VAL into the atomic box BOX, and return the value that was
     previously stored in the box.

atomic-box-compare-and-swap!

- Scheme Procedure: atomic-box-compare-and-swap! box expected desired
     If the value of the atomic box BOX is the same as, EXPECTED (in the
     sense of `eq?'), replace the contents of the box with DESIRED.
     Otherwise does not update the box.  Returns the previous value of
     the box in either case, so you can know if the swap worked by
     checking if the return value is `eq?' to EXPECTED.

display-error

- Scheme Procedure: display-error frame port subr message args rest
     Display an error message to the output port PORT.  FRAME is the
     frame in which the error occurred, SUBR is the name of the
     procedure in which the error occurred and MESSAGE is the actual
     error message, which may contain formatting instructions.  These
     will format the arguments in the list ARGS accordingly.  REST is
     currently ignored.

display-application

- Scheme Procedure: display-application frame [port [indent]]
     Display a procedure application FRAME to the output port PORT.
     INDENT specifies the indentation of the output.

display-backtrace

- Scheme Procedure: display-backtrace stack port [first [depth
[highlights]]]
     Display a backtrace to the output port PORT.  STACK is the stack to
     take the backtrace from, FIRST specifies where in the stack to
     start and DEPTH how many frames to display.  FIRST and DEPTH can be
     `#f', which means that default values will be used.  If HIGHLIGHTS
     is given it should be a list; the elements of this list will be
     highlighted wherever they appear in the backtrace.

backtrace

- Scheme Procedure: backtrace [highlights]
     Display a backtrace of the current stack to the current output
     port.  If HIGHLIGHTS is given, it should be a list; the elements of
     this list will be highlighted wherever they appear in the
     backtrace.

not

- Scheme Procedure: not x
     Return `#t' iff X is false, else return `#f'.

nil?

- Scheme Procedure: nil? x
     Return `#t' if X would be interpreted as `nil' by Emacs Lisp code,
     else return `#f'.

          (nil? #nil) ==> #t
          (nil? #f)   ==> #t
          (nil? '())  ==> #t
          (nil? 3)    ==> #f

boolean?

- Scheme Procedure: boolean? obj
     Return `#t' iff OBJ is `#t' or false.

bitvector?

- Scheme Procedure: bitvector? obj
     Return `#t' when OBJ is a bitvector, else return `#f'.

make-bitvector

- Scheme Procedure: make-bitvector len [fill]
     Create a new bitvector of length LEN and optionally initialize all
     elements to FILL.

bitvector

- Scheme Procedure: bitvector .  bits
     Create a new bitvector with the arguments as elements.

bitvector-length

- Scheme Procedure: bitvector-length vec
     Return the length of the bitvector VEC.

bitvector-bit-set?

- Scheme Procedure: bitvector-bit-set? vec idx
     Return `#t' if the bit at index IDX of the bitvector VEC is set, or
     `#f' otherwise.

bitvector-bit-clear?

- Scheme Procedure: bitvector-bit-clear? vec idx
     Return `#t' if the bit at index IDX of the bitvector VEC is clear
     (unset), or `#f' otherwise.

bitvector-set-bit!

- Scheme Procedure: bitvector-set-bit! vec idx
     Set the element at index IDX of the bitvector VEC.

bitvector-clear-bit!

- Scheme Procedure: bitvector-clear-bit! vec idx
     Clear the element at index IDX of the bitvector VEC.

bitvector-set-all-bits!

- Scheme Procedure: bitvector-set-all-bits! vec
     Set all elements of the bitvector VEC.

bitvector-clear-all-bits!

- Scheme Procedure: bitvector-clear-all-bits! vec
     Clear all elements of the bitvector VEC.

list->bitvector

- Scheme Procedure: list->bitvector list
     Return a new bitvector initialized with the elements of LIST.

bitvector->list

- Scheme Procedure: bitvector->list vec
     Return a new list initialized with the elements of the bitvector
     VEC.

bitvector-count

- Scheme Procedure: bitvector-count bitvector
     Return the number of set bits in BITVECTOR.

bitvector-position

- Scheme Procedure: bitvector-position v bit [start]
     Return the index of the first occurrence of BIT in bit vector V,
     starting from START (or zero if not given) .If there is no BIT
     entry between START and the end of V, then return `#f'.  For
     example,

          (bitvector-position #*000101 #t)  ==> 3
          (bitvector-position #*0001111 #f 3) ==> #f

bitvector-set-bits!

- Scheme Procedure: bitvector-set-bits! v bits
     Update the bitvector V in place by performing a logical OR of its
     bits with those of BITS.  For example:

          (define bv (bitvector-copy #*11000010))
          (bitvector-set-bits! bv #*10010001)
          bv
          ==> #*11010011

bitvector-clear-bits!

- Scheme Procedure: bitvector-clear-bits! v bits
     Update the bitvector V in place by performing a logical AND of its
     bits with the complement of those of BITS.  For example:

          (define bv (bitvector-copy #*11000010))
          (bitvector-clear-bits! bv #*10010001)
          bv
          ==> #*01000010

bitvector-copy

- Scheme Procedure: bitvector-copy bv [start [end]]
     Returns a freshly allocated bitvector containing the elements of
     bitvector BV between START and END.

     START defaults to 0 and END defaults to the length of BV.

bitvector-count-bits

- Scheme Procedure: bitvector-count-bits v kv
     Return a count of how many entries in bit vector V are set, with KV
     selecting the entries to consider.

     For example,

          (bitvector-count-bits #*01110111 #*11001101) ==> 3

bitvector-flip-all-bits!

- Scheme Procedure: bitvector-flip-all-bits! v
     Modify the bit vector V in place by setting all clear bits and
     clearing all set bits.

bytevector-slice

- Scheme Procedure: bytevector-slice bv offset [size]
     Return the slice of BV starting at OFFSET and counting SIZE bytes.
     When SIZE is omitted, the slice covers all of BV starting from
     OFFSET.  The returned slice shares storage with BV: changes to the
     slice are visible in BV and vice-versa.

     When BV is actually a SRFI-4 uniform vector, its element type is
     preserved unless OFFSET and SIZE are not aligned on its element
     type size.

native-endianness

- Scheme Procedure: native-endianness
     Return a symbol denoting the machine's native endianness.

bytevector?

- Scheme Procedure: bytevector? obj
     Return true if OBJ is a bytevector.

make-bytevector

- Scheme Procedure: make-bytevector len [fill]
     Return a newly allocated bytevector of LEN bytes, optionally filled
     with FILL.

bytevector-length

- Scheme Procedure: bytevector-length bv
     Return the length (in bytes) of BV.

bytevector=?

- Scheme Procedure: bytevector=? bv1 bv2
     Return is BV1 equals to BV2---i.e., if they have the same length
     and contents.

bytevector-fill!

- Scheme Procedure: bytevector-fill! bv fill [start [end]]
     Fill positions [START ... END) of bytevector BV with FILL, a byte.
     START defaults to 0 and END defaults to the length of BV.  The
     return value is unspecified.

bytevector-copy!

- Scheme Procedure: bytevector-copy! source source_start target
target_start len
     Copy LEN bytes from SOURCE into TARGET, reading from a block
     starting at SOURCE_START (a positive index within SOURCE) and
     writing to a block starting at TARGET_START.

     It is permitted for the SOURCE and TARGET regions to overlap.  In
     that case, copying takes place as if the source is first copied
     into a temporary bytevector and then into the destination.

bytevector-copy

- Scheme Procedure: bytevector-copy bv
     Return a newly allocated copy of BV.

uniform-array->bytevector

- Scheme Procedure: uniform-array->bytevector array
     Return a newly allocated bytevector whose contents will be copied
     from the uniform array ARRAY.

bytevector-u8-ref

- Scheme Procedure: bytevector-u8-ref bv index
     Return the octet located at INDEX in BV.

bytevector-s8-ref

- Scheme Procedure: bytevector-s8-ref bv index
     Return the byte located at INDEX in BV.

bytevector-u8-set!

- Scheme Procedure: bytevector-u8-set! bv index value
     Return the octet located at INDEX in BV.

bytevector-s8-set!

- Scheme Procedure: bytevector-s8-set! bv index value
     Return the octet located at INDEX in BV.

bytevector->u8-list

- Scheme Procedure: bytevector->u8-list bv
     Return a newly allocated list of octets containing the contents of
     BV.

u8-list->bytevector

- Scheme Procedure: u8-list->bytevector lst
     Turn LST, a list of octets, into a bytevector.

bytevector-uint-ref

- Scheme Procedure: bytevector-uint-ref bv index endianness size
     Return the SIZE-octet long unsigned integer at index INDEX in BV.

bytevector-sint-ref

- Scheme Procedure: bytevector-sint-ref bv index endianness size
     Return the SIZE-octet long unsigned integer at index INDEX in BV.

bytevector-uint-set!

- Scheme Procedure: bytevector-uint-set! bv index value endianness size
     Set the SIZE-octet long unsigned integer at INDEX to VALUE.

bytevector-sint-set!

- Scheme Procedure: bytevector-sint-set! bv index value endianness size
     Set the SIZE-octet long signed integer at INDEX to VALUE.

bytevector->sint-list

- Scheme Procedure: bytevector->sint-list bv endianness size
     Return a list of signed integers of SIZE octets representing the
     contents of BV.

bytevector->uint-list

- Scheme Procedure: bytevector->uint-list bv endianness size
     Return a list of unsigned integers of SIZE octets representing the
     contents of BV.

uint-list->bytevector

- Scheme Procedure: uint-list->bytevector lst endianness size
     Return a bytevector containing the unsigned integers listed in LST
     and encoded on SIZE octets according to ENDIANNESS.

sint-list->bytevector

- Scheme Procedure: sint-list->bytevector lst endianness size
     Return a bytevector containing the signed integers listed in LST
     and encoded on SIZE octets according to ENDIANNESS.

bytevector-u16-ref

- Scheme Procedure: bytevector-u16-ref bv index endianness
     Return the unsigned 16-bit integer from BV at INDEX.

bytevector-s16-ref

- Scheme Procedure: bytevector-s16-ref bv index endianness
     Return the signed 16-bit integer from BV at INDEX.

bytevector-u16-native-ref

- Scheme Procedure: bytevector-u16-native-ref bv index
     Return the unsigned 16-bit integer from BV at INDEX using the
     native endianness.

bytevector-s16-native-ref

- Scheme Procedure: bytevector-s16-native-ref bv index
     Return the unsigned 16-bit integer from BV at INDEX using the
     native endianness.

bytevector-u16-set!

- Scheme Procedure: bytevector-u16-set! bv index value endianness
     Store VALUE in BV at INDEX according to ENDIANNESS.

bytevector-s16-set!

- Scheme Procedure: bytevector-s16-set! bv index value endianness
     Store VALUE in BV at INDEX according to ENDIANNESS.

bytevector-u16-native-set!

- Scheme Procedure: bytevector-u16-native-set! bv index value
     Store the unsigned integer VALUE at index INDEX of BV using the
     native endianness.

bytevector-s16-native-set!

- Scheme Procedure: bytevector-s16-native-set! bv index value
     Store the signed integer VALUE at index INDEX of BV using the
     native endianness.

bytevector-u32-ref

- Scheme Procedure: bytevector-u32-ref bv index endianness
     Return the unsigned 32-bit integer from BV at INDEX.

bytevector-s32-ref

- Scheme Procedure: bytevector-s32-ref bv index endianness
     Return the signed 32-bit integer from BV at INDEX.

bytevector-u32-native-ref

- Scheme Procedure: bytevector-u32-native-ref bv index
     Return the unsigned 32-bit integer from BV at INDEX using the
     native endianness.

bytevector-s32-native-ref

- Scheme Procedure: bytevector-s32-native-ref bv index
     Return the unsigned 32-bit integer from BV at INDEX using the
     native endianness.

bytevector-u32-set!

- Scheme Procedure: bytevector-u32-set! bv index value endianness
     Store VALUE in BV at INDEX according to ENDIANNESS.

bytevector-s32-set!

- Scheme Procedure: bytevector-s32-set! bv index value endianness
     Store VALUE in BV at INDEX according to ENDIANNESS.

bytevector-u32-native-set!

- Scheme Procedure: bytevector-u32-native-set! bv index value
     Store the unsigned integer VALUE at index INDEX of BV using the
     native endianness.

bytevector-s32-native-set!

- Scheme Procedure: bytevector-s32-native-set! bv index value
     Store the signed integer VALUE at index INDEX of BV using the
     native endianness.

bytevector-u64-ref

- Scheme Procedure: bytevector-u64-ref bv index endianness
     Return the unsigned 64-bit integer from BV at INDEX.

bytevector-s64-ref

- Scheme Procedure: bytevector-s64-ref bv index endianness
     Return the signed 64-bit integer from BV at INDEX.

bytevector-u64-native-ref

- Scheme Procedure: bytevector-u64-native-ref bv index
     Return the unsigned 64-bit integer from BV at INDEX using the
     native endianness.

bytevector-s64-native-ref

- Scheme Procedure: bytevector-s64-native-ref bv index
     Return the unsigned 64-bit integer from BV at INDEX using the
     native endianness.

bytevector-u64-set!

- Scheme Procedure: bytevector-u64-set! bv index value endianness
     Store VALUE in BV at INDEX according to ENDIANNESS.

bytevector-s64-set!

- Scheme Procedure: bytevector-s64-set! bv index value endianness
     Store VALUE in BV at INDEX according to ENDIANNESS.

bytevector-u64-native-set!

- Scheme Procedure: bytevector-u64-native-set! bv index value
     Store the unsigned integer VALUE at index INDEX of BV using the
     native endianness.

bytevector-s64-native-set!

- Scheme Procedure: bytevector-s64-native-set! bv index value
     Store the signed integer VALUE at index INDEX of BV using the
     native endianness.

bytevector-ieee-single-ref

- Scheme Procedure: bytevector-ieee-single-ref bv index endianness
     Return the IEEE-754 single from BV at INDEX.

bytevector-ieee-single-native-ref

- Scheme Procedure: bytevector-ieee-single-native-ref bv index
     Return the IEEE-754 single from BV at INDEX using the native
     endianness.

bytevector-ieee-single-set!

- Scheme Procedure: bytevector-ieee-single-set! bv index value
endianness
     Store real VALUE in BV at INDEX according to ENDIANNESS.

bytevector-ieee-single-native-set!

- Scheme Procedure: bytevector-ieee-single-native-set! bv index value
     Store the real VALUE at index INDEX of BV using the native
     endianness.

bytevector-ieee-double-ref

- Scheme Procedure: bytevector-ieee-double-ref bv index endianness
     Return the IEEE-754 double from BV at INDEX.

bytevector-ieee-double-native-ref

- Scheme Procedure: bytevector-ieee-double-native-ref bv index
     Return the IEEE-754 double from BV at INDEX using the native
     endianness.

bytevector-ieee-double-set!

- Scheme Procedure: bytevector-ieee-double-set! bv index value
endianness
     Store real VALUE in BV at INDEX according to ENDIANNESS.

bytevector-ieee-double-native-set!

- Scheme Procedure: bytevector-ieee-double-native-set! bv index value
     Store the real VALUE at index INDEX of BV using the native
     endianness.

string->utf8

- Scheme Procedure: string->utf8 str
     Return a newly allocated bytevector that contains the UTF-8
     encoding of STR.

string->utf16

- Scheme Procedure: string->utf16 str [endianness]
     Return a newly allocated bytevector that contains the UTF-16
     encoding of STR.

string->utf32

- Scheme Procedure: string->utf32 str [endianness]
     Return a newly allocated bytevector that contains the UTF-32
     encoding of STR.

utf8->string

- Scheme Procedure: utf8->string utf
     Return a newly allocate string that contains from the UTF-8-encoded
     contents of bytevector UTF.

utf16->string

- Scheme Procedure: utf16->string utf [endianness]
     Return a newly allocate string that contains from the
     UTF-16-encoded contents of bytevector UTF.

utf32->string

- Scheme Procedure: utf32->string utf [endianness]
     Return a newly allocate string that contains from the
     UTF-32-encoded contents of bytevector UTF.

char?

- Scheme Procedure: char? x
     Return `#t' iff X is a character, else `#f'.

char=?

- Scheme Procedure: char=? [x [y .  rest]]
     Return `#t' if the Unicode code point of X is equal to the code
     point of Y, else `#f'.

char<?

- Scheme Procedure: char<? [x [y .  rest]]
     Return `#t' iff the code point of X is less than the code point of
     Y, else `#f'.

char<=?

- Scheme Procedure: char<=? [x [y .  rest]]
     Return `#t' if the Unicode code point of X is less than or equal to
     the code point of Y, else `#f'.

char>?

- Scheme Procedure: char>? [x [y .  rest]]
     Return `#t' if the Unicode code point of X is greater than the code
     point of Y, else `#f'.

char>=?

- Scheme Procedure: char>=? [x [y .  rest]]
     Return `#t' if the Unicode code point of X is greater than or equal
     to the code point of Y, else `#f'.

char-ci=?

- Scheme Procedure: char-ci=? [x [y .  rest]]
     Return `#t' if the case-folded Unicode code point of X is the same
     as the case-folded code point of Y, else `#f'.

char-ci<?

- Scheme Procedure: char-ci<? [x [y .  rest]]
     Return `#t' if the case-folded Unicode code point of X is less than
     the case-folded code point of Y, else `#f'.

char-ci<=?

- Scheme Procedure: char-ci<=? [x [y .  rest]]
     Return `#t' iff the case-folded Unicode code point of X is less
     than or equal to the case-folded code point of Y, else `#f'

char-ci>?

- Scheme Procedure: char-ci>? [x [y .  rest]]
     Return `#t' iff the case-folded code point of X is greater than the
     case-folded code point of Y, else `#f'.

char-ci>=?

- Scheme Procedure: char-ci>=? [x [y .  rest]]
     Return `#t' iff the case-folded Unicode code point of X is greater
     than or equal to the case-folded code point of Y, else `#f'.

char-alphabetic?

- Scheme Procedure: char-alphabetic? chr
     Return `#t' iff CHR is alphabetic, else `#f'.

char-numeric?

- Scheme Procedure: char-numeric? chr
     Return `#t' iff CHR is numeric, else `#f'.

char-whitespace?

- Scheme Procedure: char-whitespace? chr
     Return `#t' iff CHR is whitespace, else `#f'.

char-upper-case?

- Scheme Procedure: char-upper-case? chr
     Return `#t' iff CHR is uppercase, else `#f'.

char-lower-case?

- Scheme Procedure: char-lower-case? chr
     Return `#t' iff CHR is lowercase, else `#f'.

char-is-both?

- Scheme Procedure: char-is-both? chr
     Return `#t' iff CHR is either uppercase or lowercase, else `#f'.

char->integer

- Scheme Procedure: char->integer chr
     Return the Unicode code point of CHR.

integer->char

- Scheme Procedure: integer->char n
     Return the character that has Unicode code point N.  The integer N
     must be a valid code point.  Valid code points are in the ranges 0
     to `#xD7FF' inclusive or `#xE000' to `#x10FFFF' inclusive.

char-upcase

- Scheme Procedure: char-upcase chr
     Return the uppercase character version of CHR.

char-downcase

- Scheme Procedure: char-downcase chr
     Return the lowercase character version of CHR.

char-titlecase

- Scheme Procedure: char-titlecase chr
     Return the titlecase character version of CHR.

char-general-category

- Scheme Procedure: char-general-category chr
     Return a symbol representing the Unicode general category of CHR or
     `#f' if a named category cannot be found.

abort-to-prompt*

- Scheme Procedure: abort-to-prompt* tag args
     Abort to the nearest prompt with tag TAG, yielding the values in
     the list, ARGS.

with-continuation-barrier

- Scheme Procedure: with-continuation-barrier proc
     Call PROC and return its result.  Do not allow the invocation of
     continuations that would leave or enter the dynamic extent of the
     call to `with-continuation-barrier'.  Such an attempt causes an
     error to be signaled.

     Throws (such as errors) that are not caught from within PROC are
     caught by `with-continuation-barrier'.  In that case, a short
     message is printed to the current error port and `#f' is returned.

     Thus, `with-continuation-barrier' returns exactly once.

%make-custom-port

- Scheme Procedure: %make-custom-port input_p output_p stream encoding
conversion_strategy close_on_gc_p
%custom-port-data

- Scheme Procedure: %custom-port-data port
debug-options-interface

- Scheme Procedure: debug-options-interface [setting]
     Option interface for the debug options.  Instead of using this
     procedure directly, use the procedures `debug-enable',
     `debug-disable', `debug-set!' and `debug-options'.

bitvector-ref

- Scheme Procedure: bitvector-ref vec idx
     Return the element at index IDX of the bitvector VEC.

bitvector-set!

- Scheme Procedure: bitvector-set! vec idx val
     Set the element at index IDX of the bitvector VEC when VAL is true,
     else clear it.

bitvector-fill!

- Scheme Procedure: bitvector-fill! vec val
     Set all elements of the bitvector VEC when VAL is true, else clear
     them.

bit-invert!

- Scheme Procedure: bit-invert! v
     Modify the bit vector V by replacing each element with its
     negation.

bit-count

- Scheme Procedure: bit-count b bitvector
     Return the number of occurrences of the boolean B in BITVECTOR.

bit-count*

- Scheme Procedure: bit-count* v kv obj
     Return a count of how many entries in bit vector V are equal to
     OBJ, with KV selecting the entries to consider.

     If KV is a bit vector, then those entries where it has `#t' are the
     ones in V which are considered.  KV and V must be the same length.

     If KV is a u32vector, then it contains the indexes in V to
     consider.

     For example,

          (bit-count* #*01110111 #*11001101 #t) ==> 3
          (bit-count* #*01110111 #u32(7 0 4) #f)  ==> 2

bit-position

- Scheme Procedure: bit-position item v k
     Return the index of the first occurrence of ITEM in bit vector V,
     starting from K.  If there is no ITEM entry between K and the end
     of V, then return `#f'.  For example,

          (bit-position #t #*000101 0)  ==> 3
          (bit-position #f #*0001111 3) ==> #f

bit-set*!

- Scheme Procedure: bit-set*! v kv obj
     Set entries of bit vector V to OBJ, with KV selecting the entries
     to change.  The return value is unspecified.

     If KV is a bit vector, then those entries where it has `#t' are the
     ones in V which are set to OBJ.  V must be at least as long as KV.
     When OBJ is `#t' it's like KV is OR'ed into V.  Or when OBJ is `#f'
     it can be seen as an ANDNOT.

          (define bv #*01000010)
          (bit-set*! bv #*10010001 #t)
          bv
          ==> #*11010011

     If KV is a u32vector, then its elements are indices into V which
     are set to OBJ.

          (define bv #*01000010)
          (bit-set*! bv #u32(5 2 7) #t)
          bv
          ==> #*01100111

symbol-fref

- Scheme Procedure: symbol-fref s
     Return the contents of the symbol S's "function slot".

symbol-pref

- Scheme Procedure: symbol-pref s
     Return the "property list" currently associated with the symbol S.

symbol-fset!

- Scheme Procedure: symbol-fset! s val
     Change the binding of the symbol S's function slot.

symbol-pset!

- Scheme Procedure: symbol-pset! s val
     Change the binding of the symbol S's property slot.

dynamic-unlink

- Scheme Procedure: dynamic-unlink obj
issue-deprecation-warning

- Scheme Procedure: issue-deprecation-warning .  msgs
     Output MSGS to `(current-error-port)' when this is the first call
     to `issue-deprecation-warning' with this specific MSGS.  Do nothing
     otherwise.  The argument MSGS should be a list of strings; they are
     printed in turn, each one followed by a newline.

include-deprecated-features

- Scheme Procedure: include-deprecated-features
     Return `#t' iff deprecated features should be included in public
     interfaces.

dlopen

- Scheme Procedure: dlopen name flags
dlclose

- Scheme Procedure: dlclose obj
dlsym

- Scheme Procedure: dlsym obj name
eq?

- Scheme Procedure: eq? [x [y .  rest]]
     Return `#t' if X and Y are the same object, except for numbers and
     characters.  For example,

          (define x (vector 1 2 3))
          (define y (vector 1 2 3))
          
          (eq? x x)  ==> #t
          (eq? x y)  ==> #f

     Numbers and characters are not equal to any other object, but the
     problem is they're not necessarily `eq?' to themselves either.  This
     is even so when the number comes directly from a variable,

          (let ((n (+ 2 3)))
            (eq? n n))       ==> *unspecified*

     Generally `eqv?' should be used when comparing numbers or
     characters.  `=' or `char=?' can be used too.

     It's worth noting that end-of-list `()', `#t', `#f', a symbol of a
     given name, and a keyword of a given name, are unique objects.
     There's just one of each, so for instance no matter how `()' arises
     in a program, it's the same object and can be compared with `eq?',

          (define x (cdr '(123)))
          (define y (cdr '(456)))
          (eq? x y) ==> #t
          
          (define x (string->symbol "foo"))
          (eq? x 'foo) ==> #t

eqv?

- Scheme Procedure: eqv? [x [y .  rest]]
     Return `#t' if X and Y are the same object, or for characters and
     numbers the same value.

     On objects except characters and numbers, `eqv?' is the same as
     `eq?', it's true if X and Y are the same object.

     If X and Y are numbers or characters, `eqv?' compares their type
     and value.  An exact number is not `eqv?' to an inexact number
     (even if their value is the same).

          (eqv? 3 (+ 1 2)) ==> #t
          (eqv? 1 1.0)     ==> #f

equal?

- Scheme Procedure: equal? [x [y .  rest]]
     Return `#t' if X and Y are the same type, and their contents or
     value are equal.

     For a pair, string, vector or array, `equal?' compares the
     contents, and does so using using the same `equal?' recursively, so
     a deep structure can be traversed.

          (equal? (list 1 2 3) (list 1 2 3))   ==> #t
          (equal? (list 1 2 3) (vector 1 2 3)) ==> #f

     For other objects, `equal?' compares as per `eqv?', which means
     characters and numbers are compared by type and value (and like
     `eqv?', exact and inexact numbers are not `equal?', even if their
     value is the same).

          (equal? 3 (+ 1 2)) ==> #t
          (equal? 1 1.0)     ==> #f

     Hash tables are currently only compared as per `eq?', so two
     different tables are not `equal?', even if their contents are the
     same.

     `equal?' does not support circular data structures, it may go into
     an infinite loop if asked to compare two circular lists or similar.

     New application-defined object types (Smobs) have an `equalp'
     handler which is called by `equal?'.  This lets an application
     traverse the contents or control what is considered `equal?' for
     two such objects.  If there's no handler, the default is to just
     compare as per `eq?'.

scm-error

- Scheme Procedure: scm-error key subr message args data
     Raise an error with key KEY.  SUBR can be a string naming the
     procedure associated with the error, or `#f'.  MESSAGE is the error
     message string, possibly containing `~S' and `~A' escapes.  When an
     error is reported, these are replaced by formatting the
     corresponding members of ARGS: `~A' (was `%s' in older versions of
     Guile) formats using `display' and `~S' (was `%S') formats using
     `write'.  DATA is a list or `#f' depending on KEY: if KEY is
     `system-error' then it should be a list containing the Unix `errno'
     value; If KEY is `signal' then it should be a list containing the
     Unix signal number; If KEY is `out-of-range', `wrong-type-arg', or
     `keyword-argument-error', it is a list containing the bad value;
     otherwise it will usually be `#f'.

strerror

- Scheme Procedure: strerror err
     Return the Unix error message corresponding to ERR, which must be
     an integer value.

eval

- Scheme Procedure: eval exp module_or_state
     Evaluate EXP, a list representing a Scheme expression, in the
     top-level environment specified by MODULE_OR_STATE.  While EXP is
     evaluated (using `primitive-eval'), MODULE_OR_STATE is made the
     current module when it is a module, or the current dynamic state
     when it is a dynamic state.Example: (eval '(+ 1 2)
     (interaction-environment))

defined?

- Scheme Procedure: defined? sym [module]
     Return `#t' if SYM is defined in the module MODULE or the current
     module when MODULE is notspecified.

self-evaluating?

- Scheme Procedure: self-evaluating? obj
     Return #t for objects which Guile considers self-evaluating

macroexpand

- Scheme Procedure: macroexpand exp
     Expand the expression EXP.

macroexpanded?

- Scheme Procedure: macroexpanded? exp
     Return `#t' if EXP is an expanded expression.

load-extension

- Scheme Procedure: load-extension lib init
     Load and initialize the extension designated by LIB and INIT.  When
     there is no pre-registered function for LIB/INIT, this is
     equivalent to

          (dynamic-call INIT (dynamic-link LIB))

     When there is a pre-registered function, that function is called
     instead.

     Normally, there is no pre-registered function.  This option exists
     only for situations where dynamic linking is unavailable or
     unwanted.  In that case, you would statically link your program
     with the desired library, and register its init function right
     after Guile has been initialized.

     LIB should be a string denoting a shared library without any file
     type suffix such as ".so".  The suffix is provided automatically.
     It should also not contain any directory components.  Libraries
     that implement Guile Extensions should be put into the normal
     locations for shared libraries.  We recommend to use the naming
     convention libguile-bla-blum for a extension related to a module
     `(bla blum)'.

     The normal way for a extension to be used is to write a small
     Scheme file that defines a module, and to load the extension into
     this module.  When the module is auto-loaded, the extension is
     loaded as well.  For example,

          (define-module (bla blum))
          
          (load-extension "libguile-bla-blum" "bla_init_blum")

add-fdes-finalizer!

- Scheme Procedure: add-fdes-finalizer! fd finalizer
     Add a finalizer that will be called when FD is closed.

remove-fdes-finalizer!

- Scheme Procedure: remove-fdes-finalizer! fd finalizer
     Remove a finalizer that was previously added to the file descriptor
     FD.

program-arguments

- Scheme Procedure: program-arguments


     Return the list of command line arguments passed to Guile, as a
     list of strings.  The list includes the invoked program name, which
     is usually `"guile"', but excludes switches and parameters for
     command line options like `-e' and `-l'.

set-program-arguments

- Scheme Procedure: set-program-arguments lst
     Set the command line arguments to be returned by
     `program-arguments' (and `command-line').  LST should be a list of
     strings, the first of which is the program name (either a script
     name, or just `"guile"').

     Program arguments are held in a fluid and therefore have a separate
     value in each Guile thread.  Neither the list nor the strings
     within it are copied, so should not be modified later.

chown

- Scheme Procedure: chown object owner group
     Change the ownership and group of the file referred to by OBJECT to
     the integer values OWNER and GROUP.  OBJECT can be a string
     containing a file name or, if the platform supports fchown, a port
     or integer file descriptor which is open on the file.  The return
     value is unspecified.

     If OBJECT is a symbolic link, either the ownership of the link or
     the ownership of the referenced file will be changed depending on
     the operating system (lchown is unsupported at present).  If OWNER
     or GROUP is specified as `-1', then that ID is not changed.

chown-at

- Scheme Procedure: chown-at dir name owner group [flags]
     Like `chown', but modify the owner and/or group of the file named
     NAME in the directory referred to by the file port DIR instead.  The
     optional argument FLAGS is a bitmask.  If `AT_SYMLINK_NOFOLLOW' is
     present, then NAME will not be dereferenced if it is a symbolic
     link.

open-fdes

- Scheme Procedure: open-fdes path flags [mode]
     Similar to `open' but return a file descriptor instead of a port.

open-fdes-at

- Scheme Procedure: open-fdes-at dir path flags [mode]
     Similar to `openat', but return a file descriptor instead of a
     port.

open

- Scheme Procedure: open path flags [mode]
     Open the file named by PATH for reading and/or writing.  FLAGS is
     an integer specifying how the file should be opened.  MODE is an
     integer specifying the permission bits of the file, if it needs to
     be created, before the umask is applied.  The default is 666 (Unix
     itself has no default).

     FLAGS can be constructed by combining variables using `logior'.
     Basic flags are:

     - Variable: O_RDONLY
          Open the file read-only.

     - Variable: O_WRONLY
          Open the file write-only.

     - Variable: O_RDWR
          Open the file read/write.

     - Variable: O_APPEND
          Append to the file instead of truncating.

     - Variable: O_CREAT
          Create the file if it does not already exist.

     See the Unix documentation of the `open' system call for additional
     flags.

openat

- Scheme Procedure: openat dir path flags [mode]
     Similar to `open', but resolve the file name PATH relative to the
     directory referred to by the file port DIR instead.

close

- Scheme Procedure: close fd_or_port
     Similar to close-port (see close-port), but also works on file
     descriptors.  A side effect of closing a file descriptor is that
     any ports using that file descriptor are moved to a different file
     descriptor and have their revealed counts set to zero.

close-fdes

- Scheme Procedure: close-fdes fd
     A simple wrapper for the `close' system call.  Close file
     descriptor FD, which must be an integer.  Unlike close (see close),
     the file descriptor will be closed even if a port is using it.  The
     return value is unspecified.

stat

- Scheme Procedure: stat object [exception_on_error]
     Return an object containing various information about the file
     determined by OBJECT.  OBJECT can be a string containing a file
     name or a port or integer file descriptor which is open on a file
     (in which case `fstat' is used as the underlying system call).

     If the optional EXCEPTION_ON_ERROR argument is true, which is the
     default, an exception will be raised if the underlying system call
     returns an error, for example if the file is not found or is not
     readable.  Otherwise, an error will cause `stat' to return `#f'.
     The object returned by a successful call to `stat' can be passed as
     a single parameter to the following procedures, all of which return
     integers:

     stat:dev
          The device containing the file.

     stat:ino
          The file serial number, which distinguishes this file from all
          other files on the same device.

     stat:mode
          The mode of the file.  This includes file type information and
          the file permission bits.  See `stat:type' and `stat:perms'
          below.

     stat:nlink
          The number of hard links to the file.

     stat:uid
          The user ID of the file's owner.

     stat:gid
          The group ID of the file.

     stat:rdev
          Device ID; this entry is defined only for character or block
          special files.

     stat:size
          The size of a regular file in bytes.

     stat:atime
          The last access time for the file.

     stat:mtime
          The last modification time for the file.

     stat:ctime
          The last modification time for the attributes of the file.

     stat:blksize
          The optimal block size for reading or writing the file, in
          bytes.

     stat:blocks
          The amount of disk space that the file occupies measured in
          units of 512 byte blocks.

     In addition, the following procedures return the information from
     stat:mode in a more convenient form:

     stat:type
          A symbol representing the type of file.  Possible values are
          regular, directory, symlink, block-special, char-special,
          fifo, socket and unknown

     stat:perms
          An integer representing the access permission bits.

statat

- Scheme Procedure: statat dir filename [flags]
     Like `stat', but resolve FILENAME relative to the directory
     referred to by the file port DIR instead.

     The optional argument FLAGS argument can be `AT_SYMLINK_NOFOLLOW',
     in which case FILENAME will not be dereferenced even if it is a
     symbolic link.

lstat

- Scheme Procedure: lstat str
     Similar to `stat', but does not follow symbolic links, i.e., it
     will return information about a symbolic link itself, not the file
     it points to.  STR must be a string.

link

- Scheme Procedure: link oldpath newpath
     Creates a new name NEWPATH in the file system for the file named by
     OLDPATH.  If OLDPATH is a symbolic link, the link may or may not be
     followed depending on the system.

chdir

- Scheme Procedure: chdir str
     Change the current working directory to STR.  STR can be a string
     containing a file name, or a port if supported by the system.
     `(provided? 'chdir-port)' reports whether ports are supported.The
     return value is unspecified.

select

- Scheme Procedure: select reads writes excepts [secs [usecs]]
     This procedure has a variety of uses: waiting for the ability to
     provide input, accept output, or the existence of exceptional
     conditions on a collection of ports or file descriptors, or waiting
     for a timeout to occur.

     When an error occurs, this procedure throws a `system-error'
     exception (see `system-error').

     READS, WRITES and EXCEPTS can be lists or vectors, with each member
     a port or a file descriptor.  The value returned is a list of three
     corresponding lists or vectors containing only the members which
     meet the specified requirement.  The ability of port buffers to
     provide input or accept output is taken into account.  Ordering of
     the input lists or vectors is not preserved.

     The optional arguments SECS and USECS specify the timeout.  Either
     SECS can be specified alone, as either an integer or a real number,
     or both SECS and USECS can be specified as integers, in which case
     USECS is an additional timeout expressed in microseconds.  If SECS
     is omitted or is `#f' then select will wait for as long as it takes
     for one of the other conditions to be satisfied.

     The scsh version of `select' differs as follows: Only vectors are
     accepted for the first three arguments.  The USECS argument is not
     supported.  Multiple values are returned instead of a list.
     Duplicates in the input vectors appear only once in output.  An
     additional `select!' interface is provided.

fcntl

- Scheme Procedure: fcntl object cmd [value]
     Apply CMD to the specified file descriptor or the underlying file
     descriptor of the specified port.  VALUE is an optional integer
     argument.

     Values for CMD are:

     F_DUPFD
          Duplicate a file descriptor

     F_GETFD
          Get flags associated with the file descriptor.

     F_SETFD
          Set flags associated with the file descriptor to VALUE.

     F_GETFL
          Get flags associated with the open file.

     F_SETFL
          Set flags associated with the open file to VALUE

     F_GETOWN
          Get the process ID of a socket's owner, for `SIGIO' signals.

     F_SETOWN
          Set the process that owns a socket to VALUE, for `SIGIO'
          signals.

     FD_CLOEXEC
          The value used to indicate the "close on exec" flag with
          `F_GETFL' or `F_SETFL'.

fsync

- Scheme Procedure: fsync object
     Copies any unwritten data for the specified output file descriptor
     to disk.  If OBJECT is a port, its buffer is flushed before the
     underlying file descriptor is fsync'd.  The return value is
     unspecified.

symlink

- Scheme Procedure: symlink oldpath newpath
     Create a symbolic link named NEWPATH with the value (i.e., pointing
     to) OLDPATH.  The return value is unspecified.

symlinkat

- Scheme Procedure: symlinkat dir oldpath newpath
     Like `symlink', but resolve NEWPATH relative to the directory
     referred to by the file port DIR.

readlink

- Scheme Procedure: readlink path
     Return the value of the symbolic link named by PATH (a string, or a
     port if supported by the system), i.e., the file that the link
     points to.  To read a symbolic link represented by a port, the
     symbolic link must have been opened with the `O_NOFOLLOW' and
     `O_PATH' flags.`(provided? 'readlink-port)' reports whether ports
     are supported.

copy-file

- Scheme Procedure: copy-file oldfile newfile .  rest
     Copy the file specified by OLDFILE to NEWFILE.  The return value is
     unspecified.

     `#:copy-on-write' keyword argument determines whether copy-on-write
     copy should be attempted and the behavior in case of failure.
     Possible values are `'always' (attempt the copy-on-write, return
     error if it fails), `'auto' (attempt the copy-on-write, fallback to
     regular copy if it fails) and `'never' (perform the regular copy).

sendfile

- Scheme Procedure: sendfile out in count [offset]
     Send COUNT bytes from IN to OUT, both of which must be either open
     file ports or file descriptors.  When OFFSET is omitted, start
     reading from IN's current position; otherwise, start reading at
     OFFSET.  Return the number of bytes actually sent.

getcwd

- Scheme Procedure: getcwd
     Return the name of the current working directory.

mkdir

- Scheme Procedure: mkdir path [mode]
     Create a new directory named by PATH.  If MODE is omitted then the
     permissions of the directory are set to `#o777' masked with the
     current umask (see `umask').  Otherwise they are set to the value
     specified with MODE.  The return value is unspecified.

mkdirat

- Scheme Procedure: mkdirat dir path [mode]
     Like `mkdir', but resolve PATH relative to the directory referred
     to by the file port DIR instead.

rmdir

- Scheme Procedure: rmdir path
     Remove the existing directory named by PATH.  The directory must be
     empty for this to succeed.  The return value is unspecified.

rename-file

- Scheme Procedure: rename-file oldname newname
     Renames the file specified by OLDNAME to NEWNAME.  The return value
     is unspecified.

rename-file-at

- Scheme Procedure: rename-file-at olddir oldname newdir newname
     Like `rename-file', but when OLDDIR or NEWDIR is true, resolve
     OLDNAME or NEWNAME relative to the directory specified by file port
     OLDDIR or NEWDIR instead of the current working directory.

delete-file

- Scheme Procedure: delete-file str
     Deletes (or "unlinks") the file specified by STR.

delete-file-at

- Scheme Procedure: delete-file-at dir str [flags]
     Like `unlink', but resolve STR relative to the directory referred
     to by the file port DIR instead.

     The optional FLAGS argument can be `AT_REMOVEDIR', in which case
     `delete-file-at' will act like `rmdir' instead of `delete-file'.
     Why doesn't POSIX have a `rmdirat' function for this instead? No
     idea!

access?

- Scheme Procedure: access? path how
     Test accessibility of a file under the real UID and GID of the
     calling process.  The return is `#t' if PATH exists and the
     permissions requested by HOW are all allowed, or `#f' if not.

     HOW is an integer which is one of the following values, or a
     bitwise-OR (`logior') of multiple values.

     - Variable: R_OK
          Test for read permission.

     - Variable: W_OK
          Test for write permission.

     - Variable: X_OK
          Test for execute permission.

     - Variable: F_OK
          Test for existence of the file.  This is implied by each of
          the other tests, so there's no need to combine it with them.

     It's important to note that `access?' does not simply indicate what
     will happen on attempting to read or write a file.  In normal
     circumstances it does, but in a set-UID or set-GID program it
     doesn't because `access?' tests the real ID, whereas an open or
     execute attempt uses the effective ID.

     A program which will never run set-UID/GID can ignore the
     difference between real and effective IDs, but for maximum
     generality, especially in library functions, it's best not to use
     `access?' to predict the result of an open or execute, instead
     simply attempt that and catch any exception.

     The main use for `access?' is to let a set-UID/GID program
     determine what the invoking user would have been allowed to do,
     without the greater (or perhaps lesser) privileges afforded by the
     effective ID.  For more on this, see ``Testing File Access'' in The
     GNU C Library Reference Manual.

chmod

- Scheme Procedure: chmod object mode
     Changes the permissions of the file referred to by OBJECT.  OBJECT
     can be a string containing a file name or a port or integer file
     descriptor which is open on a file (in which case `fchmod' is used
     as the underlying system call).  MODE specifies the new permissions
     as a decimal number, e.g., `(chmod "foo" #o755)'.  The return value
     is unspecified.

chmodat

- Scheme Procedure: chmodat dir pathname mode [flags]
     Like CHMOD, but modify the permissions of the file named PATHNAME
     in the directory referred to by the file port DIR instead.  The
     optional FLAGS argument may be 0 or `AT_SYMLINK_NOFOLLOW', in which
     case PATHNAME is not dereferenced if it is a symbolic link, i.e.,
     the permissions of the symbolic link itself are modified.

     Note that `AT_SYMLINK_NOFOLLOW' is not supported on all systems and
     may result in `ENOTSUP'.

umask

- Scheme Procedure: umask [mode]
     If MODE is omitted, returns a decimal number representing the
     current file creation mask.  Otherwise the file creation mask is
     set to MODE and the previous value is returned.

     E.g., `(umask #o022)' sets the mask to octal 22, decimal 18.

mkstemp

- Scheme Procedure: mkstemp tmpl [mode]
     Create a new unique file in the file system.  Return a buffered
     port open for reading and writing to the file.

     TMPL is a string specifying where the file should be created: it
     must end with `XXXXXX'.  The name of the newly created file will be
     the same as TMPL, but with those `X's changed, and can be
     determined by calling `port-filename' on the returned port.

     Note that the newly created file is not deleted automatically by
     Guile; probably the caller should arrange to call `delete-file'
     when the file is no longer needed.

     POSIX doesn't specify the permissions mode of the file.  On GNU and
     most systems it's `#o600'.  An application can use `chmod' to relax
     that if desired.  For example `#o666' less `umask', which is usual
     for ordinary file creation,

          (let ((port (mkstemp "/tmp/myfile-XXXXXX")))
            (chmod port (logand #o666 (lognot (umask))))
            ...)

     The optional MODE argument specifies a mode, as a string in the
     same format that `open-file' takes.  It defaults to `"w+"'.

mkstemp!

- Scheme Procedure: mkstemp! tmpl [mode]
     Create a new unique file in the file system and return a new
     buffered port open for reading and writing to the file.

     TMPL is a string specifying where the file should be created: it
     must end with `XXXXXX' and those `X's will be changed in the string
     to return the name of the file.  (`port-filename' on the port also
     gives the name.)

     POSIX doesn't specify the permissions mode of the file, on GNU and
     most systems it's `#o600'.  An application can use `chmod' to relax
     that if desired.  For example `#o666' less `umask', which is usual
     for ordinary file creation,

          (let ((port (mkstemp! (string-copy "/tmp/myfile-XXXXXX"))))
            (chmod port (logand #o666 (lognot (umask))))
            ...)

     The optional MODE argument specifies a mode, as a string in the
     same format that `open-file' takes.  It defaults to `"w+"'.

mkdtemp

- Scheme Procedure: mkdtemp tmpl
     Create a new unique directory in the file system named in
     accordance with TMPL.  The last six characters of the template must
     be 'XXXXXX'.

     Upon success, this procedure returns the name of the directory
     created.

     An error may be thrown if the template is incorrect or if the
     directory could not be created.

system-file-name-convention

- Scheme Procedure: system-file-name-convention
     Return either `posix' or `windows', depending on what kind of
     system this Guile is running on.

dirname

- Scheme Procedure: dirname filename
     Return the directory name component of the file name FILENAME.  If
     FILENAME does not contain a directory component, `.' is returned.

basename

- Scheme Procedure: basename filename [suffix]
     Return the base name of the file name FILENAME.  The base name is
     the file name without any directory components.  If SUFFIX is
     provided, and is equal to the end of FILENAME, it is removed also.

canonicalize-path

- Scheme Procedure: canonicalize-path path
     Return the canonical path of PATH.  A canonical path has no `.' or
     `..' components, nor any repeated path separators (`/') nor
     symlinks.

     Raises an error if any component of PATH does not exist.

directory-stream?

- Scheme Procedure: directory-stream? obj
     Return a boolean indicating whether OBJ is a directory stream as
     returned by `opendir'.

opendir

- Scheme Procedure: opendir dirname
     Open the directory specified by DIRNAME and return a directory
     stream.

readdir

- Scheme Procedure: readdir port
     Return (as a string) the next directory entry from the directory
     stream PORT.  If there is no remaining entry to be read then the
     end of file object is returned.

rewinddir

- Scheme Procedure: rewinddir port
     Reset the directory port PORT so that the next call to `readdir'
     will return the first directory entry.

closedir

- Scheme Procedure: closedir port
     Close the directory stream PORT.  The return value is unspecified.

make-fluid

- Scheme Procedure: make-fluid [dflt]
     Return a newly created fluid, whose initial value is DFLT, or `#f'
     if DFLT is not given.  Fluids are objects that can hold one value
     per dynamic state.  That is, modifications to this value are only
     visible to code that executes with the same dynamic state as the
     modifying code.  When a new dynamic state is constructed, it
     inherits the values from its parent.  Because each thread normally
     executes with its own dynamic state, you can use fluids for thread
     local storage.

make-unbound-fluid

- Scheme Procedure: make-unbound-fluid
     Make a fluid that is initially unbound.

make-thread-local-fluid

- Scheme Procedure: make-thread-local-fluid [dflt]
     Return a newly created fluid, whose initial value is DFLT, or `#f'
     if DFLT is not given.  Unlike fluids made with `make-fluid', thread
     local fluids are not captured by `make-dynamic-state'.  Similarly,
     a newly spawned child thread does not inherit thread-local fluid
     values from the parent thread.

fluid?

- Scheme Procedure: fluid? obj
     Return `#t' iff OBJ is a fluid; otherwise, return `#f'.

fluid-thread-local?

- Scheme Procedure: fluid-thread-local? fluid
     Return `#t' if the fluid FLUID is is thread local, or `#f'
     otherwise.

fluid-ref

- Scheme Procedure: fluid-ref fluid
     Return the value associated with FLUID in the current dynamic root.
     If FLUID has not been set, then return its default value.

fluid-ref*

- Scheme Procedure: fluid-ref* fluid depth
     Return the DEPTHth oldest value associated with FLUID in the
     current thread.  If DEPTH equals or exceeds the number of values
     that have been assigned to FLUID, return the default value of the
     fluid.

fluid-set!

- Scheme Procedure: fluid-set! fluid value
     Set the value associated with FLUID in the current dynamic root.

fluid-unset!

- Scheme Procedure: fluid-unset! fluid
     Unset the value associated with FLUID.

fluid-bound?

- Scheme Procedure: fluid-bound? fluid
     Return `#t' iff FLUID is bound to a value.  Throw an error if FLUID
     is not a fluid.

with-fluids*

- Scheme Procedure: with-fluids* fluids values thunk
     Set FLUIDS to VALUES temporary, and call THUNK.  FLUIDS must be a
     list of fluids and VALUES must be the same number of their values
     to be applied.  Each substitution is done one after another.  THUNK
     must be a procedure with no argument.

dynamic-state?

- Scheme Procedure: dynamic-state? obj
     Return `#t' if OBJ is a dynamic state object; return `#f' otherwise

current-dynamic-state

- Scheme Procedure: current-dynamic-state
     Return a snapshot of the current fluid-value associations as a
     fresh dynamic state object.

set-current-dynamic-state

- Scheme Procedure: set-current-dynamic-state state
     Set the current dynamic state object to STATE and return the
     previous current dynamic state object.

with-dynamic-state

- Scheme Procedure: with-dynamic-state state proc
     Call PROC while STATE is the current dynamic state object.

pointer?

- Scheme Procedure: pointer? obj
     Return `#t' if OBJ is a pointer object, `#f' otherwise.

make-pointer

- Scheme Procedure: make-pointer address [finalizer]
     Return a foreign pointer object pointing to ADDRESS.  If FINALIZER
     is passed, it should be a pointer to a one-argument C function that
     will be called when the pointer object becomes unreachable.

pointer-address

- Scheme Procedure: pointer-address pointer
     Return the numerical value of POINTER.

pointer->scm

- Scheme Procedure: pointer->scm pointer
     Unsafely cast POINTER to a Scheme object.  Cross your fingers!

scm->pointer

- Scheme Procedure: scm->pointer scm
     Return a foreign pointer object with the `object-address' of SCM.

pointer->bytevector

- Scheme Procedure: pointer->bytevector pointer len [offset [uvec_type]]
     Return a bytevector aliasing the LEN bytes pointed to by POINTER.

     The user may specify an alternate default interpretation for the
     memory by passing the UVEC_TYPE argument, to indicate that the
     memory is an array of elements of that type.  UVEC_TYPE should be
     something that `uniform-vector-element-type' would return, like
     `f32' or `s16'.

     When OFFSET is passed, it specifies the offset in bytes relative to
     POINTER of the memory region aliased by the returned bytevector.

bytevector->pointer

- Scheme Procedure: bytevector->pointer bv [offset]
     Return a pointer pointer aliasing the memory pointed to by BV or
     OFFSET bytes after BV when OFFSET is passed.

set-pointer-finalizer!

- Scheme Procedure: set-pointer-finalizer! pointer finalizer
     Arrange for the C procedure wrapped by FINALIZER to be called on
     the pointer wrapped by POINTER when POINTER becomes unreachable.
     Note: the C procedure should not call into Scheme.  If you need a
     Scheme finalizer, use guardians.

dereference-pointer

- Scheme Procedure: dereference-pointer pointer
     Assuming POINTER points to a memory region that holds a pointer,
     return this pointer.

string->pointer

- Scheme Procedure: string->pointer string [encoding]
     Return a foreign pointer to a nul-terminated copy of STRING in the
     given ENCODING, defaulting to the current locale encoding.  The C
     string is freed when the returned foreign pointer becomes
     unreachable.

     This is the Scheme equivalent of `scm_to_stringn'.

pointer->string

- Scheme Procedure: pointer->string pointer [length [encoding]]
     Return the string representing the C string pointed to by POINTER.
     If LENGTH is omitted or `-1', the string is assumed to be
     nul-terminated.  Otherwise LENGTH is the number of bytes in memory
     pointed to by POINTER.  The C string is assumed to be in the given
     ENCODING, defaulting to the current locale encoding.

     This is the Scheme equivalent of `scm_from_stringn'.

alignof

- Scheme Procedure: alignof type
     Return the alignment of TYPE, in bytes.

     TYPE should be a valid C type, like `int'.  Alternately TYPE may be
     the symbol `*', in which case the alignment of a pointer is
     returned.  TYPE may also be a list of types, in which case the
     alignment of a `struct' with ABI-conventional packing is returned.

sizeof

- Scheme Procedure: sizeof type
     Return the size of TYPE, in bytes.

     TYPE should be a valid C type, like `int'.  Alternately TYPE may be
     the symbol `*', in which case the size of a pointer is returned.
     TYPE may also be a list of types, in which case the size of a
     `struct' with ABI-conventional packing is returned.

pointer->procedure

- Scheme Procedure: pointer->procedure return_type func_ptr arg_types .
keyword_args
     Make a foreign function.

     Given the foreign void pointer FUNC_PTR, its argument and return
     types ARG_TYPES and RETURN_TYPE, return a procedure that will pass
     arguments to the foreign function and return appropriate values.

     ARG_TYPES should be a list of foreign types.  `return_type' should
     be a foreign type.  If the `#:return-errno?' keyword argument is
     provided and its value is true, then the returned procedure will
     return two values, with `errno' as the second value.

procedure->pointer

- Scheme Procedure: procedure->pointer return_type proc arg_types
     Return a pointer to a C function of type RETURN_TYPE taking
     arguments of types ARG_TYPES (a list) and behaving as a proxy to
     procedure PROC.  Thus PROC's arity, supported argument types, and
     return type should match RETURN_TYPE and ARG_TYPES.

file-port?

- Scheme Procedure: file-port? obj
     Determine whether OBJ is a port that is related to a file.

open-file

- Scheme Procedure: open-file filename mode .  keyword_args
     Open the file whose name is FILENAME, and return a port
     representing that file.  The attributes of the port are determined
     by the MODE string.  The way in which this is interpreted is
     similar to C stdio.  The first character must be one of the
     following:

     r
          Open an existing file for input.

     w
          Open a file for output, creating it if it doesn't already
          exist or removing its contents if it does.

     a
          Open a file for output, creating it if it doesn't already
          exist.  All writes to the port will go to the end of the file.
          The "append mode" can be turned off while the port is in use
          see fcntl

     The following additional characters can be appended:

     b
          Open the underlying file in binary mode, if supported by the
          system.  Also, open the file using the binary-compatible
          character encoding "ISO-8859-1", ignoring the default port
          encoding.

     +
          Open the port for both input and output.  E.g., `r+': open an
          existing file for both input and output.

     e
          Mark the underlying file descriptor as close-on-exec, as per
          the `O_CLOEXEC' flag.

     0
          Create an "unbuffered" port.  In this case input and output
          operations are passed directly to the underlying port
          implementation without additional buffering.  This is likely
          to slow down I/O operations.  The buffering mode can be
          changed while a port is in use see setvbuf

     l
          Add line-buffering to the port.  The port output buffer will
          be automatically flushed whenever a newline character is
          written.

     In theory we could create read/write ports which were buffered in
     one direction only.  However this isn't included in the current
     interfaces.  If a file cannot be opened with the access requested,
     `open-file' throws an exception.

port-revealed

- Scheme Procedure: port-revealed port
     Return the revealed count for PORT.

set-port-revealed!

- Scheme Procedure: set-port-revealed! port rcount
     Sets the revealed count for a port to a given value.  The return
     value is unspecified.

adjust-port-revealed!

- Scheme Procedure: adjust-port-revealed! port addend
     Add ADDEND to the revealed count of PORT.  The return value is
     unspecified.

gc-stats

- Scheme Procedure: gc-stats
     Return an association list of statistics about Guile's current use
     of storage.

gc-dump

- Scheme Procedure: gc-dump
     Dump information about the garbage collector's internal data
     structures and memory usage to the standard output.

object-address

- Scheme Procedure: object-address obj
     Return an integer that for the lifetime of OBJ is uniquely returned
     by this function for OBJ

gc-disable

- Scheme Procedure: gc-disable
     Disables the garbage collector.  Nested calls are permitted.  GC is
     re-enabled once `gc-enable' has been called the same number of
     times `gc-disable' was called.

gc-enable

- Scheme Procedure: gc-enable
     Enables the garbage collector.

gc

- Scheme Procedure: gc
     Scans all of SCM objects and reclaims for further use those that
     are no longer accessible.

gettext

- Scheme Procedure: gettext msgid [domain [category]]
     Return the translation of MSGID in the message domain DOMAIN.
     DOMAIN is optional and defaults to the domain set through
     (textdomain).  CATEGORY is optional and defaults to LC_MESSAGES.

ngettext

- Scheme Procedure: ngettext msgid msgid_plural n [domain [category]]
     Return the translation of MSGID/MSGID_PLURAL in the message domain
     DOMAIN, with the plural form being chosen appropriately for the
     number N.  DOMAIN is optional and defaults to the domain set
     through (textdomain).  CATEGORY is optional and defaults to
     LC_MESSAGES.

textdomain

- Scheme Procedure: textdomain [domainname]
     If optional parameter DOMAINNAME is supplied, set the textdomain.
     Return the textdomain.

bindtextdomain

- Scheme Procedure: bindtextdomain domainname [directory]
     If optional parameter DIRECTORY is supplied, set message catalogs
     to directory DIRECTORY.  Return the directory bound to DOMAINNAME.

bind-textdomain-codeset

- Scheme Procedure: bind-textdomain-codeset domainname [encoding]
     If optional parameter ENCODING is supplied, set encoding for
     message catalogs of DOMAINNAME.  Return the encoding of DOMAINNAME.

make-generalized-vector

- Scheme Procedure: make-generalized-vector type len [fill]
     Make a generalized vector

%make-vtable-vtable

- Scheme Procedure: %make-vtable-vtable layout
%init-layout!

- Scheme Procedure: %init-layout! class layout
class-of

- Scheme Procedure: class-of x
     Return the class of X.

instance?

- Scheme Procedure: instance? obj
     Return `#t' if OBJ is an instance.

generic-function-name

- Scheme Procedure: generic-function-name obj
     Return the name of the generic function OBJ.

%clear-fields!

- Scheme Procedure: %clear-fields! obj unbound
%modify-instance

- Scheme Procedure: %modify-instance old new
     Used by change-class to modify objects in place.

generic-capability?

- Scheme Procedure: generic-capability? proc
enable-primitive-generic!

- Scheme Procedure: enable-primitive-generic! .  subrs
set-primitive-generic!

- Scheme Procedure: set-primitive-generic! subr generic
primitive-generic-generic

- Scheme Procedure: primitive-generic-generic subr
%goops-early-init

- Scheme Procedure: %goops-early-init
%goops-loaded

- Scheme Procedure: %goops-loaded
     Announce that GOOPS is loaded and perform initialization on the C
     level which depends on the loaded GOOPS modules.

make-guardian

- Scheme Procedure: make-guardian
     Create a new guardian.  A guardian protects a set of objects from
     garbage collection, allowing a program to apply cleanup or other
     actions.

     `make-guardian' returns a procedure representing the guardian.
     Calling the guardian procedure with an argument adds the argument
     to the guardian's set of protected objects.  Calling the guardian
     procedure without an argument returns one of the protected objects
     which are ready for garbage collection, or `#f' if no such object
     is available.  Objects which are returned in this way are removed
     from the guardian.

     You can put a single object into a guardian more than once and you
     can put a single object into more than one guardian.  The object
     will then be returned multiple times by the guardian procedures.

     An object is eligible to be returned from a guardian when it is no
     longer referenced from outside any guardian.

     There is no guarantee about the order in which objects are returned
     from a guardian.  If you want to impose an order on finalization
     actions, for example, you can do that by keeping objects alive in
     some global data structure until they are no longer needed for
     finalizing other objects.

     Being an element in a weak vector, a key in a hash table with weak
     keys, or a value in a hash table with weak value does not prevent
     an object from being returned by a guardian.  But as long as an
     object can be returned from a guardian it will not be removed from
     such a weak vector or hash table.  In other words, a weak link does
     not prevent an object from being considered collectable, but being
     inside a guardian prevents a weak link from being broken.

     A key in a weak key hash table can be though of as having a strong
     reference to its associated value as long as the key is accessible.
     Consequently, when the key only accessible from within a guardian,
     the reference from the key to the value is also considered to be
     coming from within a guardian.  Thus, if there is no other
     reference to the value, it is eligible to be returned from a
     guardian.

hashq

- Scheme Procedure: hashq key size
     Determine a hash value for KEY that is suitable for lookups in a
     hashtable of size SIZE, where `eq?' is used as the equality
     predicate.  The function returns an integer in the range 0 to SIZE
     - 1.  Note that `hashq' may use internal addresses.  Thus two calls
     to hashq where the keys are `eq?' are not guaranteed to deliver the
     same value if the key object gets garbage collected in between.
     This can happen, for example with symbols: `(hashq 'foo n) (gc)
     (hashq 'foo n)' may produce two different values, since `foo' will
     be garbage collected.

hashv

- Scheme Procedure: hashv key size
     Determine a hash value for KEY that is suitable for lookups in a
     hashtable of size SIZE, where `eqv?' is used as the equality
     predicate.  The function returns an integer in the range 0 to SIZE
     - 1.  Note that `(hashv key)' may use internal addresses.  Thus two
     calls to hashv where the keys are `eqv?' are not guaranteed to
     deliver the same value if the key object gets garbage collected in
     between.  This can happen, for example with symbols: `(hashv 'foo
     n) (gc) (hashv 'foo n)' may produce two different values, since
     `foo' will be garbage collected.

hash

- Scheme Procedure: hash key size
     Determine a hash value for KEY that is suitable for lookups in a
     hashtable of size SIZE, where `equal?' is used as the equality
     predicate.  The function returns an integer in the range 0 to SIZE
     - 1.

make-hash-table

- Scheme Procedure: make-hash-table [n]
     Make a new abstract hash table object with minimum number of
     buckets N

hash-table?

- Scheme Procedure: hash-table? obj
     Return `#t' if OBJ is an abstract hash table object.

hash-clear!

- Scheme Procedure: hash-clear! table
     Remove all items from TABLE (without triggering a resize).

hashq-get-handle

- Scheme Procedure: hashq-get-handle table key
     This procedure returns the `(key .  value)' pair from the hash
     table TABLE.  If TABLE does not hold an associated value for KEY,
     `#f' is returned.  Uses `eq?' for equality testing.

hashq-create-handle!

- Scheme Procedure: hashq-create-handle! table key init
     This function looks up KEY in TABLE and returns its handle.  If KEY
     is not already present, a new handle is created which associates
     KEY with INIT.

hashq-ref

- Scheme Procedure: hashq-ref table key [dflt]
     Look up KEY in the hash table TABLE, and return the value (if any)
     associated with it.  If KEY is not found, return DFLT (or `#f' if
     no DFLT argument is supplied).  Uses `eq?' for equality testing.

hashq-set!

- Scheme Procedure: hashq-set! table key val
     Find the entry in TABLE associated with KEY, and store VAL there.
     Uses `eq?' for equality testing.

hashq-remove!

- Scheme Procedure: hashq-remove! table key
     Remove KEY (and any value associated with it) from TABLE.  Uses
     `eq?' for equality tests.

hashv-get-handle

- Scheme Procedure: hashv-get-handle table key
     This procedure returns the `(key .  value)' pair from the hash
     table TABLE.  If TABLE does not hold an associated value for KEY,
     `#f' is returned.  Uses `eqv?' for equality testing.

hashv-create-handle!

- Scheme Procedure: hashv-create-handle! table key init
     This function looks up KEY in TABLE and returns its handle.  If KEY
     is not already present, a new handle is created which associates
     KEY with INIT.

hashv-ref

- Scheme Procedure: hashv-ref table key [dflt]
     Look up KEY in the hash table TABLE, and return the value (if any)
     associated with it.  If KEY is not found, return DFLT (or `#f' if
     no DFLT argument is supplied).  Uses `eqv?' for equality testing.

hashv-set!

- Scheme Procedure: hashv-set! table key val
     Find the entry in TABLE associated with KEY, and store VALUE there.
     Uses `eqv?' for equality testing.

hashv-remove!

- Scheme Procedure: hashv-remove! table key
     Remove KEY (and any value associated with it) from TABLE.  Uses
     `eqv?' for equality tests.

hash-get-handle

- Scheme Procedure: hash-get-handle table key
     This procedure returns the `(key .  value)' pair from the hash
     table TABLE.  If TABLE does not hold an associated value for KEY,
     `#f' is returned.  Uses `equal?' for equality testing.

hash-create-handle!

- Scheme Procedure: hash-create-handle! table key init
     This function looks up KEY in TABLE and returns its handle.  If KEY
     is not already present, a new handle is created which associates
     KEY with INIT.

hash-ref

- Scheme Procedure: hash-ref table key [dflt]
     Look up KEY in the hash table TABLE, and return the value (if any)
     associated with it.  If KEY is not found, return DFLT (or `#f' if
     no DFLT argument is supplied).  Uses `equal?' for equality testing.

hash-set!

- Scheme Procedure: hash-set! table key val
     Find the entry in TABLE associated with KEY, and store VAL there.
     Uses `equal?' for equality testing.

hash-remove!

- Scheme Procedure: hash-remove! table key
     Remove KEY (and any value associated with it) from TABLE.  Uses
     `equal?' for equality tests.

hashx-get-handle

- Scheme Procedure: hashx-get-handle hash assoc table key
     This behaves the same way as the corresponding `-get-handle'
     function, but uses HASH as a hash function and ASSOC to compare
     keys.  `hash' must be a function that takes two arguments, a key to
     be hashed and a table size.  `assoc' must be an associator
     function, like `assoc', `assq' or `assv'.

hashx-create-handle!

- Scheme Procedure: hashx-create-handle! hash assoc table key init
     This behaves the same way as the corresponding `-create-handle'
     function, but uses HASH as a hash function and ASSOC to compare
     keys.  `hash' must be a function that takes two arguments, a key to
     be hashed and a table size.  `assoc' must be an associator
     function, like `assoc', `assq' or `assv'.

hashx-ref

- Scheme Procedure: hashx-ref hash assoc table key [dflt]
     This behaves the same way as the corresponding `ref' function, but
     uses HASH as a hash function and ASSOC to compare keys.  `hash'
     must be a function that takes two arguments, a key to be hashed and
     a table size.  `assoc' must be an associator function, like
     `assoc', `assq' or `assv'.

     By way of illustration, `hashq-ref table key' is equivalent to
     `hashx-ref hashq assq table key'.

hashx-set!

- Scheme Procedure: hashx-set! hash assoc table key val
     This behaves the same way as the corresponding `set!' function, but
     uses HASH as a hash function and ASSOC to compare keys.  `hash'
     must be a function that takes two arguments, a key to be hashed and
     a table size.  `assoc' must be an associator function, like
     `assoc', `assq' or `assv'.

     By way of illustration, `hashq-set! table key' is equivalent to
     `hashx-set! hashq assq table key'.

hashx-remove!

- Scheme Procedure: hashx-remove! hash assoc table obj
     This behaves the same way as the corresponding `remove!' function,
     but uses HASH as a hash function and ASSOC to compare keys.  `hash'
     must be a function that takes two arguments, a key to be hashed and
     a table size.  `assoc' must be an associator function, like
     `assoc', `assq' or `assv'.

     By way of illustration, `hashq-remove! table key' is equivalent to
     `hashx-remove! hashq assq #f table key'.

hash-fold

- Scheme Procedure: hash-fold proc init table
     An iterator over hash-table elements.  Accumulates and returns a
     result by applying PROC successively.  The arguments to PROC are
     "(key value prior-result)" where key and value are successive pairs
     from the hash table TABLE, and prior-result is either INIT (for the
     first application of PROC) or the return value of the previous
     application of PROC.  For example, `(hash-fold acons '() tab)' will
     convert a hash table into an a-list of key-value pairs.

hash-for-each

- Scheme Procedure: hash-for-each proc table
     An iterator over hash-table elements.  Applies PROC successively on
     all hash table items.  The arguments to PROC are "(key value)"
     where key and value are successive pairs from the hash table TABLE.

hash-for-each-handle

- Scheme Procedure: hash-for-each-handle proc table
     An iterator over hash-table elements.  Applies PROC successively on
     all hash table handles.

hash-map->list

- Scheme Procedure: hash-map->list proc table
     An iterator over hash-table elements.  Accumulates and returns as a
     list the results of applying PROC successively.  The arguments to
     PROC are "(key value)" where key and value are successive pairs
     from the hash table TABLE.

hash-count

- Scheme Procedure: hash-count pred table
     Return the number of elements in the given hash TABLE that cause
     `(PRED KEY VALUE)' to return true.  To quickly determine the total
     number of elements, use `(const #t)' for PRED.

make-hook

- Scheme Procedure: make-hook [n_args]
     Create a hook for storing procedure of arity N_ARGS.  N_ARGS
     defaults to zero.  The returned value is a hook object to be used
     with the other hook procedures.

hook?

- Scheme Procedure: hook? x
     Return `#t' if X is a hook, `#f' otherwise.

hook-empty?

- Scheme Procedure: hook-empty? hook
     Return `#t' if HOOK is an empty hook, `#f' otherwise.

add-hook!

- Scheme Procedure: add-hook! hook proc [append_p]
     Add the procedure PROC to the hook HOOK.  The procedure is added to
     the end if APPEND_P is true, otherwise it is added to the front.
     The return value of this procedure is not specified.

remove-hook!

- Scheme Procedure: remove-hook! hook proc
     Remove the procedure PROC from the hook HOOK.  The return value of
     this procedure is not specified.

reset-hook!

- Scheme Procedure: reset-hook! hook
     Remove all procedures from the hook HOOK.  The return value of this
     procedure is not specified.

run-hook

- Scheme Procedure: run-hook hook .  args
     Apply all procedures from the hook HOOK to the arguments ARGS.  The
     order of the procedure application is first to last.  The return
     value of this procedure is not specified.

hook->list

- Scheme Procedure: hook->list hook
     Convert the procedure list of HOOK to a list.

make-locale

- Scheme Procedure: make-locale category_list locale_name [base_locale]
     Return a reference to a data structure representing a set of locale
     datasets.  CATEGORY_LIST should be either a list of locale
     categories or a single category as used with `setlocale' (see
     `setlocale') and LOCALE_NAME should be the name of the locale
     considered (e.g., `"sl_SI"').  Optionally, if `base_locale' is
     passed, it should be a locale object denoting settings for
     categories not listed in CATEGORY_LIST.

locale?

- Scheme Procedure: locale? obj
     Return true if OBJ is a locale object.

string-locale<?

- Scheme Procedure: string-locale<? s1 s2 [locale]
     Compare strings S1 and S2 in a locale-dependent way.If LOCALE is
     provided, it should be locale object (as returned by `make-locale')
     and will be used to perform the comparison; otherwise, the current
     system locale is used.

string-locale>?

- Scheme Procedure: string-locale>? s1 s2 [locale]
     Compare strings S1 and S2 in a locale-dependent way.If LOCALE is
     provided, it should be locale object (as returned by `make-locale')
     and will be used to perform the comparison; otherwise, the current
     system locale is used.

string-locale-ci<?

- Scheme Procedure: string-locale-ci<? s1 s2 [locale]
     Compare strings S1 and S2 in a case-insensitive, and
     locale-dependent way.  If LOCALE is provided, it should be locale
     object (as returned by `make-locale') and will be used to perform
     the comparison; otherwise, the current system locale is used.

string-locale-ci>?

- Scheme Procedure: string-locale-ci>? s1 s2 [locale]
     Compare strings S1 and S2 in a case-insensitive, and
     locale-dependent way.  If LOCALE is provided, it should be locale
     object (as returned by `make-locale') and will be used to perform
     the comparison; otherwise, the current system locale is used.

string-locale-ci=?

- Scheme Procedure: string-locale-ci=? s1 s2 [locale]
     Compare strings S1 and S2 in a case-insensitive, and
     locale-dependent way.  If LOCALE is provided, it should be locale
     object (as returned by `make-locale') and will be used to perform
     the comparison; otherwise, the current system locale is used.

char-locale<?

- Scheme Procedure: char-locale<? c1 c2 [locale]
     Return true if character C1 is lower than C2 according to LOCALE or
     to the current locale.

char-locale>?

- Scheme Procedure: char-locale>? c1 c2 [locale]
     Return true if character C1 is greater than C2 according to LOCALE
     or to the current locale.

char-locale-ci<?

- Scheme Procedure: char-locale-ci<? c1 c2 [locale]
     Return true if character C1 is lower than C2, in a case insensitive
     way according to LOCALE or to the current locale.

char-locale-ci>?

- Scheme Procedure: char-locale-ci>? c1 c2 [locale]
     Return true if character C1 is greater than C2, in a case
     insensitive way according to LOCALE or to the current locale.

char-locale-ci=?

- Scheme Procedure: char-locale-ci=? c1 c2 [locale]
     Return true if character C1 is equal to C2, in a case insensitive
     way according to LOCALE or to the current locale.

char-locale-downcase

- Scheme Procedure: char-locale-downcase chr [locale]
     Return the lowercase character that corresponds to CHR according to
     either LOCALE or the current locale.

char-locale-upcase

- Scheme Procedure: char-locale-upcase chr [locale]
     Return the uppercase character that corresponds to CHR according to
     either LOCALE or the current locale.

char-locale-titlecase

- Scheme Procedure: char-locale-titlecase chr [locale]
     Return the titlecase character that corresponds to CHR according to
     either LOCALE or the current locale.

string-locale-upcase

- Scheme Procedure: string-locale-upcase str [locale]
     Return a new string that is the uppercase version of STR according
     to either LOCALE or the current locale.

string-locale-downcase

- Scheme Procedure: string-locale-downcase str [locale]
     Return a new string that is the down-case version of STR according
     to either LOCALE or the current locale.

string-locale-titlecase

- Scheme Procedure: string-locale-titlecase str [locale]
     Return a new string that is the title-case version of STR according
     to either LOCALE or the current locale.

locale-string->integer

- Scheme Procedure: locale-string->integer str [base [locale]]
     Convert string STR into an integer according to either LOCALE (a
     locale object as returned by `make-locale') or the current process
     locale.  Return two values: an integer (on success) or `#f', and
     the number of characters read from STR (`0' on failure).

locale-string->inexact

- Scheme Procedure: locale-string->inexact str [locale]
     Convert string STR into an inexact number according to either
     LOCALE (a locale object as returned by `make-locale') or the
     current process locale.  Return two values: an inexact number (on
     success) or `#f', and the number of characters read from STR (`0'
     on failure).

nl-langinfo

- Scheme Procedure: nl-langinfo item [locale]
     Return a string denoting locale information for ITEM in the current
     locale or that specified by LOCALE.  The semantics and arguments
     are the same as those of the X/Open `nl_langinfo' function (see
     `nl_langinfo' in manual `nl_langinfo'The GNU C Library Reference
     Manual).

ftell

- Scheme Procedure: ftell fd_port
     Return an integer representing the current position of FD_PORT,
     measured from the beginning.  Equivalent to:

          (seek port 0 SEEK_CUR)

redirect-port

- Scheme Procedure: redirect-port old new
     This procedure takes two ports and duplicates the underlying file
     descriptor from OLD into NEW.  The current file descriptor in NEW
     will be closed.  After the redirection the two ports will share a
     file position and file status flags.

     The return value is unspecified.

     Unexpected behavior can result if both ports are subsequently used
     and the original and/or duplicate ports are buffered.

     This procedure does not have any side effects on other ports or
     revealed counts.

dup->fdes

- Scheme Procedure: dup->fdes fd_or_port [fd]
     Return a new integer file descriptor referring to the open file
     designated by FD_OR_PORT, which must be either an open file port or
     a file descriptor.

dup2

- Scheme Procedure: dup2 oldfd newfd
     A simple wrapper for the `dup2' system call.  Copies the file
     descriptor OLDFD to descriptor number NEWFD, replacing the previous
     meaning of NEWFD.  Both OLDFD and NEWFD must be integers.  Unlike
     for dup->fdes or primitive-move->fdes, no attempt is made to move
     away ports which are using NEWFD.  The return value is unspecified.

fileno

- Scheme Procedure: fileno port
     Return the integer file descriptor underlying PORT.  Does not
     change its revealed count.

isatty?

- Scheme Procedure: isatty? port
     Return `#t' if PORT is using a serial non--file device, otherwise
     `#f'.

fdopen

- Scheme Procedure: fdopen fdes modes
     Return a new port based on the file descriptor FDES.  Modes are
     given by the string MODES.  The revealed count of the port is
     initialized to zero.  The modes string is the same as that accepted
     by open-file.

primitive-move->fdes

- Scheme Procedure: primitive-move->fdes port fd
     Moves the underlying file descriptor for PORT to the integer value
     FD without changing the revealed count of PORT.  Any other ports
     already using this descriptor will be automatically shifted to new
     descriptors and their revealed counts reset to zero.  The return
     value is `#f' if the file descriptor already had the required value
     or `#t' if it was moved.

fdes->ports

- Scheme Procedure: fdes->ports fd
     Return a list of existing ports which have FD as an underlying file
     descriptor, without changing their revealed counts.

keyword?

- Scheme Procedure: keyword? obj
     Return `#t' if the argument OBJ is a keyword, else `#f'.

symbol->keyword

- Scheme Procedure: symbol->keyword symbol
     Return the keyword with the same name as SYMBOL.

keyword->symbol

- Scheme Procedure: keyword->symbol keyword
     Return the symbol with the same name as KEYWORD.

make-list

- Scheme Procedure: make-list n [init]
     Create a list containing of N elements, where each element is
     initialized to INIT.  INIT defaults to the empty list `()' if not
     given.

cons*

- Scheme Procedure: cons* arg .  rest
     Like `list', but the last arg provides the tail of the constructed
     list, returning `(cons ARG1 (cons ARG2 (cons ... ARGN)))'.  Requires
     at least one argument.  If given one argument, that argument is
     returned as result.  This function is called `list*' in some other
     Schemes and in Common LISP.

null?

- Scheme Procedure: null? x
     Return `#t' iff X is the empty list, else `#f'.

list?

- Scheme Procedure: list? x
     Return `#t' iff X is a proper list, else `#f'.

length

- Scheme Procedure: length lst
     Return the number of elements in list LST.

append

- Scheme Procedure: append .  args
     Return a list consisting of the elements of the lists passed as
     arguments.

          (append '(x) '(y))          ==>  (x y)
          (append '(a) '(b c d))      ==>  (a b c d)
          (append '(a (b)) '((c)))    ==>  (a (b) (c))

     The resulting list is always newly allocated, except that it shares
     structure with the last list argument.  The last argument may
     actually be any object; an improper list results if the last
     argument is not a proper list.

          (append '(a b) '(c . d))    ==>  (a b c . d)
          (append '() 'a)             ==>  a

append!

- Scheme Procedure: append! .  args
     A destructive version of `append' (see in manual The Revised^5
     Report on Scheme).  The cdr field of each list's final pair is
     changed to point to the head of the next list, so no consing is
     performed.  Return the mutated list.

last-pair

- Scheme Procedure: last-pair lst
     Return the last pair in LST, signaling an error if LST is circular.

reverse

- Scheme Procedure: reverse lst
     Return a new list that contains the elements of LST but in reverse
     order.

reverse!

- Scheme Procedure: reverse! lst [new_tail]
     A destructive version of `reverse' (see in manual The Revised^5
     Report on Scheme).  The cdr of each cell in LST is modified to
     point to the previous list element.  Return the reversed list.

     Caveat: because the list is modified in place, the tail of the
     original list now becomes its head, and the head of the original
     list now becomes the tail.  Therefore, the LST symbol to which the
     head of the original list was bound now points to the tail.  To
     ensure that the head of the modified list is not lost, it is wise
     to save the return value of `reverse!'

list-ref

- Scheme Procedure: list-ref list k
     Return the Kth element from LIST.

list-set!

- Scheme Procedure: list-set! list k val
     Set the Kth element of LIST to VAL.

list-cdr-ref

- Scheme Procedure: list-cdr-ref
     implemented by the C function "scm_list_tail"

list-tail

- Scheme Procedure: list-tail lst k


     Return the "tail" of LST beginning with its Kth element.  The first
     element of the list is considered to be element 0.

     `list-tail' and `list-cdr-ref' are identical.  It may help to think
     of `list-cdr-ref' as accessing the Kth cdr of the list, or
     returning the results of cdring K times down LST.

list-cdr-set!

- Scheme Procedure: list-cdr-set! list k val
     Set the Kth cdr of LIST to VAL.

list-head

- Scheme Procedure: list-head lst k
     Copy the first K elements from LST into a new list, and return it.

list-copy

- Scheme Procedure: list-copy lst
     Return a (newly-created) copy of LST.

list

- Scheme Procedure: list .  objs
     Return a list containing OBJS, the arguments to `list'.

memq

- Scheme Procedure: memq x lst
     Return the first sublist of LST whose car is `eq?' to X where the
     sublists of LST are the non-empty lists returned by `(list-tail LST
     K)' for K less than the length of LST.  If X does not occur in LST,
     then `#f' (not the empty list) is returned.

memv

- Scheme Procedure: memv x lst
     Return the first sublist of LST whose car is `eqv?' to X where the
     sublists of LST are the non-empty lists returned by `(list-tail LST
     K)' for K less than the length of LST.  If X does not occur in LST,
     then `#f' (not the empty list) is returned.

member

- Scheme Procedure: member x lst
     Return the first sublist of LST whose car is `equal?' to X where
     the sublists of LST are the non-empty lists returned by `(list-tail
     LST K)' for K less than the length of LST.  If X does not occur in
     LST, then `#f' (not the empty list) is returned.

delq!

- Scheme Procedure: delq! item lst




     These procedures are destructive versions of `delq', `delv' and
     `delete': they modify the existing LST rather than creating a new
     list.  Caveat evaluator: Like other destructive list functions,
     these functions cannot modify the binding of LST, and so cannot be
     used to delete the first element of LST destructively.

delv!

- Scheme Procedure: delv! item lst
     Destructively remove all elements from LST that are `eqv?' to ITEM.

delete!

- Scheme Procedure: delete! item lst
     Destructively remove all elements from LST that are `equal?' to
     ITEM.

delq

- Scheme Procedure: delq item lst
     Return a newly-created copy of LST with elements `eq?' to ITEM
     removed.  This procedure mirrors `memq': `delq' compares elements
     of LST against ITEM with `eq?'.

delv

- Scheme Procedure: delv item lst
     Return a newly-created copy of LST with elements `eqv?' to ITEM
     removed.  This procedure mirrors `memv': `delv' compares elements
     of LST against ITEM with `eqv?'.

delete

- Scheme Procedure: delete item lst
     Return a newly-created copy of LST with elements `equal?' to ITEM
     removed.  This procedure mirrors `member': `delete' compares
     elements of LST against ITEM with `equal?'.

delq1!

- Scheme Procedure: delq1! item lst
     Like `delq!', but only deletes the first occurrence of ITEM from
     LST.  Tests for equality using `eq?'.  See also `delv1!' and
     `delete1!'.

delv1!

- Scheme Procedure: delv1! item lst
     Like `delv!', but only deletes the first occurrence of ITEM from
     LST.  Tests for equality using `eqv?'.  See also `delq1!' and
     `delete1!'.

delete1!

- Scheme Procedure: delete1! item lst
     Like `delete!', but only deletes the first occurrence of ITEM from
     LST.  Tests for equality using `equal?'.  See also `delq1!' and
     `delv1!'.

filter

- Scheme Procedure: filter pred list
     Return all the elements of 2nd arg LIST that satisfy predicate
     PRED.  The list is not disordered -- elements that appear in the
     result list occur in the same order as they occur in the argument
     list.  The returned list may share a common tail with the argument
     list.  The dynamic order in which the various applications of pred
     are made is not specified.

          (filter even? '(0 7 8 8 43 -4)) => (0 8 8 -4)

filter!

- Scheme Procedure: filter! pred list
     Linear-update variant of `filter'.

primitive-load

- Scheme Procedure: primitive-load filename
     Load the file named FILENAME and evaluate its contents in the
     top-level environment.  The load paths are not searched; FILENAME
     must either be a full pathname or be a pathname relative to the
     current directory.  If the variable `%load-hook' is defined, it
     should be bound to a procedure that will be called before any code
     is loaded.  See the documentation for `%load-hook' later in this
     section.

%package-data-dir

- Scheme Procedure: %package-data-dir
     Return the name of the directory where Scheme packages, modules and
     libraries are kept.  On most Unix systems, this will be
     `/usr/local/share/guile'.

%library-dir

- Scheme Procedure: %library-dir
     Return the directory where the Guile Scheme library files are
     installed.  E.g., may return "/usr/share/guile/1.3.5".

%site-dir

- Scheme Procedure: %site-dir
     Return the directory where users should install Scheme code for use
     with this version of Guile.

     E.g., may return "/usr/share/guile/site/3.0".

%global-site-dir

- Scheme Procedure: %global-site-dir
     Return the directory where users should install Scheme code for use
     with all versions of Guile.

     E.g., may return "/usr/share/guile/site".

%site-ccache-dir

- Scheme Procedure: %site-ccache-dir
     Return the directory where users should install compiled `.go'
     files for use with this version of Guile.

     E.g., may return "/usr/lib/guile/3.0/site-ccache".

parse-path

- Scheme Procedure: parse-path path [tail]
     Parse PATH, which is expected to be a colon-separated string, into
     a list and return the resulting list with TAIL appended.  If PATH
     is `#f', TAIL is returned.

parse-path-with-ellipsis

- Scheme Procedure: parse-path-with-ellipsis path base
     Parse PATH, which is expected to be a colon-separated string, into
     a list and return the resulting list with BASE (a list) spliced in
     place of the `...' path component, if present, or else BASE is
     added to the end.  If PATH is `#f', BASE is returned.

search-path

- Scheme Procedure: search-path path filename .  rest
     Search PATH for a directory containing a file named FILENAME.  The
     file must be readable, and not a directory.  If we find one, return
     its full filename; otherwise, return `#f'.  If FILENAME is
     absolute, return it unchanged.  If given, REST is a list of
     extension strings; for each directory in PATH, we search for
     FILENAME concatenated with each extension.

%search-load-path

- Scheme Procedure: %search-load-path filename
     Search %LOAD-PATH for the file named FILENAME, which must be
     readable by the current user.  If FILENAME is found in the list of
     paths to search or is an absolute pathname, return its full
     pathname.  Otherwise, return `#f'.  Filenames may have any of the
     optional extensions in the `%load-extensions' list;
     `%search-load-path' will try each extension automatically.

%warn-auto-compilation-enabled

- Scheme Procedure: %warn-auto-compilation-enabled
primitive-load-path

- Scheme Procedure: primitive-load-path .  args
     Search %LOAD-PATH for the file named FILENAME and load it into the
     top-level environment.

     If FILENAME is a relative pathname and is not found in the list of
     search paths, one of three things may happen, depending on the
     optional second argument, EXCEPTION_ON_NOT_FOUND.  If it is `#f',
     `#f' will be returned.  If it is a procedure, it will be called
     with no arguments.  Otherwise an error is signaled.

make-syntax-transformer

- Scheme Procedure: make-syntax-transformer name type binding
     Construct a "syntax transformer".

     This function is part of Guile's low-level support for the psyntax
     syntax expander.  Users should not call this function.

macro?

- Scheme Procedure: macro? obj
     Return `#t' if OBJ is a syntax transformer (an object that
     transforms Scheme expressions at expansion-time).

     Macros are actually just one kind of syntax transformer; this
     procedure has its name due to historical reasons.

macro-type

- Scheme Procedure: macro-type m
     Return the type of the syntax transformer M, as passed to
     `make-syntax-transformer'.  If M is a primitive syntax transformer,
     `#f' will be returned.

macro-name

- Scheme Procedure: macro-name m
     Return the name of the syntax transformer M.

macro-transformer

- Scheme Procedure: macro-transformer m
     Return the transformer procedure of the macro M.

     If M is a syntax transformer but not a macro, `#f' will be
     returned.  (This can happen, for example, with primitive syntax
     transformers).

macro-binding

- Scheme Procedure: macro-binding m
     Return the binding of the syntax transformer M, as passed to
     `make-syntax-transformer'.  If M is a primitive syntax transformer,
     `#f' will be returned.

memoize-expression

- Scheme Procedure: memoize-expression exp
     Memoize the expression EXP.

unmemoize-expression

- Scheme Procedure: unmemoize-expression m
     Unmemoize the memoized expression M.

memoized-typecode

- Scheme Procedure: memoized-typecode sym
     Return the memoized typecode corresponding to the symbol SYM.

%resolve-variable

- Scheme Procedure: %resolve-variable loc mod
     Look up and return the variable for LOC.

current-module

- Scheme Procedure: current-module
     Return the current module.

set-current-module

- Scheme Procedure: set-current-module module
     Set the current module to MODULE and return the previous current
     module.

interaction-environment

- Scheme Procedure: interaction-environment
     Return a specifier for the environment that contains
     implementation--defined bindings, typically a superset of those
     listed in the report.  The intent is that this procedure will
     return the environment in which the implementation would evaluate
     expressions dynamically typed by the user.

module-local-variable

- Scheme Procedure: module-local-variable module sym
     Return the variable bound to SYM in MODULE.  Return `#f' is SYM is
     not bound locally in MODULE.

module-variable

- Scheme Procedure: module-variable module sym
     Return the variable bound to SYM in MODULE.  This may be both a
     local variable or an imported variable.  Return `#f' is SYM is not
     bound in MODULE.

module-transformer

- Scheme Procedure: module-transformer module
     Returns the syntax expander for the given module.

module-import-interface

- Scheme Procedure: module-import-interface module sym
     Return the module or interface from which SYM is imported in
     MODULE.  If SYM is not imported (i.e., it is not defined in MODULE
     or it is a module-local binding instead of an imported one), then
     `#f' is returned.

define!

- Scheme Procedure: define! sym value
     Define SYM to be VALUE in the current module.Returns the variable
     itself.  Note that this is a procedure, not a macro.

module-reverse-lookup

- Scheme Procedure: module-reverse-lookup module variable
     Return the symbol under which VARIABLE is bound in MODULE or #F if
     VARIABLE is not visible from MODULE.  If MODULE is `#f', then the
     pre-module obarray is used.

%get-pre-modules-obarray

- Scheme Procedure: %get-pre-modules-obarray
     Return the obarray that is used for all new bindings before the
     module system is booted.  The first call to `set-current-module'
     will boot the module system.

exact?

- Scheme Procedure: exact? x
     Return `#t' if X is an exact number, `#f' otherwise.

inexact?

- Scheme Procedure: inexact? x
     Return `#t' if X is an inexact number, `#f' else.

odd?

- Scheme Procedure: odd? n
     Return `#t' if N is an odd number, `#f' otherwise.

even?

- Scheme Procedure: even? n
     Return `#t' if N is an even number, `#f' otherwise.

finite?

- Scheme Procedure: finite? x
     Return `#t' if the real number X is neither infinite nor a NaN,
     `#f' otherwise.

inf?

- Scheme Procedure: inf? x
     Return `#t' if the real number X is `+inf.0' or `-inf.0'.  Otherwise
     return `#f'.

nan?

- Scheme Procedure: nan? x
     Return `#t' if the real number X is a NaN, or `#f' otherwise.

inf

- Scheme Procedure: inf
     Return Inf.

nan

- Scheme Procedure: nan
     Return NaN.

abs

- Scheme Procedure: abs x
     Return the absolute value of X.

quotient

- Scheme Procedure: quotient x y
     Return the quotient of the numbers X and Y.

remainder

- Scheme Procedure: remainder x y
     Return the remainder of the numbers X and Y.

          (remainder 13 4) ==> 1
          (remainder -13 4) ==> -1

modulo

- Scheme Procedure: modulo x y
     Return the modulo of the numbers X and Y.

          (modulo 13 4) ==> 1
          (modulo -13 4) ==> 3

euclidean-quotient

- Scheme Procedure: euclidean-quotient x y
     Return the integer Q such that X = Q*Y + R where 0 <= R < abs(Y).

          (euclidean-quotient 123 10) ==> 12
          (euclidean-quotient 123 -10) ==> -12
          (euclidean-quotient -123 10) ==> -13
          (euclidean-quotient -123 -10) ==> 13
          (euclidean-quotient -123.2 -63.5) ==> 2.0
          (euclidean-quotient 16/3 -10/7) ==> -3

euclidean-remainder

- Scheme Procedure: euclidean-remainder x y
     Return the real number R such that 0 <= R < abs(Y) and X = Q*Y + R
     for some integer Q.

          (euclidean-remainder 123 10) ==> 3
          (euclidean-remainder 123 -10) ==> 3
          (euclidean-remainder -123 10) ==> 7
          (euclidean-remainder -123 -10) ==> 7
          (euclidean-remainder -123.2 -63.5) ==> 3.8
          (euclidean-remainder 16/3 -10/7) ==> 22/21

euclidean/

- Scheme Procedure: euclidean/ x y
     Return the integer Q and the real number R such that X = Q*Y + R
     and 0 <= R < abs(Y).

          (euclidean/ 123 10) ==> 12 and 3
          (euclidean/ 123 -10) ==> -12 and 3
          (euclidean/ -123 10) ==> -13 and 7
          (euclidean/ -123 -10) ==> 13 and 7
          (euclidean/ -123.2 -63.5) ==> 2.0 and 3.8
          (euclidean/ 16/3 -10/7) ==> -3 and 22/21

floor-quotient

- Scheme Procedure: floor-quotient x y
     Return the floor of X / Y.

          (floor-quotient 123 10) ==> 12
          (floor-quotient 123 -10) ==> -13
          (floor-quotient -123 10) ==> -13
          (floor-quotient -123 -10) ==> 12
          (floor-quotient -123.2 -63.5) ==> 1.0
          (floor-quotient 16/3 -10/7) ==> -4

floor-remainder

- Scheme Procedure: floor-remainder x y
     Return the real number R such that X = Q*Y + R where Q = floor(X /
     Y).

          (floor-remainder 123 10) ==> 3
          (floor-remainder 123 -10) ==> -7
          (floor-remainder -123 10) ==> 7
          (floor-remainder -123 -10) ==> -3
          (floor-remainder -123.2 -63.5) ==> -59.7
          (floor-remainder 16/3 -10/7) ==> -8/21

floor/

- Scheme Procedure: floor/ x y
     Return the integer Q and the real number R such that X = Q*Y + R
     and Q = floor(X / Y).

          (floor/ 123 10) ==> 12 and 3
          (floor/ 123 -10) ==> -13 and -7
          (floor/ -123 10) ==> -13 and 7
          (floor/ -123 -10) ==> 12 and -3
          (floor/ -123.2 -63.5) ==> 1.0 and -59.7
          (floor/ 16/3 -10/7) ==> -4 and -8/21

ceiling-quotient

- Scheme Procedure: ceiling-quotient x y
     Return the ceiling of X / Y.

          (ceiling-quotient 123 10) ==> 13
          (ceiling-quotient 123 -10) ==> -12
          (ceiling-quotient -123 10) ==> -12
          (ceiling-quotient -123 -10) ==> 13
          (ceiling-quotient -123.2 -63.5) ==> 2.0
          (ceiling-quotient 16/3 -10/7) ==> -3

ceiling-remainder

- Scheme Procedure: ceiling-remainder x y
     Return the real number R such that X = Q*Y + R where Q = ceiling(X
     / Y).

          (ceiling-remainder 123 10) ==> -7
          (ceiling-remainder 123 -10) ==> 3
          (ceiling-remainder -123 10) ==> -3
          (ceiling-remainder -123 -10) ==> 7
          (ceiling-remainder -123.2 -63.5) ==> 3.8
          (ceiling-remainder 16/3 -10/7) ==> 22/21

ceiling/

- Scheme Procedure: ceiling/ x y
     Return the integer Q and the real number R such that X = Q*Y + R
     and Q = ceiling(X / Y).

          (ceiling/ 123 10) ==> 13 and -7
          (ceiling/ 123 -10) ==> -12 and 3
          (ceiling/ -123 10) ==> -12 and -3
          (ceiling/ -123 -10) ==> 13 and 7
          (ceiling/ -123.2 -63.5) ==> 2.0 and 3.8
          (ceiling/ 16/3 -10/7) ==> -3 and 22/21

truncate-quotient

- Scheme Procedure: truncate-quotient x y
     Return X / Y rounded toward zero.

          (truncate-quotient 123 10) ==> 12
          (truncate-quotient 123 -10) ==> -12
          (truncate-quotient -123 10) ==> -12
          (truncate-quotient -123 -10) ==> 12
          (truncate-quotient -123.2 -63.5) ==> 1.0
          (truncate-quotient 16/3 -10/7) ==> -3

truncate-remainder

- Scheme Procedure: truncate-remainder x y
     Return the real number R such that X = Q*Y + R where Q = truncate(X
     / Y).

          (truncate-remainder 123 10) ==> 3
          (truncate-remainder 123 -10) ==> 3
          (truncate-remainder -123 10) ==> -3
          (truncate-remainder -123 -10) ==> -3
          (truncate-remainder -123.2 -63.5) ==> -59.7
          (truncate-remainder 16/3 -10/7) ==> 22/21

truncate/

- Scheme Procedure: truncate/ x y
     Return the integer Q and the real number R such that X = Q*Y + R
     and Q = truncate(X / Y).

          (truncate/ 123 10) ==> 12 and 3
          (truncate/ 123 -10) ==> -12 and 3
          (truncate/ -123 10) ==> -12 and -3
          (truncate/ -123 -10) ==> 12 and -3
          (truncate/ -123.2 -63.5) ==> 1.0 and -59.7
          (truncate/ 16/3 -10/7) ==> -3 and 22/21

centered-quotient

- Scheme Procedure: centered-quotient x y
     Return the integer Q such that X = Q*Y + R where -abs(Y/2) <= R <
     abs(Y/2).

          (centered-quotient 123 10) ==> 12
          (centered-quotient 123 -10) ==> -12
          (centered-quotient -123 10) ==> -12
          (centered-quotient -123 -10) ==> 12
          (centered-quotient -123.2 -63.5) ==> 2.0
          (centered-quotient 16/3 -10/7) ==> -4

centered-remainder

- Scheme Procedure: centered-remainder x y
     Return the real number R such that -abs(Y/2) <= R < abs(Y/2) and X
     = Q*Y + R for some integer Q.

          (centered-remainder 123 10) ==> 3
          (centered-remainder 123 -10) ==> 3
          (centered-remainder -123 10) ==> -3
          (centered-remainder -123 -10) ==> -3
          (centered-remainder -123.2 -63.5) ==> 3.8
          (centered-remainder 16/3 -10/7) ==> -8/21

centered/

- Scheme Procedure: centered/ x y
     Return the integer Q and the real number R such that X = Q*Y + R
     and -abs(Y/2) <= R < abs(Y/2).

          (centered/ 123 10) ==> 12 and 3
          (centered/ 123 -10) ==> -12 and 3
          (centered/ -123 10) ==> -12 and -3
          (centered/ -123 -10) ==> 12 and -3
          (centered/ -123.2 -63.5) ==> 2.0 and 3.8
          (centered/ 16/3 -10/7) ==> -4 and -8/21

round-quotient

- Scheme Procedure: round-quotient x y
     Return X / Y to the nearest integer, with ties going to the nearest
     even integer.

          (round-quotient 123 10) ==> 12
          (round-quotient 123 -10) ==> -12
          (round-quotient -123 10) ==> -12
          (round-quotient -123 -10) ==> 12
          (round-quotient 125 10) ==> 12
          (round-quotient 127 10) ==> 13
          (round-quotient 135 10) ==> 14
          (round-quotient -123.2 -63.5) ==> 2.0
          (round-quotient 16/3 -10/7) ==> -4

round-remainder

- Scheme Procedure: round-remainder x y
     Return the real number R such that X = Q*Y + R, where Q is X / Y
     rounded to the nearest integer, with ties going to the nearest even
     integer.

          (round-remainder 123 10) ==> 3
          (round-remainder 123 -10) ==> 3
          (round-remainder -123 10) ==> -3
          (round-remainder -123 -10) ==> -3
          (round-remainder 125 10) ==> 5
          (round-remainder 127 10) ==> -3
          (round-remainder 135 10) ==> -5
          (round-remainder -123.2 -63.5) ==> 3.8
          (round-remainder 16/3 -10/7) ==> -8/21

round/

- Scheme Procedure: round/ x y
     Return the integer Q and the real number R such that X = Q*Y + R
     and Q is X / Y rounded to the nearest integer, with ties going to
     the nearest even integer.

          (round/ 123 10) ==> 12 and 3
          (round/ 123 -10) ==> -12 and 3
          (round/ -123 10) ==> -12 and -3
          (round/ -123 -10) ==> 12 and -3
          (round/ 125 10) ==> 12 and 5
          (round/ 127 10) ==> 13 and -3
          (round/ 135 10) ==> 14 and -5
          (round/ -123.2 -63.5) ==> 2.0 and 3.8
          (round/ 16/3 -10/7) ==> -4 and -8/21

gcd

- Scheme Procedure: gcd [x [y .  rest]]
     Return the greatest common divisor of all parameter values.  If
     called without arguments, 0 is returned.

lcm

- Scheme Procedure: lcm [x [y .  rest]]
     Return the least common multiple of the arguments.  If called
     without arguments, 1 is returned.

logand

- Scheme Procedure: logand [x [y .  rest]]
     Return the bitwise AND of the integer arguments.

          (logand) ==> -1
          (logand 7) ==> 7
          (logand #b111 #b011 #b001) ==> 1

logior

- Scheme Procedure: logior [x [y .  rest]]
     Return the bitwise OR of the integer arguments.

          (logior) ==> 0
          (logior 7) ==> 7
          (logior #b000 #b001 #b011) ==> 3

logxor

- Scheme Procedure: logxor [x [y .  rest]]
     Return the bitwise XOR of the integer arguments.  A bit is set in
     the result if it is set in an odd number of arguments.

          (logxor) ==> 0
          (logxor 7) ==> 7
          (logxor #b000 #b001 #b011) ==> 2
          (logxor #b000 #b001 #b011 #b011) ==> 1

logtest

- Scheme Procedure: logtest j k
     Test whether J and K have any 1 bits in common.  This is equivalent
     to `(not (zero? (logand j k)))', but without actually calculating
     the `logand', just testing for non-zero.

          (logtest #b0100 #b1011) ==> #f
          (logtest #b0100 #b0111) ==> #t

logbit?

- Scheme Procedure: logbit? index j
     Test whether bit number INDEX in J is set.  INDEX starts from 0 for
     the least significant bit.

          (logbit? 0 #b1101) ==> #t
          (logbit? 1 #b1101) ==> #f
          (logbit? 2 #b1101) ==> #t
          (logbit? 3 #b1101) ==> #t
          (logbit? 4 #b1101) ==> #f

lognot

- Scheme Procedure: lognot n
     Return the integer which is the ones-complement of the integer
     argument.

          (number->string (lognot #b10000000) 2)
             ==> "-10000001"
          (number->string (lognot #b0) 2)
             ==> "-1"

modulo-expt

- Scheme Procedure: modulo-expt n k m
     Return N raised to the integer exponent K, modulo M.

          (modulo-expt 2 3 5)
             ==> 3

integer-expt

- Scheme Procedure: integer-expt n k
     Return N raised to the power K.  K must be an exact integer, N can
     be any number.

     Negative K is supported, and results in 1/N^abs(K) in the usual
     way.  N^0 is 1, as usual, and that includes 0^0 is 1.

          (integer-expt 2 5)   ==> 32
          (integer-expt -3 3)  ==> -27
          (integer-expt 5 -3)  ==> 1/125
          (integer-expt 0 0)   ==> 1

ash

- Scheme Procedure: ash n count
     Return floor(N * 2^COUNT).  N and COUNT must be exact integers.

     With N viewed as an infinite-precision twos-complement integer,
     `ash' means a left shift introducing zero bits when COUNT is
     positive, or a right shift dropping bits when COUNT is negative.
     This is an ``arithmetic'' shift.

          (number->string (ash #b1 3) 2)     ==> "1000"
          (number->string (ash #b1010 -1) 2) ==> "101"
          
          ;; -23 is bits ...11101001, -6 is bits ...111010
          (ash -23 -2) ==> -6

round-ash

- Scheme Procedure: round-ash n count
     Return round(N * 2^COUNT).  N and COUNT must be exact integers.

     With N viewed as an infinite-precision twos-complement integer,
     `round-ash' means a left shift introducing zero bits when COUNT is
     positive, or a right shift rounding to the nearest integer (with
     ties going to the nearest even integer) when COUNT is negative.
     This is a rounded ``arithmetic'' shift.

          (number->string (round-ash #b1 3) 2)     ==> "1000"
          (number->string (round-ash #b1010 -1) 2) ==> "101"
          (number->string (round-ash #b1010 -2) 2) ==> "10"
          (number->string (round-ash #b1011 -2) 2) ==> "11"
          (number->string (round-ash #b1101 -2) 2) ==> "11"
          (number->string (round-ash #b1110 -2) 2) ==> "100"

bit-extract

- Scheme Procedure: bit-extract n start end
     Return the integer composed of the START (inclusive) through END
     (exclusive) bits of N.  The STARTth bit becomes the 0-th bit in the
     result.

          (number->string (bit-extract #b1101101010 0 4) 2)
             ==> "1010"
          (number->string (bit-extract #b1101101010 4 9) 2)
             ==> "10110"

logcount

- Scheme Procedure: logcount n
     Return the number of bits in integer N.  If integer is positive,
     the 1-bits in its binary representation are counted.  If negative,
     the 0-bits in its two's-complement binary representation are
     counted.  If 0, 0 is returned.

          (logcount #b10101010)
             ==> 4
          (logcount 0)
             ==> 0
          (logcount -2)
             ==> 1

integer-length

- Scheme Procedure: integer-length n
     Return the number of bits necessary to represent N.

          (integer-length #b10101010)
             ==> 8
          (integer-length 0)
             ==> 0
          (integer-length #b1111)
             ==> 4

number->string

- Scheme Procedure: number->string n [radix]
     Return a string holding the external representation of the number N
     in the given RADIX.  If N is inexact, a radix of 10 will be used.

string->number

- Scheme Procedure: string->number string [radix]
     Return a number of the maximally precise representation expressed
     by the given STRING.  RADIX must be an exact integer, either 2, 8,
     10, or 16.  If supplied, RADIX is a default radix that may be
     overridden by an explicit radix prefix in STRING (e.g.  "#o177").
     If RADIX is not supplied, then the default radix is 10.  If string
     is not a syntactically valid notation for a number, then
     `string->number' returns `#f'.

number?

- Scheme Procedure: number? x
     Return `#t' if X is a number, `#f' otherwise.

complex?

- Scheme Procedure: complex? x
     Return `#t' if X is a complex number, `#f' otherwise.  Note that
     the sets of real, rational and integer values form subsets of the
     set of complex numbers, i.  e.  the predicate will also be
     fulfilled if X is a real, rational or integer number.

real?

- Scheme Procedure: real? x
     Return `#t' if X is a real number, `#f' otherwise.  Note that the
     set of integer values forms a subset of the set of real numbers, i.
     e.  the predicate will also be fulfilled if X is an integer number.

rational?

- Scheme Procedure: rational? x
     Return `#t' if X is a rational number, `#f' otherwise.  Note that
     the set of integer values forms a subset of the set of rational
     numbers, i.  e.  the predicate will also be fulfilled if X is an
     integer number.

integer?

- Scheme Procedure: integer? x
     Return `#t' if X is an integer number, else return `#f'.

exact-integer?

- Scheme Procedure: exact-integer? x
     Return `#t' if X is an exact integer number, else return `#f'.

=

- Scheme Procedure: = [x [y .  rest]]
     Return `#t' if all parameters are numerically equal.

<

- Scheme Procedure: < [x [y .  rest]]
     Return `#t' if the list of parameters is monotonically increasing.

>

- Scheme Procedure: > [x [y .  rest]]
     Return `#t' if the list of parameters is monotonically decreasing.

<=

- Scheme Procedure: <= [x [y .  rest]]
     Return `#t' if the list of parameters is monotonically
     non-decreasing.

>=

- Scheme Procedure: >= [x [y .  rest]]
     Return `#t' if the list of parameters is monotonically
     non-increasing.

zero?

- Scheme Procedure: zero? z
     Return `#t' if Z is an exact or inexact number equal to zero.

positive?

- Scheme Procedure: positive? x
     Return `#t' if X is an exact or inexact number greater than zero.

negative?

- Scheme Procedure: negative? x
     Return `#t' if X is an exact or inexact number less than zero.

max

- Scheme Procedure: max [x [y .  rest]]
     Return the maximum of all parameter values.

min

- Scheme Procedure: min [x [y .  rest]]
     Return the minimum of all parameter values.

+

- Scheme Procedure: + [x [y .  rest]]
     Return the sum of all parameter values.  Return 0 if called without
     any parameters.

1+

- Scheme Procedure: 1+ x
     Return X+1.

-

- Scheme Procedure: - [x [y .  rest]]
     If called with one argument Z1, -Z1 returned.  Otherwise the sum of
     all but the first argument are subtracted from the first argument.

1-

- Scheme Procedure: 1- x
     Return X-1.

*

- Scheme Procedure: * [x [y .  rest]]
     Return the product of all arguments.  If called without arguments,
     1 is returned.

/

- Scheme Procedure: / [x [y .  rest]]
     Divide the first argument by the product of the remaining
     arguments.  If called with one argument Z1, 1/Z1 is returned.

truncate

- Scheme Procedure: truncate x
     Round the number X towards zero.

round

- Scheme Procedure: round x
     Round the number X towards the nearest integer.  When it is exactly
     halfway between two integers, round towards the even one.

floor

- Scheme Procedure: floor x
     Round the number X towards minus infinity.

ceiling

- Scheme Procedure: ceiling x
     Round the number X towards infinity.

expt

- Scheme Procedure: expt x y
     Return X raised to the power of Y.

sin

- Scheme Procedure: sin z
     Compute the sine of Z.

cos

- Scheme Procedure: cos z
     Compute the cosine of Z.

tan

- Scheme Procedure: tan z
     Compute the tangent of Z.

sinh

- Scheme Procedure: sinh z
     Compute the hyperbolic sine of Z.

cosh

- Scheme Procedure: cosh z
     Compute the hyperbolic cosine of Z.

tanh

- Scheme Procedure: tanh z
     Compute the hyperbolic tangent of Z.

asin

- Scheme Procedure: asin z
     Compute the arc sine of Z.

acos

- Scheme Procedure: acos z
     Compute the arc cosine of Z.

atan

- Scheme Procedure: atan z [y]
     With one argument, compute the arc tangent of Z.  If Y is present,
     compute the arc tangent of Z/Y, using the sign of Z and Y to
     determine the quadrant.

asinh

- Scheme Procedure: asinh z
     Compute the inverse hyperbolic sine of Z.

acosh

- Scheme Procedure: acosh z
     Compute the inverse hyperbolic cosine of Z.

atanh

- Scheme Procedure: atanh z
     Compute the inverse hyperbolic tangent of Z.

make-rectangular

- Scheme Procedure: make-rectangular real_part imaginary_part
     Return a complex number constructed of the given REAL_PART and
     IMAGINARY_PART parts.

make-polar

- Scheme Procedure: make-polar mag ang
     Return the complex number MAG * e^(i * ANG).

real-part

- Scheme Procedure: real-part z
     Return the real part of the number Z.

imag-part

- Scheme Procedure: imag-part z
     Return the imaginary part of the number Z.

numerator

- Scheme Procedure: numerator z
     Return the numerator of the number Z.

denominator

- Scheme Procedure: denominator z
     Return the denominator of the number Z.

magnitude

- Scheme Procedure: magnitude z
     Return the magnitude of the number Z.  This is the same as `abs'
     for real arguments, but also allows complex numbers.

angle

- Scheme Procedure: angle z
     Return the angle of the complex number Z.

exact->inexact

- Scheme Procedure: exact->inexact z
     Convert the number Z to its inexact representation.

inexact->exact

- Scheme Procedure: inexact->exact z
     Return an exact number that is numerically closest to Z.

rationalize

- Scheme Procedure: rationalize x eps
     Returns the _simplest_ rational number differing from X by no more
     than EPS.

     As required by R5RS, `rationalize' only returns an exact result
     when both its arguments are exact.  Thus, you might need to use
     `inexact->exact' on the arguments.

          (rationalize (inexact->exact 1.2) 1/100)
          ==> 6/5

log

- Scheme Procedure: log z
     Return the natural logarithm of Z.

log10

- Scheme Procedure: log10 z
     Return the base 10 logarithm of Z.

exp

- Scheme Procedure: exp z
     Return e to the power of Z, where e is the base of natural
     logarithms (2.71828...).

exact-integer-sqrt

- Scheme Procedure: exact-integer-sqrt k
     Return two exact non-negative integers S and R such that K = S^2 +
     R and S^2 <= K < (S + 1)^2.  An error is raised if K is not an
     exact non-negative integer.

          (exact-integer-sqrt 10) ==> 3 and 1

sqrt

- Scheme Procedure: sqrt z
     Return the square root of Z.  Of the two possible roots (positive
     and negative), the one with positive real part is returned, or if
     that's zero then a positive imaginary part.  Thus,

          (sqrt 9.0)       ==> 3.0
          (sqrt -9.0)      ==> 0.0+3.0i
          (sqrt 1.0+1.0i)  ==> 1.09868411346781+0.455089860562227i
          (sqrt -1.0-1.0i) ==> 0.455089860562227-1.09868411346781i

object-properties

- Scheme Procedure: object-properties obj
     Return OBJ's property list.

set-object-properties!

- Scheme Procedure: set-object-properties! obj alist
     Set OBJ's property list to ALIST.

object-property

- Scheme Procedure: object-property obj key
     Return the property of OBJ with name KEY.

set-object-property!

- Scheme Procedure: set-object-property! obj key value
     In OBJ's property list, set the property named KEY to VALUE.

pair?

- Scheme Procedure: pair? x
     Return `#t' if X is a pair; otherwise return `#f'.

set-car!

- Scheme Procedure: set-car! pair value
     Stores VALUE in the car field of PAIR.  The value returned by
     `set-car!' is unspecified.

set-cdr!

- Scheme Procedure: set-cdr! pair value
     Stores VALUE in the cdr field of PAIR.  The value returned by
     `set-cdr!' is unspecified.

cddr

- Scheme Procedure: cddr x
cdar

- Scheme Procedure: cdar x
cadr

- Scheme Procedure: cadr x
caar

- Scheme Procedure: caar x
cdddr

- Scheme Procedure: cdddr x
cddar

- Scheme Procedure: cddar x
cdadr

- Scheme Procedure: cdadr x
cdaar

- Scheme Procedure: cdaar x
caddr

- Scheme Procedure: caddr x
cadar

- Scheme Procedure: cadar x
caadr

- Scheme Procedure: caadr x
caaar

- Scheme Procedure: caaar x
cddddr

- Scheme Procedure: cddddr x
cdddar

- Scheme Procedure: cdddar x
cddadr

- Scheme Procedure: cddadr x
cddaar

- Scheme Procedure: cddaar x
cdaddr

- Scheme Procedure: cdaddr x
cdadar

- Scheme Procedure: cdadar x
cdaadr

- Scheme Procedure: cdaadr x
cdaaar

- Scheme Procedure: cdaaar x
cadddr

- Scheme Procedure: cadddr x
caddar

- Scheme Procedure: caddar x
cadadr

- Scheme Procedure: cadadr x
cadaar

- Scheme Procedure: cadaar x
caaddr

- Scheme Procedure: caaddr x
caadar

- Scheme Procedure: caadar x
caaadr

- Scheme Procedure: caaadr x
caaaar

- Scheme Procedure: caaaar x
%port-property

- Scheme Procedure: %port-property port key
     Return the property of PORT associated with KEY.

%set-port-property!

- Scheme Procedure: %set-port-property! port key value
     Set the property of PORT associated with KEY to VALUE.

current-input-port

- Scheme Procedure: current-input-port
     Return the current input port.  This is the default port used by
     many input procedures.  Initially, `current-input-port' returns the
     "standard input" in Unix and C terminology.

current-output-port

- Scheme Procedure: current-output-port
     Return the current output port.  This is the default port used by
     many output procedures.  Initially, `current-output-port' returns
     the "standard output" in Unix and C terminology.

current-error-port

- Scheme Procedure: current-error-port
     Return the port to which errors and warnings should be sent (the
     "standard error" in Unix and C terminology).

current-warning-port

- Scheme Procedure: current-warning-port
     Return the port to which diagnostic warnings should be sent.

current-load-port

- Scheme Procedure: current-load-port
     Return the current-load-port.  The load port is used internally by
     `primitive-load'.

port-mode

- Scheme Procedure: port-mode port
     Return the port modes associated with the open port PORT.  These
     will not necessarily be identical to the modes used when the port
     was opened, since modes such as "append" which are used only during
     port creation are not retained.

port?

- Scheme Procedure: port? x
     Return a boolean indicating whether X is a port.  Equivalent to
     `(or (input-port? X) (output-port? X))'.

input-port?

- Scheme Procedure: input-port? x
     Return `#t' if X is an input port, otherwise return `#f'.  Any
     object satisfying this predicate also satisfies `port?'.

output-port?

- Scheme Procedure: output-port? x
     Return `#t' if X is an output port, otherwise return `#f'.  Any
     object satisfying this predicate also satisfies `port?'.

port-closed?

- Scheme Procedure: port-closed? port
     Return `#t' if PORT is closed or `#f' if it is open.

eof-object?

- Scheme Procedure: eof-object? x
     Return `#t' if X is an end-of-file object; otherwise return `#f'.

close-port

- Scheme Procedure: close-port port
     Close the specified port object.  Return `#t' if it successfully
     closes a port or `#f' if it was already closed.  An exception may
     be raised if an error occurs, for example when flushing buffered
     output.  See also close, for a procedure which can close file
     descriptors.

close-input-port

- Scheme Procedure: close-input-port port
     Close the specified input port object.  The routine has no effect
     if the file has already been closed.  An exception may be raised if
     an error occurs.  The value returned is unspecified.

     See also close, for a procedure which can close file descriptors.

close-output-port

- Scheme Procedure: close-output-port port
     Close the specified output port object.  The routine has no effect
     if the file has already been closed.  An exception may be raised if
     an error occurs.  The value returned is unspecified.

     See also close, for a procedure which can close file descriptors.

specialize-port-encoding!

- Scheme Procedure: specialize-port-encoding! port encoding
%port-encoding

- Scheme Procedure: %port-encoding port
     Returns, as a symbol, the character encoding that PORT uses to
     interpret its input and output.

%set-port-encoding!

- Scheme Procedure: %set-port-encoding! port enc
     Sets the character encoding that will be used to interpret all port
     I/O.  New ports are created with the encoding appropriate for the
     current locale if `setlocale' has been called or ISO-8859-1
     otherwise and this procedure can be used to modify that encoding.

port-conversion-strategy

- Scheme Procedure: port-conversion-strategy port
     Returns the behavior of the port when handling a character that is
     not representable in the port's current encoding.  It returns the
     symbol `error' if unrepresentable characters should cause
     exceptions, `substitute' if the port should try to replace
     unrepresentable characters with question marks or approximate
     characters, or `escape' if unrepresentable characters should be
     converted to string escapes.

     If PORT is `#f', then the current default behavior will be
     returned.  New ports will have this default behavior when they are
     created.

set-port-conversion-strategy!

- Scheme Procedure: set-port-conversion-strategy! port sym
     Sets the behavior of the interpreter when outputting a character
     that is not representable in the port's current encoding.  SYM can
     be either `'error', `'substitute', or `'escape'.  If it is
     `'error', an error will be thrown when an unconvertible character
     is encountered.  If it is `'substitute', then unconvertible
     characters will be replaced with approximate characters, or with
     question marks if no approximately correct character is available.
     If it is `'escape', it will appear as a hex escape when output.

     If PORT is an open port, the conversion error behavior is set for
     that port.  If it is `#f', it is set as the default behavior for
     any future ports that get created in this thread.

port-read-wait-fd

- Scheme Procedure: port-read-wait-fd port
port-write-wait-fd

- Scheme Procedure: port-write-wait-fd port
port-poll

- Scheme Procedure: port-poll port events [timeout]
port-decode-char

- Scheme Procedure: port-decode-char port bv start count
read-char

- Scheme Procedure: read-char [port]
     Return the next character available from PORT, updating PORT to
     point to the following character.  If no more characters are
     available, the end-of-file object is returned.

     When PORT's data cannot be decoded according to its character
     encoding, a `decoding-error' is raised and PORT points past the
     erroneous byte sequence.

peek-char

- Scheme Procedure: peek-char [port]
     Return the next character available from PORT, _without_ updating
     PORT to point to the following character.  If no more characters
     are available, the end-of-file object is returned.

     The value returned by a call to `peek-char' is the same as the
     value that would have been returned by a call to `read-char' on the
     same port.  The only difference is that the very next call to
     `read-char' or `peek-char' on that PORT will return the value
     returned by the preceding call to `peek-char'.  In particular, a
     call to `peek-char' on an interactive port will hang waiting for
     input whenever a call to `read-char' would have hung.

     As for `read-char', a `decoding-error' may be raised if such a
     situation occurs.  However, unlike with `read-char', PORT still
     points at the beginning of the erroneous byte sequence when the
     error is raised.

unread-char

- Scheme Procedure: unread-char cobj [port]
     Place character COBJ in PORT so that it will be read by the next
     read operation.  If called multiple times, the unread characters
     will be read again in last-in first-out order.  If PORT is not
     supplied, the current input port is used.

unread-string

- Scheme Procedure: unread-string str [port]
     Place the string STR in PORT so that its characters will be read in
     subsequent read operations.  If called multiple times, the unread
     characters will be read again in last-in first-out order.  If PORT
     is not supplied, the current-input-port is used.

setvbuf

- Scheme Procedure: setvbuf port mode [size]
     Set the buffering mode for PORT.  MODE can be one of the following
     symbols:

     none
          no buffering

     line
          line buffering

     block
          block buffering, using a newly allocated buffer of SIZE bytes.
          If SIZE is omitted, a default size will be used.

     Only certain types of ports are supported, most importantly file
     ports.

drain-input

- Scheme Procedure: drain-input port
     This procedure clears a port's input buffers, similar to the way
     that force-output clears the output buffer.  The contents of the
     buffers are returned as a single string, e.g.,

          (define p (open-input-file ...))
          (drain-input p) => empty string, nothing buffered yet.
          (unread-char (read-char p) p)
          (drain-input p) => initial chars from p, up to the buffer size.

     Draining the buffers may be useful for cleanly finishing buffered
     I/O so that the file descriptor can be used directly for further
     input.

force-output

- Scheme Procedure: force-output [port]
     Flush the specified output port, or the current output port if PORT
     is omitted.  The current output buffer contents are passed to the
     underlying port implementation (e.g., in the case of fports, the
     data will be written to the file and the output buffer will be
     cleared.) It has no effect on an unbuffered port.

     The return value is unspecified.

port-clear-stream-start-for-bom-read

- Scheme Procedure: port-clear-stream-start-for-bom-read port
port-clear-stream-start-for-bom-write

- Scheme Procedure: port-clear-stream-start-for-bom-write port [buf]
port-random-access?

- Scheme Procedure: port-random-access? port
     Return true if the port is random-access, or false otherwise.

port-read-buffering

- Scheme Procedure: port-read-buffering port
     Return the amount of read buffering on a port, in bytes.

expand-port-read-buffer!

- Scheme Procedure: expand-port-read-buffer! port size [putback_p]
     Expand the read buffer of PORT to SIZE.  Copy the old buffered
     data, if, any, to the beginning of the new buffer, unless PUTBACK_P
     is true, in which case copy it to the end instead.  Return the new
     buffer.

port-read

- Scheme Procedure: port-read port
     Return the read function for an input port.

port-write

- Scheme Procedure: port-write port
     Return the write function for an output port.

port-read-buffer

- Scheme Procedure: port-read-buffer port
     Return the read buffer for a port.

port-write-buffer

- Scheme Procedure: port-write-buffer port
     Return the write buffer for a port.

port-auxiliary-write-buffer

- Scheme Procedure: port-auxiliary-write-buffer port
     Return the auxiliary write buffer for a port.

port-line-buffered?

- Scheme Procedure: port-line-buffered? port
     Return true if the port is line buffered.

port-encode-chars

- Scheme Procedure: port-encode-chars port buf str start count
port-encode-char

- Scheme Procedure: port-encode-char port buf ch
put-char

- Scheme Procedure: put-char port ch
     Encode CH to bytes, and send those bytes to PORT.

put-string

- Scheme Procedure: put-string port string [start [count]]
     Display the COUNT characters from STRING to PORT, starting with the
     character at index START.  START defaults to 0, and COUNT defaults
     to displaying all characters until the end of the string.

     Calling `put-string' is equivalent in all respects to calling
     `put-char' on the relevant sequence of characters, except that it
     will attempt to write multiple characters to the port at a time,
     even if the port is unbuffered.

char-ready?

- Scheme Procedure: char-ready? [port]
     Return `#t' if a character is ready on input PORT and return `#f'
     otherwise.  If `char-ready?' returns `#t' then the next `read-char'
     operation on PORT is guaranteed not to hang.  If PORT is a file
     port at end of file then `char-ready?' returns `#t'.

     `char-ready?' exists to make it possible for a program to accept
     characters from interactive ports without getting stuck waiting for
     input.  Any input editors associated with such ports must make sure
     that characters whose existence has been asserted by `char-ready?'
     cannot be rubbed out.  If `char-ready?' were to return `#f' at end
     of file, a port at end of file would be indistinguishable from an
     interactive port that has no ready characters.

seek

- Scheme Procedure: seek fd_port offset whence
     Sets the current position of FD_PORT to the integer OFFSET, which
     is interpreted according to the value of WHENCE.

     One of the following variables should be supplied for WHENCE:

     - Variable: SEEK_SET
          Seek from the beginning of the file.

     - Variable: SEEK_CUR
          Seek from the current position.

     - Variable: SEEK_END
          Seek from the end of the file.

     On systems that support it, such as GNU/Linux, the following
     constants can be used for WHENCE to navigate ``holes'' in sparse
     files:

     - Variable: SEEK_DATA
          Seek to the next location in the file greater than or equal to
          OFFSET containing data.  If OFFSET points to data, then the
          file offset is set to OFFSET.

     - Variable: SEEK_HOLE
          Seek to the next hole in the file greater than or equal to the
          OFFSET.  If OFFSET points into the middle of a hole, then the
          file offset is set to OFFSET.  If there is no hole past
          OFFSET, then the file offset is adjusted to the end of the
          file---i.e., there is an implicit hole at the end of any file.

     If FD_PORT is a file descriptor, the underlying system call is
     `lseek' (see in manual The GNU C Library Reference Manual).  PORT
     may be a string port.

     The value returned is the new position in the file.  This means
     that the current position of a port can be obtained using:

          (seek port 0 SEEK_CUR)

truncate-file

- Scheme Procedure: truncate-file object [length]
     Truncate file OBJECT to LENGTH bytes.  OBJECT can be a filename
     string, a port object, or an integer file descriptor.  The return
     value is unspecified.

     For a port or file descriptor LENGTH can be omitted, in which case
     the file is truncated at the current position (per `ftell' above).

     On most systems a file can be extended by giving a length greater
     than the current size, but this is not mandatory in the POSIX
     standard.

port-line

- Scheme Procedure: port-line port
     Return the current line number for PORT.

     The first line of a file is 0.  But you might want to add 1 when
     printing line numbers, since starting from 1 is traditional in
     error messages, and likely to be more natural to non-programmers.

set-port-line!

- Scheme Procedure: set-port-line! port line
     Set the current line number for PORT to LINE.  The first line of a
     file is 0.

port-column

- Scheme Procedure: port-column port
     Return the current column number of PORT.  If the number is
     unknown, the result is #f.  Otherwise, the result is a 0-origin
     integer - i.e.  the first character of the first line is line 0,
     column 0.  (However, when you display a file position, for example
     in an error message, we recommend you add 1 to get 1-origin
     integers.  This is because lines and column numbers traditionally
     start with 1, and that is what non-programmers will find most
     natural.)

set-port-column!

- Scheme Procedure: set-port-column! port column
     Set the current column of PORT.  Before reading the first character
     on a line the column should be 0.

port-filename

- Scheme Procedure: port-filename port
     Return the filename associated with PORT, or `#f' if no filename is
     associated with the port.

set-port-filename!

- Scheme Procedure: set-port-filename! port filename
     Change the filename associated with PORT, using the current input
     port if none is specified.  Note that this does not change the
     port's source of data, but only the value that is returned by
     `port-filename' and reported in diagnostic output.

port-for-each

- Scheme Procedure: port-for-each proc
     Apply PROC to each port in the Guile port table in turn.  The
     return value is unspecified.  More specifically, PROC is applied
     exactly once to every port that exists in the system at the time
     `port-for-each' is invoked.  Changes to the port table while
     `port-for-each' is running have no effect as far as `port-for-each'
     is concerned.

flush-all-ports

- Scheme Procedure: flush-all-ports
     Equivalent to calling `force-output' on all open output ports.  The
     return value is unspecified.

%make-void-port

- Scheme Procedure: %make-void-port mode
     Create and return a new void port.  A void port acts like
     `/dev/null'.  The MODE argument specifies the input/output modes
     for this port: see the documentation for `open-file' in File Ports.

print-options-interface

- Scheme Procedure: print-options-interface [setting]
     Option interface for the print options.  Instead of using this
     procedure directly, use the procedures `print-enable',
     `print-disable', `print-set!' and `print-options'.

simple-format

- Scheme Procedure: simple-format destination message .  args
     Write MESSAGE to DESTINATION, defaulting to the current output
     port.  MESSAGE can contain `~A' (was `%s') and `~S' (was `%S')
     escapes.  When printed, the escapes are replaced with corresponding
     members of ARGS: `~A' formats using `display' and `~S' formats
     using `write'.  If DESTINATION is `#t', then use the current output
     port, if DESTINATION is `#f', then return a string containing the
     formatted text.  Does not add a trailing newline.

newline

- Scheme Procedure: newline [port]
     Send a newline to PORT.  If PORT is omitted, send to the current
     output port.

write-char

- Scheme Procedure: write-char chr [port]
     Send character CHR to PORT.

port-with-print-state

- Scheme Procedure: port-with-print-state port [pstate]
     Create a new port which behaves like PORT, but with an included
     print state PSTATE.  PSTATE is optional.  If PSTATE isn't supplied
     and PORT already has a print state, the old print state is reused.

get-print-state

- Scheme Procedure: get-print-state port
     Return the print state of the port PORT.  If PORT has no associated
     print state, `#f' is returned.

set-procedure-minimum-arity!

- Scheme Procedure: set-procedure-minimum-arity! proc req opt rest
procedure-minimum-arity

- Scheme Procedure: procedure-minimum-arity proc
     Return the "minimum arity" of a procedure.

     If the procedure has only one arity, that arity is returned as a
     list of three values: the number of required arguments, the number
     of optional arguments, and a boolean indicating whether or not the
     procedure takes rest arguments.

     For a case-lambda procedure, the arity returned is the one with the
     lowest minimum number of arguments, and the highest maximum number
     of arguments.

     If it was not possible to determine the arity of the procedure,
     `#f' is returned.

procedure-properties

- Scheme Procedure: procedure-properties proc
     Return PROC's property list.

set-procedure-properties!

- Scheme Procedure: set-procedure-properties! proc alist
     Set PROC's property list to ALIST.

procedure-property

- Scheme Procedure: procedure-property proc key
     Return the property of PROC with name KEY.

set-procedure-property!

- Scheme Procedure: set-procedure-property! proc key val
     In PROC's property list, set the property named KEY to VAL.

procedure-name

- Scheme Procedure: procedure-name proc
     Return the name of the procedure PROC

procedure-documentation

- Scheme Procedure: procedure-documentation proc
     Return the documentation string associated with `proc'.  By
     convention, if a procedure contains more than one expression and
     the first expression is a string constant, that string is assumed
     to contain documentation for that procedure.

procedure-source

- Scheme Procedure: procedure-source proc
     Return the source of the procedure PROC.

procedure?

- Scheme Procedure: procedure? obj
     Return `#t' if OBJ is a procedure.

thunk?

- Scheme Procedure: thunk? obj
     Return `#t' if OBJ is a procedure that can be called with zero
     arguments.

procedure-with-setter?

- Scheme Procedure: procedure-with-setter? obj
     Return `#t' if OBJ is a procedure with an associated setter
     procedure.

make-procedure-with-setter

- Scheme Procedure: make-procedure-with-setter procedure setter
     Create a new procedure which behaves like PROCEDURE, but with the
     associated setter SETTER.

procedure

- Scheme Procedure: procedure proc
     Return the procedure of PROC, which must be an applicable struct.

setter

- Scheme Procedure: setter proc
     Return the setter of PROC, which must be an applicable struct with
     a setter.

make-promise

- Scheme Procedure: make-promise thunk
     Create a new promise object.

     `make-promise' is a procedural form of `delay'.  These two
     expressions are equivalent:

          (delay EXP)
          (make-promise (lambda () EXP))

force

- Scheme Procedure: force promise
     If PROMISE has not been computed yet, compute and return PROMISE,
     otherwise just return the previously computed value.

promise?

- Scheme Procedure: promise? obj
     Return true if OBJ is a promise, i.e.  a delayed computation (see
     in manual The Revised^5 Report on Scheme).

eof-object

- Scheme Procedure: eof-object
     Return the end-of-file object.

open-bytevector-input-port

- Scheme Procedure: open-bytevector-input-port bv [transcoder]
     Return an input port whose contents are drawn from bytevector BV.

get-u8

- Scheme Procedure: get-u8 port
     Read an octet from PORT, a binary input port, blocking as
     necessary.

lookahead-u8

- Scheme Procedure: lookahead-u8 port
     Like `get-u8' but does not update PORT to point past the octet.

get-bytevector-n

- Scheme Procedure: get-bytevector-n port count
     Read COUNT octets from PORT, blocking as necessary and return a
     bytevector containing the octets read.  If fewer bytes are
     available, a bytevector smaller than COUNT is returned.

get-bytevector-n!

- Scheme Procedure: get-bytevector-n! port bv start count
     Read COUNT bytes from PORT and store them in BV starting at index
     START.  Return either the number of bytes actually read or the
     end-of-file object.

get-bytevector-some

- Scheme Procedure: get-bytevector-some port
     Read from PORT, blocking as necessary, until bytes are available or
     an end-of-file is reached.  Return either the end-of-file object or
     a new bytevector containing some of the available bytes (at least
     one), and update the port position to point just past these bytes.

get-bytevector-some!

- Scheme Procedure: get-bytevector-some! port bv start count
     Read up to COUNT bytes from PORT, blocking as necessary until at
     least one byte is available or an end-of-file is reached.  Store
     them in BV starting at index START.  Return the number of bytes
     actually read, or an end-of-file object.

put-u8

- Scheme Procedure: put-u8 port octet
     Write OCTET to binary port PORT.

put-bytevector

- Scheme Procedure: put-bytevector port bv [start [count]]
     Write the contents of BV to PORT, optionally starting at index
     START and limiting to COUNT octets.

unget-bytevector

- Scheme Procedure: unget-bytevector port bv [start [count]]
     Unget the contents of BV to PORT, optionally starting at index
     START and limiting to COUNT octets.

open-bytevector-output-port

- Scheme Procedure: open-bytevector-output-port [transcoder]
     Return two values: an output port and a procedure.  The latter
     should be called with zero arguments to obtain a bytevector
     containing the data accumulated by the port.

%make-transcoded-port

- Scheme Procedure: %make-transcoded-port port
     Return a new port which reads and writes to PORT

get-string-n!

- Scheme Procedure: get-string-n! port str start count
     Read up to COUNT characters from PORT into STR, starting at START.
     If no characters can be read before the end of file is encountered,
     the end of file object is returned.  Otherwise, the number of
     characters read is returned.

random

- Scheme Procedure: random n [state]
     Return a number in [0, N).

     Accepts a positive integer or real n and returns a number of the
     same type between zero (inclusive) and N (exclusive).  The values
     returned have a uniform distribution.

     The optional argument STATE must be of the type produced by
     `seed->random-state'.  It defaults to the value of the variable
     *RANDOM-STATE*.  This object is used to maintain the state of the
     pseudo-random-number generator and is altered as a side effect of
     the random operation.

copy-random-state

- Scheme Procedure: copy-random-state [state]
     Return a copy of the random state STATE.

seed->random-state

- Scheme Procedure: seed->random-state seed
     Return a new random state using SEED.

datum->random-state

- Scheme Procedure: datum->random-state datum
     Return a new random state using DATUM, which should have been
     obtained from `random-state->datum'.

random-state->datum

- Scheme Procedure: random-state->datum state
     Return a datum representation of STATE that may be written out and
     read back with the Scheme reader.

random:uniform

- Scheme Procedure: random:uniform [state]
     Return a uniformly distributed inexact real random number in [0,1).

random:normal

- Scheme Procedure: random:normal [state]
     Return an inexact real in a normal distribution.  The distribution
     used has mean 0 and standard deviation 1.  For a normal
     distribution with mean m and standard deviation d use `(+ m (* d
     (random:normal)))'.

random:solid-sphere!

- Scheme Procedure: random:solid-sphere! v [state]
     Fills VECT with inexact real random numbers the sum of whose
     squares is less than 1.0.  Thinking of VECT as coordinates in space
     of dimension N = `(vector-length VECT)', the coordinates are
     uniformly distributed within the unit N-sphere.

random:hollow-sphere!

- Scheme Procedure: random:hollow-sphere! v [state]
     Fills vect with inexact real random numbers the sum of whose
     squares is equal to 1.0.  Thinking of vect as coordinates in space
     of dimension n = (vector-length vect), the coordinates are
     uniformly distributed over the surface of the unit n-sphere.

random:normal-vector!

- Scheme Procedure: random:normal-vector! v [state]
     Fills vect with inexact real random numbers that are independent
     and standard normally distributed (i.e., with mean 0 and variance
     1).

random:exp

- Scheme Procedure: random:exp [state]
     Return an inexact real in an exponential distribution with mean 1.
     For an exponential distribution with mean u use (* u (random:exp)).

random-state-from-platform

- Scheme Procedure: random-state-from-platform
     Construct a new random state seeded from a platform-specific source
     of entropy, appropriate for use in non-security-critical
     applications.

%read-delimited!

- Scheme Procedure: %read-delimited! delims str gobble [port [start
[end]]]
     Read characters from PORT into STR until one of the characters in
     the DELIMS string is encountered.  If GOBBLE is true, discard the
     delimiter character; otherwise, leave it in the input stream for
     the next read.  If PORT is not specified, use the value of
     `(current-input-port)'.  If START or END are specified, store data
     only into the substring of STR bounded by START and END (which
     default to the beginning and end of the string, respectively).

     Return a pair consisting of the delimiter that terminated the
     string and the number of characters read.  If reading stopped at
     the end of file, the delimiter returned is the EOF-OBJECT; if the
     string was filled without encountering a delimiter, this value is
     `#f'.

%read-line

- Scheme Procedure: %read-line [port]
     Read a newline-terminated line from PORT, allocating storage as
     necessary.  The newline terminator (if any) is removed from the
     string, and a pair consisting of the line and its delimiter is
     returned.  The delimiter may be either a newline or the EOF-OBJECT;
     if `%read-line' is called at the end of file, it returns the pair
     `(#<eof> .  #<eof>)'.

write-line

- Scheme Procedure: write-line obj [port]
     Display OBJ and a newline character to PORT.  If PORT is not
     specified, `(current-output-port)' is used.  This procedure is
     equivalent to:

          (display obj [port])
          (newline [port])

read-options-interface

- Scheme Procedure: read-options-interface [setting]
     Option interface for the read options.  Instead of using this
     procedure directly, use the procedures `read-enable',
     `read-disable', `read-set!' and `read-options'.

primitive-read

- Scheme Procedure: primitive-read [port]
     Read an s-expression from the input port PORT, or from the current
     input port if PORT is not specified.  Any whitespace before the
     next token is discarded.

read-hash-extend

- Scheme Procedure: read-hash-extend chr proc
     Install the procedure PROC for reading expressions starting with
     the character sequence `#' and CHR.  PROC will be called with two
     arguments: the character CHR and the port to read further data
     from.  The object returned will be the return value of `read'.
     Passing `#f' for PROC will remove a previous setting.

file-encoding

- Scheme Procedure: file-encoding port
     Scans the port for an Emacs-like character coding declaration near
     the top of the contents of a port with random-accessible contents.
     The coding declaration is of the form `coding: XXXXX' and must
     appear in a scheme comment.

     Returns a string containing the character encoding of the file if a
     declaration was found, or `#f' otherwise.

read-string!/partial

- Scheme Procedure: read-string!/partial str [port_or_fdes [start
[end]]]
     Read characters from a port or file descriptor into a string STR.  A
     port must have an underlying file descriptor --- a so-called fport.
     This procedure is scsh-compatible and can efficiently read large
     strings.  It will:

        * attempt to fill the entire string, unless the START and/or END
          arguments are supplied.  i.e., START defaults to 0 and END
          defaults to `(string-length str)'

        * use the current input port if PORT_OR_FDES is not supplied.

        * return fewer than the requested number of characters in some
          cases, e.g., on end of file, if interrupted by a signal, or if
          not all the characters are immediately available.

        * wait indefinitely for some input if no characters are
          currently available, unless the port is in non-blocking mode.

        * read characters from the port's input buffers if available,
          instead from the underlying file descriptor.

        * return `#f' if end-of-file is encountered before reading any
          characters, otherwise return the number of characters read.

        * return 0 if the port is in non-blocking mode and no characters
          are immediately available.

        * return 0 if the request is for 0 bytes, with no end-of-file
          check.

write-string/partial

- Scheme Procedure: write-string/partial str [port_or_fdes [start
[end]]]
     Write characters from a string STR to a port or file descriptor.  A
     port must have an underlying file descriptor --- a so-called fport.
     This procedure is scsh-compatible and can efficiently write large
     strings.  It will:

        * attempt to write the entire string, unless the START and/or
          END arguments are supplied.  i.e., START defaults to 0 and END
          defaults to `(string-length str)'

        * use the current output port if PORT_OF_FDES is not supplied.

        * in the case of a buffered port, store the characters in the
          port's output buffer, if all will fit.  If they will not fit
          then any existing buffered characters will be flushed before
          attempting to write the new characters directly to the
          underlying file descriptor.  If the port is in non-blocking
          mode and buffered characters can not be flushed immediately,
          then an `EAGAIN' system-error exception will be raised (Note:
          scsh does not support the use of non-blocking buffered ports.)

        * write fewer than the requested number of characters in some
          cases, e.g., if interrupted by a signal or if not all of the
          output can be accepted immediately.

        * wait indefinitely for at least one character from STR to be
          accepted by the port, unless the port is in non-blocking mode.

        * return the number of characters accepted by the port.

        * return 0 if the port is in non-blocking mode and can not
          accept at least one character from STR immediately

        * return 0 immediately if the request size is 0 bytes.

sigaction

- Scheme Procedure: sigaction signum [handler [flags [thread]]]
     Install or report the signal handler for a specified signal.

     SIGNUM is the signal number, which can be specified using the value
     of variables such as `SIGINT'.

     If HANDLER is omitted, `sigaction' returns a pair: the CAR is the
     current signal handler, which will be either an integer with the
     value `SIG_DFL' (default action) or `SIG_IGN' (ignore), or the
     Scheme procedure which handles the signal, or `#f' if a non-Scheme
     procedure handles the signal.  The CDR contains the current
     `sigaction' flags for the handler.

     If HANDLER is provided, it is installed as the new handler for
     SIGNUM.  HANDLER can be a Scheme procedure taking one argument, or
     the value of `SIG_DFL' (default action) or `SIG_IGN' (ignore), or
     `#f' to restore whatever signal handler was installed before
     `sigaction' was first used.  When a scheme procedure has been
     specified, that procedure will run in the given THREAD.  When no
     thread has been given, the thread that made this call to
     `sigaction' is used.  Flags can optionally be specified for the new
     handler.  The return value is a pair with information about the old
     handler as described above.

     This interface does not provide access to the "signal blocking"
     facility.  Maybe this is not needed, since the thread support may
     provide solutions to the problem of consistent access to data
     structures.

restore-signals

- Scheme Procedure: restore-signals
     Return all signal handlers to the values they had before any call
     to `sigaction' was made.  The return value is unspecified.

alarm

- Scheme Procedure: alarm i
     Set a timer to raise a `SIGALRM' signal after the specified number
     of seconds (an integer).  It's advisable to install a signal
     handler for `SIGALRM' beforehand, since the default action is to
     terminate the process.

     The return value indicates the time remaining for the previous
     alarm, if any.  The new value replaces the previous alarm.  If
     there was no previous alarm, the return value is zero.

setitimer

- Scheme Procedure: setitimer which_timer interval_seconds
interval_microseconds value_seconds value_microseconds
     Set the timer specified by WHICH_TIMER according to the given
     INTERVAL_SECONDS, INTERVAL_MICROSECONDS, VALUE_SECONDS, and
     VALUE_MICROSECONDS values.

     Return information about the timer's previous setting.  Errors are
     handled as described in the guile info pages under ``POSIX
     Interface Conventions''.

     The timers available are: `ITIMER_REAL', `ITIMER_VIRTUAL', and
     `ITIMER_PROF'.

     The return value will be a list of two cons pairs representing the
     current state of the given timer.  The first pair is the seconds
     and microseconds of the timer `it_interval', and the second pair is
     the seconds and microseconds of the timer `it_value'.  `ITIMER_PROF'
     or `ITIMER_VIRTUAL' are not supported on some platforms and will
     always error.  `(provided? 'ITIMER_PROF)' and `(provided?
     'ITIMER_VIRTUAL)' report whether those timers are supported.

getitimer

- Scheme Procedure: getitimer which_timer
     Return information about the timer specified by WHICH_TIMER Errors
     are handled as described in the guile info pages under ``POSIX
     Interface Conventions''.

     The timers available are: `ITIMER_REAL', `ITIMER_VIRTUAL', and
     `ITIMER_PROF'.

     The return value will be a list of two cons pairs representing the
     current state of the given timer.  The first pair is the seconds
     and microseconds of the timer `it_interval', and the second pair is
     the seconds and microseconds of the timer `it_value'.  `ITIMER_PROF'
     or `ITIMER_VIRTUAL' are not supported on some platforms and will
     always error.  `(provided? 'ITIMER_PROF)' and `(provided?
     'ITIMER_VIRTUAL)' report whether those timers are supported.

pause

- Scheme Procedure: pause
     Pause the current process (thread?) until a signal arrives whose
     action is to either terminate the current process or invoke a
     handler procedure.  The return value is unspecified.

sleep

- Scheme Procedure: sleep i
     Wait for the given number of seconds (an integer) or until a signal
     arrives.  The return value is zero if the time elapses or the
     number of seconds remaining otherwise.

     See also `usleep'.

usleep

- Scheme Procedure: usleep i
     Wait the given period USECS microseconds (an integer).  If a signal
     arrives the wait stops and the return value is the time remaining,
     in microseconds.  If the period elapses with no signal the return
     is zero.

     On most systems the process scheduler is not microsecond accurate
     and the actual period slept by `usleep' may be rounded to a system
     clock tick boundary.  Traditionally such ticks were 10 milliseconds
     apart, and that interval is often still used.

     See also `sleep'.

raise

- Scheme Procedure: raise sig
     Sends a specified signal SIG to the current process, where SIG is
     as described for the kill procedure.

system

- Scheme Procedure: system [cmd]
     Execute CMD using the operating system's "command processor".  Under
     Unix this is usually the default shell `sh'.  The value returned is
     CMD's exit status as returned by `waitpid', which can be
     interpreted using `status:exit-val' and friends.

     If `system' is called without arguments, return a boolean
     indicating whether the command processor is available.

getenv

- Scheme Procedure: getenv nam
     Looks up the string NAM in the current environment.  The return
     value is `#f' unless a string of the form `NAME=VALUE' is found, in
     which case the string `VALUE' is returned.

primitive-exit

- Scheme Procedure: primitive-exit [status]
     Terminate the current process without unwinding the Scheme stack.
     The exit status is STATUS if supplied, otherwise zero.

primitive-_exit

- Scheme Procedure: primitive-_exit [status]
     Terminate the current process using the _exit() system call and
     without unwinding the Scheme stack.  The exit status is STATUS if
     supplied, otherwise zero.

     This function is typically useful after a fork, to ensure no Scheme
     cleanups or `atexit' handlers are run (those usually belonging in
     the parent rather than the child).

restricted-vector-sort!

- Scheme Procedure: restricted-vector-sort! vec less startpos endpos
     Sort the vector VEC, using LESS for comparing the vector elements.
     STARTPOS (inclusively) and ENDPOS (exclusively) delimit the range
     of the vector which gets sorted.  The return value is not
     specified.

sorted?

- Scheme Procedure: sorted? items less
     Return `#t' iff ITEMS is a list or vector such that, for each
     element X and the next element Y of ITEMS, `(LESS Y X)' returns
     `#f'.

merge

- Scheme Procedure: merge alist blist less
     Merge two already sorted lists into one.  Given two lists ALIST and
     BLIST, such that `(sorted? alist less?)' and `(sorted? blist
     less?)', return a new list in which the elements of ALIST and BLIST
     have been stably interleaved so that `(sorted? (merge alist blist
     less?) less?)'.  Note: this does _not_ accept vectors.

merge!

- Scheme Procedure: merge! alist blist less
     Takes two lists ALIST and BLIST such that `(sorted? alist less?)'
     and `(sorted? blist less?)' and returns a new list in which the
     elements of ALIST and BLIST have been stably interleaved so that
     `(sorted? (merge alist blist less?) less?)'.  This is the
     destructive variant of `merge' Note: this does _not_ accept
     vectors.

sort!

- Scheme Procedure: sort! items less
     Sort the sequence ITEMS, which may be a list or a vector.  LESS is
     used for comparing the sequence elements.  The sorting is
     destructive, that means that the input sequence is modified to
     produce the sorted result.  This is not a stable sort.

sort

- Scheme Procedure: sort items less
     Sort the sequence ITEMS, which may be a list or a vector.  LESS is
     used for comparing the sequence elements.  This is not a stable
     sort.

stable-sort!

- Scheme Procedure: stable-sort! items less
     Sort the sequence ITEMS, which may be a list or a vector.  LESS is
     used for comparing the sequence elements.  The sorting is
     destructive, that means that the input sequence is modified to
     produce the sorted result.  This is a stable sort.

stable-sort

- Scheme Procedure: stable-sort items less
     Sort the sequence ITEMS, which may be a list or a vector.  LESS is
     used for comparing the sequence elements.  This is a stable sort.

sort-list!

- Scheme Procedure: sort-list! items less
     Sort the list ITEMS, using LESS for comparing the list elements.
     The sorting is destructive, that means that the input list is
     modified to produce the sorted result.  This is a stable sort.

sort-list

- Scheme Procedure: sort-list items less
     Sort the list ITEMS, using LESS for comparing the list elements.
     This is a stable sort.

supports-source-properties?

- Scheme Procedure: supports-source-properties? obj
     Return #t if OBJ supports adding source properties, otherwise
     return #f.

source-properties

- Scheme Procedure: source-properties obj
     Return the source property association list of OBJ.

set-source-properties!

- Scheme Procedure: set-source-properties! obj alist
     Install the association list ALIST as the source property list for
     OBJ.

source-property

- Scheme Procedure: source-property obj key
     Return the source property specified by KEY from OBJ's source
     property list.

set-source-property!

- Scheme Procedure: set-source-property! obj key datum
     Set the source property of object OBJ, which is specified by KEY to
     DATUM.  Normally, the key will be a symbol.

cons-source

- Scheme Procedure: cons-source xorig x y
     Create and return a new pair whose car and cdr are X and Y.  Any
     source properties associated with XORIG are also associated with
     the new pair.

append-reverse

- Scheme Procedure: append-reverse revhead tail
     Reverse REV-HEAD, append TAIL to it, and return the result.  This
     is equivalent to `(append (reverse REV-HEAD) TAIL)', but its
     implementation is more efficient.

          (append-reverse '(1 2 3) '(4 5 6)) ==> (3 2 1 4 5 6)

append-reverse!

- Scheme Procedure: append-reverse! revhead tail
     Reverse REV-HEAD, append TAIL to it, and return the result.  This
     is equivalent to `(append! (reverse! REV-HEAD) TAIL)', but its
     implementation is more efficient.

          (append-reverse! (list 1 2 3) '(4 5 6)) ==> (3 2 1 4 5 6)

     REV-HEAD may be modified in order to produce the result.

concatenate

- Scheme Procedure: concatenate lstlst
     Construct a list by appending all lists in LSTLST.

     `concatenate' is the same as `(apply append LSTLST)'.  It exists
     because some Scheme implementations have a limit on the number of
     arguments a function takes, which the `apply' might exceed.  In
     Guile there is no such limit.

concatenate!

- Scheme Procedure: concatenate! lstlst
     Construct a list by appending all lists in LSTLST.  Those lists may
     be modified to produce the result.

     `concatenate!' is the same as `(apply append! LSTLST)'.  It exists
     because some Scheme implementations have a limit on the number of
     arguments a function takes, which the `apply' might exceed.  In
     Guile there is no such limit.

count

- Scheme Procedure: count pred list1 .  rest
     Return a count of the number of times PRED returns true when called
     on elements from the given lists.

     PRED is called with N parameters `(PRED ELEM1 ... ELEMN)', each
     element being from the corresponding LIST1 ... LSTN.  The first
     call is with the first element of each list, the second with the
     second element from each, and so on.

     Counting stops when the end of the shortest list is reached.  At
     least one list must be non-circular.

delete

- Scheme Procedure: delete x lst [pred]
     Return a list containing the elements of LST but with those equal
     to X deleted.  The returned elements will be in the same order as
     they were in LST.

     Equality is determined by PRED, or `equal?' if not given.  An
     equality call is made just once for each element, but the order in
     which the calls are made on the elements is unspecified.

     The equality calls are always `(pred x elem)', ie.: the given X is
     first.  This means for instance elements greater than 5 can be
     deleted with `(delete 5 lst <)'.

     LST is not modified, but the returned list might share a common
     tail with LST.

delete!

- Scheme Procedure: delete! x lst [pred]
     Return a list containing the elements of LST but with those equal
     to X deleted.  The returned elements will be in the same order as
     they were in LST.

     Equality is determined by PRED, or `equal?' if not given.  An
     equality call is made just once for each element, but the order in
     which the calls are made on the elements is unspecified.

     The equality calls are always `(pred x elem)', ie.: the given X is
     first.  This means for instance elements greater than 5 can be
     deleted with `(delete 5 lst <)'.

     LST may be modified to construct the returned list.

delete-duplicates

- Scheme Procedure: delete-duplicates lst [pred]
     Return a list containing the elements of LST but without
     duplicates.

     When elements are equal, only the first in LST is retained.  Equal
     elements can be anywhere in LST, they don't have to be adjacent.
     The returned list will have the retained elements in the same order
     as they were in LST.

     Equality is determined by PRED, or `equal?' if not given.  Calls
     `(pred x y)' are made with element X being before Y in LST.  A call
     is made at most once for each combination, but the sequence of the
     calls across the elements is unspecified.

     LST is not modified, but the return might share a common tail with
     LST.

     In the worst case, this is an O(N^2) algorithm because it must
     check each element against all those preceding it.  For long lists
     it is more efficient to sort and then compare only adjacent
     elements.

delete-duplicates!

- Scheme Procedure: delete-duplicates! lst [pred]
     Return a list containing the elements of LST but without
     duplicates.

     When elements are equal, only the first in LST is retained.  Equal
     elements can be anywhere in LST, they don't have to be adjacent.
     The returned list will have the retained elements in the same order
     as they were in LST.

     Equality is determined by PRED, or `equal?' if not given.  Calls
     `(pred x y)' are made with element X being before Y in LST.  A call
     is made at most once for each combination, but the sequence of the
     calls across the elements is unspecified.

     LST may be modified to construct the returned list.

     In the worst case, this is an O(N^2) algorithm because it must
     check each element against all those preceding it.  For long lists
     it is more efficient to sort and then compare only adjacent
     elements.

length+

- Scheme Procedure: length+ lst
     Return the length of LST, or `#f' if LST is circular.

list-copy

- Scheme Procedure: list-copy lst
     Return a copy of the given list LST.

     LST can be a proper or improper list.  And if LST is not a pair
     then it's treated as the final tail of an improper list and simply
     returned.

lset-difference!

- Scheme Procedure: lset-difference! equal lst .  rest
     Return LST with any elements in the lists in REST removed (ie.:
     subtracted).  For only one LST argument, just that list is
     returned.

     The given EQUAL procedure is used for comparing elements, called as
     `(EQUAL elem1 elemN)'.  The first argument is from LST and the
     second from one of the subsequent lists.  But exactly which calls
     are made and in what order is unspecified.

          (lset-difference! eqv? (list 'x 'y))           ==> (x y)
          (lset-difference! eqv? (list 1 2 3) '(3 1))    ==> (2)
          (lset-difference! eqv? (list 1 2 3) '(3) '(2)) ==> (1)

     `lset-difference!' may modify LST to form its result.

partition

- Scheme Procedure: partition pred list
     Partition the elements of LIST with predicate PRED.  Return two
     values: the list of elements satisfying PRED and the list of
     elements _not_ satisfying PRED.  The order of the output lists
     follows the order of LIST.  LIST is not mutated.  One of the output
     lists may share memory with LIST.

partition!

- Scheme Procedure: partition! pred lst
     Split LST into those elements which do and don't satisfy the
     predicate PRED.

     The return is two values (see Multiple Values), the first being a
     list of all elements from LST which satisfy PRED, the second a list
     of those which do not.

     The elements in the result lists are in the same order as in LST
     but the order in which the calls `(PRED elem)' are made on the list
     elements is unspecified.

     LST may be modified to construct the return lists.

remove

- Scheme Procedure: remove pred list
     Return a list containing all elements from LIST which do not
     satisfy the predicate PRED.  The elements in the result list have
     the same order as in LIST.  The order in which PRED is applied to
     the list elements is not specified.

remove!

- Scheme Procedure: remove! pred list
     Return a list containing all elements from LIST which do not
     satisfy the predicate PRED.  The elements in the result list have
     the same order as in LIST.  The order in which PRED is applied to
     the list elements is not specified.  LIST may be modified to build
     the return list.

make-srfi-4-vector

- Scheme Procedure: make-srfi-4-vector type len [fill]
     Make a srfi-4 vector

srfi-4-vector-type-size

- Scheme Procedure: srfi-4-vector-type-size vec
     Return the size, in bytes, of each element of a srfi-4 vector.

string-null?

- Scheme Procedure: string-null? str
     Return `#t' if STR's length is zero, and `#f' otherwise.

          (string-null? "")  ==> #t
          y                    ==> "foo"
          (string-null? y)     ==> #f

string-any-c-code

- Scheme Procedure: string-any-c-code char_pred s [start [end]]
     Check if CHAR_PRED is true for any character in string S.

     CHAR_PRED can be a character to check for any equal to that, or a
     character set (see Character Sets) to check for any in that set, or
     a predicate procedure to call.

     For a procedure, calls `(CHAR_PRED c)' are made successively on the
     characters from START to END.  If CHAR_PRED returns true (ie.:
     non-`#f'), `string-any' stops and that return value is the return
     from `string-any'.  The call on the last character (ie.: at END-1),
     if that point is reached, is a tail call.

     If there are no characters in S (ie.: START equals END) then the
     return is `#f'.

string-every-c-code

- Scheme Procedure: string-every-c-code char_pred s [start [end]]
     Check if CHAR_PRED is true for every character in string S.

     CHAR_PRED can be a character to check for every character equal to
     that, or a character set (see Character Sets) to check for every
     character being in that set, or a predicate procedure to call.

     For a procedure, calls `(CHAR_PRED c)' are made successively on the
     characters from START to END.  If CHAR_PRED returns `#f',
     `string-every' stops and returns `#f'.  The call on the last
     character (ie.: at END-1), if that point is reached, is a tail call
     and the return from that call is the return from `string-every'.

     If there are no characters in S (ie.: START equals END) then the
     return is `#t'.

string-tabulate

- Scheme Procedure: string-tabulate proc len
     PROC is an integer->char procedure.  Construct a string of size LEN
     by applying PROC to each index to produce the corresponding string
     element.  The order in which PROC is applied to the indices is not
     specified.

string->list

- Scheme Procedure: string->list str [start [end]]
     Convert the string STR into a list of characters.

reverse-list->string

- Scheme Procedure: reverse-list->string chrs
     An efficient implementation of `(compose list->string reverse)':

          (reverse-list->string '(#\a #\B #\c)) ==> "cBa"

string-join

- Scheme Procedure: string-join ls [delimiter [grammar]]
     Append the string in the string list LS, using the string DELIMITER
     as a delimiter between the elements of LS.  DELIMITER defaults to
     `' , that is, strings in LS are appended with the space character
     in between them.  GRAMMAR is a symbol which specifies how the
     delimiter is placed between the strings, and defaults to the symbol
     `infix'.

     infix
          Insert the separator between list elements.  An empty string
          will produce an empty list.

     strict-infix
          Like `infix', but will raise an error if given the empty list.

     suffix
          Insert the separator after every list element.

     prefix
          Insert the separator before each list element.

string-copy

- Scheme Procedure: string-copy str [start [end]]
     Return a freshly allocated copy of the string STR.  If given, START
     and END delimit the portion of STR which is copied.

string-copy!

- Scheme Procedure: string-copy! target tstart s [start [end]]
     Copy the sequence of characters from index range [START, END) in
     string S to string TARGET, beginning at index TSTART.  The
     characters are copied left-to-right or right-to-left as needed --
     the copy is guaranteed to work, even if TARGET and S are the same
     string.  It is an error if the copy operation runs off the end of
     the target string.

substring-move!

- Scheme Procedure: substring-move! str1 start1 end1 str2 start2
     Copy the substring of STR1 bounded by START1 and END1 into STR2
     beginning at position START2.  STR1 and STR2 can be the same
     string.

string-take

- Scheme Procedure: string-take s n
     Return the N first characters of S.

string-drop

- Scheme Procedure: string-drop s n
     Return all but the first N characters of S.

string-take-right

- Scheme Procedure: string-take-right s n
     Return the N last characters of S.

string-drop-right

- Scheme Procedure: string-drop-right s n
     Return all but the last N characters of S.

string-pad

- Scheme Procedure: string-pad s len [chr [start [end]]]
     Take that characters from START to END from the string S and return
     a new string, right-padded by the character CHR to length LEN.  If
     the resulting string is longer than LEN, it is truncated on the
     right.

string-pad-right

- Scheme Procedure: string-pad-right s len [chr [start [end]]]
     Take that characters from START to END from the string S and return
     a new string, left-padded by the character CHR to length LEN.  If
     the resulting string is longer than LEN, it is truncated on the
     left.

string-trim

- Scheme Procedure: string-trim s [char_pred [start [end]]]
     Trim S by skipping over all characters on the left that satisfy the
     parameter CHAR_PRED:

        * if it is the character CH, characters equal to CH are trimmed,

        * if it is a procedure PRED characters that satisfy PRED are
          trimmed,

        * if it is a character set, characters in that set are trimmed.

     If called without a CHAR_PRED argument, all whitespace is trimmed.

string-trim-right

- Scheme Procedure: string-trim-right s [char_pred [start [end]]]
     Trim S by skipping over all characters on the right that satisfy
     the parameter CHAR_PRED:

        * if it is the character CH, characters equal to CH are trimmed,

        * if it is a procedure PRED characters that satisfy PRED are
          trimmed,

        * if it is a character sets, all characters in that set are
          trimmed.

     If called without a CHAR_PRED argument, all whitespace is trimmed.

string-trim-both

- Scheme Procedure: string-trim-both s [char_pred [start [end]]]
     Trim S by skipping over all characters on both sides of the string
     that satisfy the parameter CHAR_PRED:

        * if it is the character CH, characters equal to CH are trimmed,

        * if it is a procedure PRED characters that satisfy PRED are
          trimmed,

        * if it is a character set, the characters in the set are
          trimmed.

     If called without a CHAR_PRED argument, all whitespace is trimmed.

string-fill!

- Scheme Procedure: string-fill! str chr [start [end]]
     Stores CHR in every element of the given STR and returns an
     unspecified value.

string-compare

- Scheme Procedure: string-compare s1 s2 proc_lt proc_eq proc_gt [start1
[end1 [start2 [end2]]]]
     Apply PROC_LT, PROC_EQ, PROC_GT to the mismatch index, depending
     upon whether S1 is less than, equal to, or greater than S2.  The
     mismatch index is the largest index I such that for every 0 <= J <
     I, S1[J] = S2[J] -- that is, I is the first position that does not
     match.

string-compare-ci

- Scheme Procedure: string-compare-ci s1 s2 proc_lt proc_eq proc_gt
[start1 [end1 [start2 [end2]]]]
     Apply PROC_LT, PROC_EQ, PROC_GT to the mismatch index, depending
     upon whether S1 is less than, equal to, or greater than S2.  The
     mismatch index is the largest index I such that for every 0 <= J <
     I, S1[J] = S2[J] -- that is, I is the first position where the
     lowercased letters do not match.

string=

- Scheme Procedure: string= s1 s2 [start1 [end1 [start2 [end2]]]]
     Return `#f' if S1 and S2 are not equal, a true value otherwise.

string<>

- Scheme Procedure: string<> s1 s2 [start1 [end1 [start2 [end2]]]]
     Return `#f' if S1 and S2 are equal, a true value otherwise.

string<

- Scheme Procedure: string< s1 s2 [start1 [end1 [start2 [end2]]]]
     Return `#f' if S1 is greater or equal to S2, a true value
     otherwise.

string>

- Scheme Procedure: string> s1 s2 [start1 [end1 [start2 [end2]]]]
     Return `#f' if S1 is less or equal to S2, a true value otherwise.

string<=

- Scheme Procedure: string<= s1 s2 [start1 [end1 [start2 [end2]]]]
     Return `#f' if S1 is greater to S2, a true value otherwise.

string>=

- Scheme Procedure: string>= s1 s2 [start1 [end1 [start2 [end2]]]]
     Return `#f' if S1 is less to S2, a true value otherwise.

string-ci=

- Scheme Procedure: string-ci= s1 s2 [start1 [end1 [start2 [end2]]]]
     Return `#f' if S1 and S2 are not equal, a true value otherwise.  The
     character comparison is done case-insensitively.

string-ci<>

- Scheme Procedure: string-ci<> s1 s2 [start1 [end1 [start2 [end2]]]]
     Return `#f' if S1 and S2 are equal, a true value otherwise.  The
     character comparison is done case-insensitively.

string-ci<

- Scheme Procedure: string-ci< s1 s2 [start1 [end1 [start2 [end2]]]]
     Return `#f' if S1 is greater or equal to S2, a true value
     otherwise.  The character comparison is done case-insensitively.

string-ci>

- Scheme Procedure: string-ci> s1 s2 [start1 [end1 [start2 [end2]]]]
     Return `#f' if S1 is less or equal to S2, a true value otherwise.
     The character comparison is done case-insensitively.

string-ci<=

- Scheme Procedure: string-ci<= s1 s2 [start1 [end1 [start2 [end2]]]]
     Return `#f' if S1 is greater to S2, a true value otherwise.  The
     character comparison is done case-insensitively.

string-ci>=

- Scheme Procedure: string-ci>= s1 s2 [start1 [end1 [start2 [end2]]]]
     Return `#f' if S1 is less to S2, a true value otherwise.  The
     character comparison is done case-insensitively.

string-hash

- Scheme Procedure: string-hash s [bound [start [end]]]
     Compute a hash value for S.  the optional argument BOUND is a
     non-negative exact integer specifying the range of the hash
     function.  A positive value restricts the return value to the range
     [0,bound).

string-hash-ci

- Scheme Procedure: string-hash-ci s [bound [start [end]]]
     Compute a hash value for S.  the optional argument BOUND is a
     non-negative exact integer specifying the range of the hash
     function.  A positive value restricts the return value to the range
     [0,bound).

string-prefix-length

- Scheme Procedure: string-prefix-length s1 s2 [start1 [end1 [start2
[end2]]]]
     Return the length of the longest common prefix of the two strings.

string-prefix-length-ci

- Scheme Procedure: string-prefix-length-ci s1 s2 [start1 [end1 [start2
[end2]]]]
     Return the length of the longest common prefix of the two strings,
     ignoring character case.

string-suffix-length

- Scheme Procedure: string-suffix-length s1 s2 [start1 [end1 [start2
[end2]]]]
     Return the length of the longest common suffix of the two strings.

string-suffix-length-ci

- Scheme Procedure: string-suffix-length-ci s1 s2 [start1 [end1 [start2
[end2]]]]
     Return the length of the longest common suffix of the two strings,
     ignoring character case.

string-prefix?

- Scheme Procedure: string-prefix? s1 s2 [start1 [end1 [start2 [end2]]]]
     Is S1 a prefix of S2?

string-prefix-ci?

- Scheme Procedure: string-prefix-ci? s1 s2 [start1 [end1 [start2
[end2]]]]
     Is S1 a prefix of S2, ignoring character case?

string-suffix?

- Scheme Procedure: string-suffix? s1 s2 [start1 [end1 [start2 [end2]]]]
     Is S1 a suffix of S2?

string-suffix-ci?

- Scheme Procedure: string-suffix-ci? s1 s2 [start1 [end1 [start2
[end2]]]]
     Is S1 a suffix of S2, ignoring character case?

string-index

- Scheme Procedure: string-index s char_pred [start [end]]
     Search through the string S from left to right, returning the index
     of the first occurrence of a character which

        * equals CHAR_PRED, if it is character,

        * satisfies the predicate CHAR_PRED, if it is a procedure,

        * is in the set CHAR_PRED, if it is a character set.

     Return `#f' if no match is found.

string-index-right

- Scheme Procedure: string-index-right s char_pred [start [end]]
     Search through the string S from right to left, returning the index
     of the last occurrence of a character which

        * equals CHAR_PRED, if it is character,

        * satisfies the predicate CHAR_PRED, if it is a procedure,

        * is in the set if CHAR_PRED is a character set.

     Return `#f' if no match is found.

string-rindex

- Scheme Procedure: string-rindex s char_pred [start [end]]
     Search through the string S from right to left, returning the index
     of the last occurrence of a character which

        * equals CHAR_PRED, if it is character,

        * satisfies the predicate CHAR_PRED, if it is a procedure,

        * is in the set if CHAR_PRED is a character set.

     Return `#f' if no match is found.

string-skip

- Scheme Procedure: string-skip s char_pred [start [end]]
     Search through the string S from left to right, returning the index
     of the first occurrence of a character which

        * does not equal CHAR_PRED, if it is character,

        * does not satisfy the predicate CHAR_PRED, if it is a
          procedure,

        * is not in the set if CHAR_PRED is a character set.

string-skip-right

- Scheme Procedure: string-skip-right s char_pred [start [end]]
     Search through the string S from right to left, returning the index
     of the last occurrence of a character which

        * does not equal CHAR_PRED, if it is character,

        * does not satisfy the predicate CHAR_PRED, if it is a
          procedure,

        * is not in the set if CHAR_PRED is a character set.

string-count

- Scheme Procedure: string-count s char_pred [start [end]]
     Return the count of the number of characters in the string S which

        * equals CHAR_PRED, if it is character,

        * satisfies the predicate CHAR_PRED, if it is a procedure.

        * is in the set CHAR_PRED, if it is a character set.

string-contains

- Scheme Procedure: string-contains s1 s2 [start1 [end1 [start2
[end2]]]]
     Does string S1 contain string S2? Return the index in S1 where S2
     occurs as a substring, or false.  The optional start/end indices
     restrict the operation to the indicated substrings.

string-contains-ci

- Scheme Procedure: string-contains-ci s1 s2 [start1 [end1 [start2
[end2]]]]
     Does string S1 contain string S2? Return the index in S1 where S2
     occurs as a substring, or false.  The optional start/end indices
     restrict the operation to the indicated substrings.  Character
     comparison is done case-insensitively.

string-upcase!

- Scheme Procedure: string-upcase! str [start [end]]
     Destructively upcase every character in `str'.

          (string-upcase! y)
          ==> "ARRDEFG"
          y
          ==> "ARRDEFG"

string-upcase

- Scheme Procedure: string-upcase str [start [end]]
     Upcase every character in `str'.

string-downcase!

- Scheme Procedure: string-downcase! str [start [end]]
     Destructively downcase every character in STR.

          y
          ==> "ARRDEFG"
          (string-downcase! y)
          ==> "arrdefg"
          y
          ==> "arrdefg"

string-downcase

- Scheme Procedure: string-downcase str [start [end]]
     Downcase every character in STR.

string-titlecase!

- Scheme Procedure: string-titlecase! str [start [end]]
     Destructively titlecase every first character in a word in STR.

string-titlecase

- Scheme Procedure: string-titlecase str [start [end]]
     Titlecase every first character in a word in STR.

string-capitalize!

- Scheme Procedure: string-capitalize! str
     Upcase the first character of every word in STR destructively and
     return STR.

          y                      ==> "hello world"
          (string-capitalize! y) ==> "Hello World"
          y                      ==> "Hello World"

string-capitalize

- Scheme Procedure: string-capitalize str
     Return a freshly allocated string with the characters in STR, where
     the first character of every word is capitalized.

string-reverse

- Scheme Procedure: string-reverse str [start [end]]
     Reverse the string STR.  The optional arguments START and END
     delimit the region of STR to operate on.

string-reverse!

- Scheme Procedure: string-reverse! str [start [end]]
     Reverse the string STR in-place.  The optional arguments START and
     END delimit the region of STR to operate on.  The return value is
     unspecified.

string-append/shared

- Scheme Procedure: string-append/shared .  rest
     Like `string-append', but the result may share memory with the
     argument strings.

string-concatenate

- Scheme Procedure: string-concatenate ls
     Append the elements of LS (which must be strings) together into a
     single string.  Guaranteed to return a freshly allocated string.

string-concatenate-reverse

- Scheme Procedure: string-concatenate-reverse ls [final_string [end]]
     Without optional arguments, this procedure is equivalent to

          (string-concatenate (reverse ls))

     If the optional argument FINAL_STRING is specified, it is consed
     onto the beginning to LS before performing the list-reverse and
     string-concatenate operations.  If END is given, only the
     characters of FINAL_STRING up to index END are used.

     Guaranteed to return a freshly allocated string.

string-concatenate/shared

- Scheme Procedure: string-concatenate/shared ls
     Like `string-concatenate', but the result may share memory with the
     strings in the list LS.

string-concatenate-reverse/shared

- Scheme Procedure: string-concatenate-reverse/shared ls [final_string
[end]]
     Like `string-concatenate-reverse', but the result may share memory
     with the strings in the LS arguments.

string-map

- Scheme Procedure: string-map proc s [start [end]]
     PROC is a char->char procedure, it is mapped over S.  The order in
     which the procedure is applied to the string elements is not
     specified.

string-map!

- Scheme Procedure: string-map! proc s [start [end]]
     PROC is a char->char procedure, it is mapped over S.  The order in
     which the procedure is applied to the string elements is not
     specified.  The string S is modified in-place, the return value is
     not specified.

string-fold

- Scheme Procedure: string-fold kons knil s [start [end]]
     Fold KONS over the characters of S, with KNIL as the terminating
     element, from left to right.  KONS must expect two arguments: The
     actual character and the last result of KONS' application.

string-fold-right

- Scheme Procedure: string-fold-right kons knil s [start [end]]
     Fold KONS over the characters of S, with KNIL as the terminating
     element, from right to left.  KONS must expect two arguments: The
     actual character and the last result of KONS' application.

string-unfold

- Scheme Procedure: string-unfold p f g seed [base [make_final]]
        * G is used to generate a series of _seed_ values from the
          initial SEED: SEED, (G SEED), (G^2 SEED), (G^3 SEED), ...

        * P tells us when to stop -- when it returns true when applied
          to one of these seed values.

        * F maps each seed value to the corresponding character in the
          result string.  These chars are assembled into the string in a
          left-to-right order.

        * BASE is the optional initial/leftmost portion of the
          constructed string; it default to the empty string.

        * MAKE_FINAL is applied to the terminal seed value (on which P
          returns true) to produce the final/rightmost portion of the
          constructed string.  It defaults to `(lambda (x) )'.

string-unfold-right

- Scheme Procedure: string-unfold-right p f g seed [base [make_final]]
        * G is used to generate a series of _seed_ values from the
          initial SEED: SEED, (G SEED), (G^2 SEED), (G^3 SEED), ...

        * P tells us when to stop -- when it returns true when applied
          to one of these seed values.

        * F maps each seed value to the corresponding character in the
          result string.  These chars are assembled into the string in a
          right-to-left order.

        * BASE is the optional initial/rightmost portion of the
          constructed string; it default to the empty string.

        * MAKE_FINAL is applied to the terminal seed value (on which P
          returns true) to produce the final/leftmost portion of the
          constructed string.  It defaults to `(lambda (x) )'.

string-for-each

- Scheme Procedure: string-for-each proc s [start [end]]
     PROC is mapped over S in left-to-right order.  The return value is
     not specified.

string-for-each-index

- Scheme Procedure: string-for-each-index proc s [start [end]]
     Call `(PROC i)' for each index i in S, from left to right.

     For example, to change characters to alternately upper and lower
     case,

          (define str (string-copy "studly"))
          (string-for-each-index
              (lambda (i)
                (string-set! str i
                  ((if (even? i) char-upcase char-downcase)
                   (string-ref str i))))
              str)
          str ==> "StUdLy"

xsubstring

- Scheme Procedure: xsubstring s from [to [start [end]]]
     This is the _extended substring_ procedure that implements
     replicated copying of a substring of some string.

     S is a string, START and END are optional arguments that demarcate
     a substring of S, defaulting to 0 and the length of S.  Replicate
     this substring up and down index space, in both the positive and
     negative directions.  `xsubstring' returns the substring of this
     string beginning at index FROM, and ending at TO, which defaults to
     FROM + (END - START).

string-xcopy!

- Scheme Procedure: string-xcopy! target tstart s sfrom [sto [start
[end]]]
     Exactly the same as `xsubstring', but the extracted text is written
     into the string TARGET starting at index TSTART.  The operation is
     not defined if `(eq? TARGET S)' or these arguments share storage --
     you cannot copy a string on top of itself.

string-replace

- Scheme Procedure: string-replace s1 s2 [start1 [end1 [start2 [end2]]]]
     Return the string S1, but with the characters START1 ... END1
     replaced by the characters START2 ... END2 from S2.

string-tokenize

- Scheme Procedure: string-tokenize s [token_set [start [end]]]
     Split the string S into a list of substrings, where each substring
     is a maximal non-empty contiguous sequence of characters from the
     character set TOKEN_SET, which defaults to `char-set:graphic'.  If
     START or END indices are provided, they restrict `string-tokenize'
     to operating on the indicated substring of S.

string-split

- Scheme Procedure: string-split str char_pred
     Split the string STR into a list of the substrings delimited by
     appearances of characters that

        * equal CHAR_PRED, if it is a character,

        * satisfy the predicate CHAR_PRED, if it is a procedure,

        * are in the set CHAR_PRED, if it is a character set.

     Note that an empty substring between separator characters will
     result in an empty string in the result list.

          (string-split "root:x:0:0:root:/root:/bin/bash" #\:)
          ==>
          ("root" "x" "0" "0" "root" "/root" "/bin/bash")
          
          (string-split "::" #\:)
          ==>
          ("" "" "")
          
          (string-split "" #\:)
          ==>
          ("")

string-filter

- Scheme Procedure: string-filter char_pred s [start [end]]
     Filter the string S, retaining only those characters which satisfy
     CHAR_PRED.

     If CHAR_PRED is a procedure, it is applied to each character as a
     predicate, if it is a character, it is tested for equality and if
     it is a character set, it is tested for membership.

string-delete

- Scheme Procedure: string-delete char_pred s [start [end]]
     Delete characters satisfying CHAR_PRED from S.

     If CHAR_PRED is a procedure, it is applied to each character as a
     predicate, if it is a character, it is tested for equality and if
     it is a character set, it is tested for membership.

char-set?

- Scheme Procedure: char-set? obj
     Return `#t' if OBJ is a character set, `#f' otherwise.

char-set=

- Scheme Procedure: char-set= .  char_sets
     Return `#t' if all given character sets are equal.

char-set<=

- Scheme Procedure: char-set<= .  char_sets
     Return `#t' if every character set CHAR_SETi is a subset of
     character set CHAR_SETi+1.

char-set-hash

- Scheme Procedure: char-set-hash cs [bound]
     Compute a hash value for the character set CS.  If BOUND is given
     and non-zero, it restricts the returned value to the range 0 ...
     BOUND - 1.

char-set-cursor

- Scheme Procedure: char-set-cursor cs
     Return a cursor into the character set CS.

char-set-ref

- Scheme Procedure: char-set-ref cs cursor
     Return the character at the current cursor position CURSOR in the
     character set CS.  It is an error to pass a cursor for which
     `end-of-char-set?' returns true.

char-set-cursor-next

- Scheme Procedure: char-set-cursor-next cs cursor
     Advance the character set cursor CURSOR to the next character in
     the character set CS.  It is an error if the cursor given satisfies
     `end-of-char-set?'.

end-of-char-set?

- Scheme Procedure: end-of-char-set? cursor
     Return `#t' if CURSOR has reached the end of a character set, `#f'
     otherwise.

char-set-fold

- Scheme Procedure: char-set-fold kons knil cs
     Fold the procedure KONS over the character set CS, initializing it
     with KNIL.

char-set-unfold

- Scheme Procedure: char-set-unfold p f g seed [base_cs]
     This is a fundamental constructor for character sets.

        * G is used to generate a series of ``seed'' values from the
          initial seed: SEED, (G SEED), (G^2 SEED), (G^3 SEED), ...

        * P tells us when to stop -- when it returns true when applied
          to one of the seed values.

        * F maps each seed value to a character.  These characters are
          added to the base character set BASE_CS to form the result;
          BASE_CS defaults to the empty set.

char-set-unfold!

- Scheme Procedure: char-set-unfold! p f g seed base_cs
     This is a fundamental constructor for character sets.

        * G is used to generate a series of ``seed'' values from the
          initial seed: SEED, (G SEED), (G^2 SEED), (G^3 SEED), ...

        * P tells us when to stop -- when it returns true when applied
          to one of the seed values.

        * F maps each seed value to a character.  These characters are
          added to the base character set BASE_CS to form the result;
          BASE_CS defaults to the empty set.

char-set-for-each

- Scheme Procedure: char-set-for-each proc cs
     Apply PROC to every character in the character set CS.  The return
     value is not specified.

char-set-map

- Scheme Procedure: char-set-map proc cs
     Map the procedure PROC over every character in CS.  PROC must be a
     character -> character procedure.

char-set-copy

- Scheme Procedure: char-set-copy cs
     Return a newly allocated character set containing all characters in
     CS.

char-set

- Scheme Procedure: char-set .  rest
     Return a character set containing all given characters.

list->char-set

- Scheme Procedure: list->char-set list [base_cs]
     Convert the character list LIST to a character set.  If the
     character set BASE_CS is given, the character in this set are also
     included in the result.

list->char-set!

- Scheme Procedure: list->char-set! list base_cs
     Convert the character list LIST to a character set.  The characters
     are added to BASE_CS and BASE_CS is returned.

string->char-set

- Scheme Procedure: string->char-set str [base_cs]
     Convert the string STR to a character set.  If the character set
     BASE_CS is given, the characters in this set are also included in
     the result.

string->char-set!

- Scheme Procedure: string->char-set! str base_cs
     Convert the string STR to a character set.  The characters from the
     string are added to BASE_CS, and BASE_CS is returned.

char-set-filter

- Scheme Procedure: char-set-filter pred cs [base_cs]
     Return a character set containing every character from CS so that
     it satisfies PRED.  If provided, the characters from BASE_CS are
     added to the result.

char-set-filter!

- Scheme Procedure: char-set-filter! pred cs base_cs
     Return a character set containing every character from CS so that
     it satisfies PRED.  The characters are added to BASE_CS and BASE_CS
     is returned.

ucs-range->char-set

- Scheme Procedure: ucs-range->char-set lower upper [error [base_cs]]
     Return a character set containing all characters whose character
     codes lie in the half-open range [LOWER,UPPER).

     If ERROR is a true value, an error is signaled if the specified
     range contains characters which are not valid Unicode code points.
     If ERROR is `#f', these characters are silently left out of the
     resulting character set.

     The characters in BASE_CS are added to the result, if given.

ucs-range->char-set!

- Scheme Procedure: ucs-range->char-set! lower upper error base_cs
     Return a character set containing all characters whose character
     codes lie in the half-open range [LOWER,UPPER).

     If ERROR is a true value, an error is signaled if the specified
     range contains characters which are not contained in the
     implemented character range.  If ERROR is `#f', these characters
     are silently left out of the resulting character set.

     The characters are added to BASE_CS and BASE_CS is returned.

->char-set

- Scheme Procedure: ->char-set x
     Coerces x into a char-set.  X may be a string, character or
     char-set.  A string is converted to the set of its constituent
     characters; a character is converted to a singleton set; a char-set
     is returned as-is.

char-set-size

- Scheme Procedure: char-set-size cs
     Return the number of elements in character set CS.

char-set-count

- Scheme Procedure: char-set-count pred cs
     Return the number of the elements int the character set CS which
     satisfy the predicate PRED.

char-set->list

- Scheme Procedure: char-set->list cs
     Return a list containing the elements of the character set CS.

char-set->string

- Scheme Procedure: char-set->string cs
     Return a string containing the elements of the character set CS.
     The order in which the characters are placed in the string is not
     defined.

char-set-contains?

- Scheme Procedure: char-set-contains? cs ch
     Return `#t' iff the character CH is contained in the character set
     CS.

char-set-every

- Scheme Procedure: char-set-every pred cs
     Return a true value if every character in the character set CS
     satisfies the predicate PRED.

char-set-any

- Scheme Procedure: char-set-any pred cs
     Return a true value if any character in the character set CS
     satisfies the predicate PRED.

char-set-adjoin

- Scheme Procedure: char-set-adjoin cs .  rest
     Add all character arguments to the first argument, which must be a
     character set.

char-set-delete

- Scheme Procedure: char-set-delete cs .  rest
     Delete all character arguments from the first argument, which must
     be a character set.

char-set-adjoin!

- Scheme Procedure: char-set-adjoin! cs .  rest
     Add all character arguments to the first argument, which must be a
     character set.

char-set-delete!

- Scheme Procedure: char-set-delete! cs .  rest
     Delete all character arguments from the first argument, which must
     be a character set.

char-set-complement

- Scheme Procedure: char-set-complement cs
     Return the complement of the character set CS.

char-set-union

- Scheme Procedure: char-set-union .  rest
     Return the union of all argument character sets.

char-set-intersection

- Scheme Procedure: char-set-intersection .  rest
     Return the intersection of all argument character sets.

char-set-difference

- Scheme Procedure: char-set-difference cs1 .  rest
     Return the difference of all argument character sets.

char-set-xor

- Scheme Procedure: char-set-xor .  rest
     Return the exclusive-or of all argument character sets.

char-set-diff+intersection

- Scheme Procedure: char-set-diff+intersection cs1 .  rest
     Return the difference and the intersection of all argument
     character sets.

char-set-complement!

- Scheme Procedure: char-set-complement! cs
     Return the complement of the character set CS.

char-set-union!

- Scheme Procedure: char-set-union! cs1 .  rest
     Return the union of all argument character sets.

char-set-intersection!

- Scheme Procedure: char-set-intersection! cs1 .  rest
     Return the intersection of all argument character sets.

char-set-difference!

- Scheme Procedure: char-set-difference! cs1 .  rest
     Return the difference of all argument character sets.

char-set-xor!

- Scheme Procedure: char-set-xor! cs1 .  rest
     Return the exclusive-or of all argument character sets.

char-set-diff+intersection!

- Scheme Procedure: char-set-diff+intersection! cs1 cs2 .  rest
     Return the difference and the intersection of all argument
     character sets.

%char-set-dump

- Scheme Procedure: %char-set-dump charset
     Returns an association list containing debugging information for
     CHARSET.  The association list has the following entries.

     char-set
          The char-set itself.

     len
          The number of character ranges the char-set contains

     ranges
          A list of lists where each sublist a range of code points and
          their associated characters

log2-binary-factors

- Scheme Procedure: log2-binary-factors n
     Return a count of how many factors of 2 are present in N.  This is
     also the bit index of the lowest 1 bit in N.  If N is 0, the return
     is -1.

          (log2-binary-factors 6) ==> 1
          (log2-binary-factors -8) ==> 3

copy-bit

- Scheme Procedure: copy-bit index n newbit
     Return N with the bit at INDEX set according to NEWBIT.  NEWBIT
     should be `#t' to set the bit to 1, or `#f' to set it to 0.  Bits
     other than at INDEX are unchanged in the return.

          (copy-bit 1 #b0101 #t) ==> 7

rotate-bit-field

- Scheme Procedure: rotate-bit-field n count start end
     Return N with the bit field from START (inclusive) to END
     (exclusive) rotated upwards by COUNT bits.

     COUNT can be positive or negative, and it can be more than the
     field width (it'll be reduced modulo the width).

          (rotate-bit-field #b0110 2 1 4) ==> #b1010

reverse-bit-field

- Scheme Procedure: reverse-bit-field n start end
     Return N with the bits between START (inclusive) to END (exclusive)
     reversed.

          (reverse-bit-field #b101001 2 4) ==> #b100101

integer->list

- Scheme Procedure: integer->list n [len]
     Return bits from N in the form of a list of `#t' for 1 and `#f' for
     0.  The least significant LEN bits are returned, and the first list
     element is the most significant of those bits.  If LEN is not
     given, the default is `(integer-length N)' (see Bitwise
     Operations).

          (integer->list 6)   ==> (#t #t #f)
          (integer->list 1 4) ==> (#f #f #f #t)

list->integer

- Scheme Procedure: list->integer lst
     Return an integer formed bitwise from the given LST list of
     booleans.  Each boolean is `#t' for a 1 and `#f' for a 0.  The
     first element becomes the most significant bit in the return.

          (list->integer '(#t #f #t #f)) ==> 10

booleans->integer

- Scheme Procedure: booleans->integer
     implemented by the C function "scm_srfi60_list_to_integer"

%get-stack-size

- Scheme Procedure: %get-stack-size
     Return the current thread's C stack size (in Scheme objects).

stack?

- Scheme Procedure: stack? obj
     Return `#t' if OBJ is a calling stack.

make-stack

- Scheme Procedure: make-stack obj .  args
     Create a new stack.  If OBJ is `#t', the current evaluation stack
     is used for creating the stack frames, otherwise the frames are
     taken from OBJ (which must be a continuation or a frame object).

     ARGS should be a list containing any combination of integer,
     procedure, address range, prompt tag and `#t' values.

     These values specify various ways of cutting away uninteresting
     stack frames from the top and bottom of the stack that `make-stack'
     returns.  They come in pairs like this: `(INNER_CUT_1 OUTER_CUT_1
     INNER_CUT_2 OUTER_CUT_2 ...)'.

     Each INNER_CUT_I can be an integer, a procedure, an address range,
     or a prompt tag.  An integer means to cut away exactly that number
     of frames.  A procedure means to cut away all frames up to but
     excluding the frame whose procedure matches the specified one.  An
     address range is a pair of integers indicating the low and high
     addresses of a procedure's code, and is the same as cutting away to
     a procedure (though with less work).  Anything else is interpreted
     as a prompt tag which cuts away all frames that are inside a prompt
     with the given tag.

     Each OUTER_CUT_I can be an integer, a procedure, an address range,
     or a prompt tag.  An integer means to cut away that number of
     frames.  A procedure means to cut away frames down to but excluding
     the frame whose procedure matches the specified one.  An address
     range is the same, but with the procedure's code specified as an
     address range.  Anything else is taken to be a prompt tag, which
     cuts away all frames that are outside a prompt with the given tag.

     If the OUTER_CUT_I of the last pair is missing, it is taken as 0.

stack-id

- Scheme Procedure: stack-id stack
     Return the identifier given to STACK by `start-stack'.

stack-ref

- Scheme Procedure: stack-ref stack index
     Return the INDEX'th frame from STACK.

stack-length

- Scheme Procedure: stack-length stack
     Return the length of STACK.

get-internal-real-time

- Scheme Procedure: get-internal-real-time
     Return the number of time units since the interpreter was started.

times

- Scheme Procedure: times
     Return an object with information about real and processor time.
     The following procedures accept such an object as an argument and
     return a selected component:

     tms:clock
          The current real time, expressed as time units relative to an
          arbitrary base.

     tms:utime
          The CPU time units used by the calling process.

     tms:stime
          The CPU time units used by the system on behalf of the calling
          process.

     tms:cutime
          The CPU time units used by terminated child processes of the
          calling process, whose status has been collected (e.g., using
          `waitpid').

     tms:cstime
          Similarly, the CPU times units used by the system on behalf of
          terminated child processes.

get-internal-run-time

- Scheme Procedure: get-internal-run-time
     Return the number of time units of processor time used by the
     interpreter.  Both _system_ and _user_ time are included but
     subprocesses are not.

current-time

- Scheme Procedure: current-time
     Return the number of seconds since 1970-01-01 00:00:00 UTC,
     excluding leap seconds.

gettimeofday

- Scheme Procedure: gettimeofday
     Return a pair containing the number of seconds and microseconds
     since 1970-01-01 00:00:00 UTC, excluding leap seconds.  Note:
     whether true microsecond resolution is available depends on the
     operating system.

localtime

- Scheme Procedure: localtime time [zone]
     Return an object representing the broken down components of TIME,
     an integer like the one returned by `current-time'.  The time zone
     for the calculation is optionally specified by ZONE (a string),
     otherwise the `TZ' environment variable or the system default is
     used.

gmtime

- Scheme Procedure: gmtime time
     Return an object representing the broken down components of TIME,
     an integer like the one returned by `current-time'.  The values are
     calculated for UTC.

mktime

- Scheme Procedure: mktime sbd_time [zone]
     SBD_TIME is an object representing broken down time and `zone' is
     an optional time zone specifier (otherwise the TZ environment
     variable or the system default is used).

     Returns a pair: the car is a corresponding integer time value like
     that returned by `current-time'; the cdr is a broken down time
     object, similar to as SBD_TIME but with normalized values.

tzset

- Scheme Procedure: tzset
     Initialize the timezone from the TZ environment variable or the
     system default.  It's not usually necessary to call this procedure
     since it's done automatically by other procedures that depend on
     the timezone.

strftime

- Scheme Procedure: strftime format stime
     Return a string which is broken-down time structure STIME formatted
     according to the given FORMAT string.

     FORMAT contains field specifications introduced by a `%' character.
     See Formatting Calendar Time in manual The GNU C Library Reference
     Manual, or `man 3 strftime', for the available formatting.

          (strftime "%c" (localtime (current-time)))
          ==> "Mon Mar 11 20:17:43 2002"

     If `setlocale' has been called (see Locales), month and day names
     are from the current locale and in the locale character set.

strptime

- Scheme Procedure: strptime format string
     Performs the reverse action to `strftime', parsing STRING according
     to the specification supplied in FORMAT.  The interpretation of
     month and day names is dependent on the current locale.  The value
     returned is a pair.  The car has an object with time components in
     the form returned by `localtime' or `gmtime', but the time zone
     components are not usefully set.  The cdr reports the number of
     characters from STRING which were used for the conversion.

%string-dump

- Scheme Procedure: %string-dump str
     Returns an association list containing debugging information for
     STR.  The association list has the following entries.

     string
          The string itself.

     start
          The start index of the string into its stringbuf

     length
          The length of the string

     shared
          If this string is a substring, it returns its parent string.
          Otherwise, it returns `#f'

     read-only
          `#t' if the string is read-only

     stringbuf-chars
          A new string containing this string's stringbuf's characters

     stringbuf-length
          The number of characters in this stringbuf

     stringbuf-mutable
          `#t' if this stringbuf is mutable

     stringbuf-wide
          `#t' if this stringbuf's characters are stored in a 32-bit
          buffer, or `#f' if they are stored in an 8-bit buffer

%symbol-dump

- Scheme Procedure: %symbol-dump sym
     Returns an association list containing debugging information for
     SYM.  The association list has the following entries.

     symbol
          The symbol itself

     hash
          Its hash value

     interned
          `#t' if it is an interned symbol

     stringbuf-chars
          A new string containing this symbols's stringbuf's characters

     stringbuf-length
          The number of characters in this stringbuf

     stringbuf-mutable
          `#t' if this stringbuf is mutable

     stringbuf-wide
          `#t' if this stringbuf's characters are stored in a 32-bit
          buffer, or `#f' if they are stored in an 8-bit buffer

string?

- Scheme Procedure: string? obj
     Return `#t' if OBJ is a string, else `#f'.

list->string

- Scheme Procedure: list->string
     implemented by the C function "scm_string"

string

- Scheme Procedure: string .  chrs


     Return a newly allocated string composed of the arguments, CHRS.

make-string

- Scheme Procedure: make-string k [chr]
     Return a newly allocated string of length K.  If CHR is given, then
     all elements of the string are initialized to CHR, otherwise the
     contents of the string are all set to `# ul'.

string-length

- Scheme Procedure: string-length string
     Return the number of characters in STRING.

string-bytes-per-char

- Scheme Procedure: string-bytes-per-char string
     Return the bytes used to represent a character in STRING.This will
     return 1 or 4.

string-ref

- Scheme Procedure: string-ref str k
     Return character K of STR using zero-origin indexing.  K must be a
     valid index of STR.

string-set!

- Scheme Procedure: string-set! str k chr
     Store CHR in element K of STR and return an unspecified value.  K
     must be a valid index of STR.

substring

- Scheme Procedure: substring str start [end]
     Return a newly allocated string formed from the characters of STR
     beginning with index START (inclusive) and ending with index END
     (exclusive).  STR must be a string, START and END must be exact
     integers satisfying:

     0 <= START <= END <= (string-length STR).

substring/read-only

- Scheme Procedure: substring/read-only str start [end]
     Return a newly allocated string formed from the characters of STR
     beginning with index START (inclusive) and ending with index END
     (exclusive).  STR must be a string, START and END must be exact
     integers satisfying:

     0 <= START <= END <= (string-length STR).

     The returned string is read-only.

substring/copy

- Scheme Procedure: substring/copy str start [end]
     Return a newly allocated string formed from the characters of STR
     beginning with index START (inclusive) and ending with index END
     (exclusive).  STR must be a string, START and END must be exact
     integers satisfying:

     0 <= START <= END <= (string-length STR).

substring/shared

- Scheme Procedure: substring/shared str start [end]
     Return string that indirectly refers to the characters of STR
     beginning with index START (inclusive) and ending with index END
     (exclusive).  STR must be a string, START and END must be exact
     integers satisfying:

     0 <= START <= END <= (string-length STR).

string-append

- Scheme Procedure: string-append .  args
     Return a newly allocated string whose characters form the
     concatenation of the given strings, ARGS.

string-utf8-length

- Scheme Procedure: string-utf8-length string
     Returns the number of bytes in the UTF-8 representation of STRING.

string-normalize-nfc

- Scheme Procedure: string-normalize-nfc string
     Returns the NFC normalized form of STRING.

string-normalize-nfd

- Scheme Procedure: string-normalize-nfd string
     Returns the NFD normalized form of STRING.

string-normalize-nfkc

- Scheme Procedure: string-normalize-nfkc string
     Returns the NFKC normalized form of STRING.

string-normalize-nfkd

- Scheme Procedure: string-normalize-nfkd string
     Returns the NFKD normalized form of STRING.

string=?

- Scheme Procedure: string=? [s1 [s2 .  rest]]
     Lexicographic equality predicate; return `#t' if the two strings
     are the same length and contain the same characters in the same
     positions, otherwise return `#f'.

     The procedure `string-ci=?' treats upper and lower case letters as
     though they were the same character, but `string=?' treats upper
     and lower case as distinct characters.

string-ci=?

- Scheme Procedure: string-ci=? [s1 [s2 .  rest]]
     Case-insensitive string equality predicate; return `#t' if the two
     strings are the same length and their component characters match
     (ignoring case) at each position; otherwise return `#f'.

string<?

- Scheme Procedure: string<? [s1 [s2 .  rest]]
     Lexicographic ordering predicate; return `#t' if S1 is
     lexicographically less than S2.

string<=?

- Scheme Procedure: string<=? [s1 [s2 .  rest]]
     Lexicographic ordering predicate; return `#t' if S1 is
     lexicographically less than or equal to S2.

string>?

- Scheme Procedure: string>? [s1 [s2 .  rest]]
     Lexicographic ordering predicate; return `#t' if S1 is
     lexicographically greater than S2.

string>=?

- Scheme Procedure: string>=? [s1 [s2 .  rest]]
     Lexicographic ordering predicate; return `#t' if S1 is
     lexicographically greater than or equal to S2.

string-ci<?

- Scheme Procedure: string-ci<? [s1 [s2 .  rest]]
     Case insensitive lexicographic ordering predicate; return `#t' if
     S1 is lexicographically less than S2 regardless of case.

string-ci<=?

- Scheme Procedure: string-ci<=? [s1 [s2 .  rest]]
     Case insensitive lexicographic ordering predicate; return `#t' if
     S1 is lexicographically less than or equal to S2 regardless of
     case.

string-ci>?

- Scheme Procedure: string-ci>? [s1 [s2 .  rest]]
     Case insensitive lexicographic ordering predicate; return `#t' if
     S1 is lexicographically greater than S2 regardless of case.

string-ci>=?

- Scheme Procedure: string-ci>=? [s1 [s2 .  rest]]
     Case insensitive lexicographic ordering predicate; return `#t' if
     S1 is lexicographically greater than or equal to S2 regardless of
     case.

object->string

- Scheme Procedure: object->string obj [printer]
     Return a Scheme string obtained by printing OBJ.  Printing function
     can be specified by the optional second argument PRINTER (default:
     `write').

open-input-string

- Scheme Procedure: open-input-string str
     Take a string and return an input port that delivers characters
     from the string.  The port can be closed by `close-input-port',
     though its storage will be reclaimed by the garbage collector if it
     becomes inaccessible.

open-output-string

- Scheme Procedure: open-output-string
     Return an output port that will accumulate characters for retrieval
     by `get-output-string'.  The port can be closed by the procedure
     `close-output-port', though its storage will be reclaimed by the
     garbage collector if it becomes inaccessible.

get-output-string

- Scheme Procedure: get-output-string port
     Given an output port created by `open-output-string', return a
     string consisting of the characters that have been output to the
     port so far.

eval-string

- Scheme Procedure: eval-string string [module]
     Evaluate STRING as the text representation of a Scheme form or
     forms, and return whatever value they produce.  Evaluation takes
     place in the given module, or the current module when no module is
     given.  While the code is evaluated, the given module is made the
     current one.  The current module is restored when this procedure
     returns.

make-struct-layout

- Scheme Procedure: make-struct-layout fields
     Return a new structure layout object.

     FIELDS must be a string made up of pairs of characters strung
     together.  The first character of each pair describes a field type,
     the second a field protection.  Allowed types are 'p' for
     GC-protected Scheme data, 'u' for unprotected binary data.  Allowed
     protections are 'w' for normal fields or 'h' for hidden fields.

     Hidden fields are writable, but they will not consume an
     initializer arg passed to `make-struct'.  They are useful to add
     slots to a struct in a way that preserves backward-compatibility
     with existing calls to `make-struct', especially for derived
     vtables.

struct?

- Scheme Procedure: struct? x
     Return `#t' iff X is a structure object, else `#f'.

struct-vtable?

- Scheme Procedure: struct-vtable? x
     Return `#t' iff X is a vtable structure.

allocate-struct

- Scheme Procedure: allocate-struct vtable nfields
     Allocate a new structure with space for NFIELDS fields.

     VTABLE must be a vtable structure (see Vtables).

     NFIELDS must be a non-negative integer.  Strictly speaking NFIELDS
     is redundant, as the vtable carries the size for its instances.
     However passing it is useful as a sanity check, given that one
     module can inline a constructor in another.

     Fields will be initialized with their default values.

make-struct/simple

- Scheme Procedure: make-struct/simple vtable .  init
     Create a new structure.

     VTABLE must be a vtable structure (see Vtables).

     The INIT1, ... arguments supply the initial values for the
     structure's fields .  This is a restricted variant of
     `make-struct/no-tail' which applies only if the structure has no
     unboxed fields.  `make-struct/simple' must be called with as many
     INIT values as the struct has fields.  No finalizer is set on the
     instance, even if the vtable has a non-zero finalizer field.  No
     magical vtable fields are inherited.

     The advantage of using `make-struct/simple' is that the compiler
     can inline it, so it is faster.  When in doubt though, use
     `make-struct/no-tail'.

make-struct/no-tail

- Scheme Procedure: make-struct/no-tail vtable .  init
     Create a new structure.

     VTABLE must be a vtable structure (see Vtables).

     The INIT1, ... are optional arguments describing how successive
     fields of the structure should be initialized.  Note that hidden
     fields (those with protection 'h') have to be manually set.

     If fewer optional arguments than initializable fields are supplied,
     fields of type 'p' get default value #f while fields of type 'u'
     are initialized to 0.

make-vtable

- Scheme Procedure: make-vtable fields [printer]
     Create a vtable, for creating structures with the given FIELDS.

     The optional PRINTER argument is a function to be called `(PRINTER
     struct port)' on the structures created.  It should look at STRUCT
     and write to PORT.

struct-ref

- Scheme Procedure: struct-ref handle pos
     Access the POSth field of struct associated with HANDLE.

     If the field is of type 'p', then it can be set to an arbitrary
     value.

     If the field is of type 'u', then it can only be set to a
     non-negative integer value small enough to fit in one machine word.

struct-set!

- Scheme Procedure: struct-set! handle pos val
     Set the slot of the structure HANDLE with index POS to VAL.  Signal
     an error if the slot can not be written to.

struct-ref/unboxed

- Scheme Procedure: struct-ref/unboxed handle pos
     Access the POSth field of struct associated with HANDLE.  The field
     must be of type 'u'.

struct-set!/unboxed

- Scheme Procedure: struct-set!/unboxed handle pos val
     Set the slot of the structure HANDLE with index POS to VAL.  Signal
     an error if the slot can not be written to.

struct-vtable

- Scheme Procedure: struct-vtable handle
     Return the vtable structure that describes the type of struct
     associated with HANDLE.

struct-vtable-name

- Scheme Procedure: struct-vtable-name vtable
     Return the name of the vtable VTABLE.

set-struct-vtable-name!

- Scheme Procedure: set-struct-vtable-name! vtable name
     Set the name of the vtable VTABLE to NAME.

symbol?

- Scheme Procedure: symbol? obj
     Return `#t' if OBJ is a symbol, otherwise return `#f'.

symbol-interned?

- Scheme Procedure: symbol-interned? symbol
     Return `#t' if SYMBOL is interned, otherwise return `#f'.

make-symbol

- Scheme Procedure: make-symbol name
     Return a new uninterned symbol with the name NAME.  The returned
     symbol is guaranteed to be unique and future calls to
     `string->symbol' will not return it.

symbol->string

- Scheme Procedure: symbol->string s
     Return the name of SYMBOL as a string.  The resulting string is
     immutable.

string->symbol

- Scheme Procedure: string->symbol string
     Return the symbol whose name is STRING.

string-ci->symbol

- Scheme Procedure: string-ci->symbol str
     Return the symbol whose name is STR.  STR is converted to lowercase
     before the conversion is done, if Guile is currently reading
     symbols case-insensitively.

gensym

- Scheme Procedure: gensym [prefix]
     Create a new symbol with a name constructed from a prefix and a
     counter value.  The string PREFIX can be specified as an optional
     argument.  Default prefix is `g'.  The counter is increased by 1 at
     each call.  There is no provision for resetting the counter.

symbol-hash

- Scheme Procedure: symbol-hash symbol
     Return a hash value for SYMBOL.

syntax?

- Scheme Procedure: syntax? obj
     Return `#t' if the argument OBJ is a syntax object, else `#f'.

make-syntax

- Scheme Procedure: make-syntax exp wrap module [source]
     Make a new syntax object.

syntax-expression

- Scheme Procedure: syntax-expression obj
     Return the expression contained in the syntax object OBJ.

syntax-wrap

- Scheme Procedure: syntax-wrap obj
     Return the wrap contained in the syntax object OBJ.

syntax-module

- Scheme Procedure: syntax-module obj
     Return the module info contained in the syntax object OBJ.

syntax-source

- Scheme Procedure: syntax-source obj
     Return the source properties for syntax object OBJ, as an alist
     possibly containing the keys `filename', `line', and `column'.
     Return `#f' if no source properties are available.

syntax-sourcev

- Scheme Procedure: syntax-sourcev obj
     Return the source location information for syntax object OBJ, as a
     vector of `#(FILENAME LINE COLUMN)', or `#f' if no source
     properties are available.

%call-with-new-thread

- Scheme Procedure: %call-with-new-thread thunk
yield

- Scheme Procedure: yield
     Move the calling thread to the end of the scheduling queue.

thread?

- Scheme Procedure: thread? obj
     Return `#t' if OBJ is a thread.

make-mutex

- Scheme Procedure: make-mutex [kind]
     Create a new mutex.  If KIND is not given, the mutex will be a
     standard non-recursive mutex.  Otherwise pass `recursive' to make a
     recursive mutex, or `allow-external-unlock' to make a non-recursive
     mutex that can be unlocked from any thread.

make-recursive-mutex

- Scheme Procedure: make-recursive-mutex
     Create a new recursive mutex.

lock-mutex

- Scheme Procedure: lock-mutex mutex [timeout]
     Lock mutex MUTEX.  If the mutex is already locked, the calling
     thread blocks until the mutex becomes available.

unlock-mutex

- Scheme Procedure: unlock-mutex mutex
     Unlocks MUTEX.  The calling thread must already hold the lock on
     MUTEX, unless the mutex was created with the
     `allow-external-unlock' option; otherwise an error will be
     signaled.

mutex?

- Scheme Procedure: mutex? obj
     Return `#t' if OBJ is a mutex.

mutex-owner

- Scheme Procedure: mutex-owner mx
     Return the thread owning MX, or `#f'.

mutex-level

- Scheme Procedure: mutex-level mx
     Return the lock level of mutex MX.

mutex-locked?

- Scheme Procedure: mutex-locked? mx
     Returns `#t' if the mutex MX is locked.

make-condition-variable

- Scheme Procedure: make-condition-variable
     Make a new condition variable.

wait-condition-variable

- Scheme Procedure: wait-condition-variable cond mutex [timeout]
     Wait until condition variable CV has been signaled.  While waiting,
     mutex MX is atomically unlocked (as with `unlock-mutex') and is
     locked again when this function returns.  When T is given, it
     specifies a point in time where the waiting should be aborted.  It
     can be either a integer as returned by `current-time' or a pair as
     returned by `gettimeofday'.  When the waiting is aborted the mutex
     is locked and `#f' is returned.  After the condition variable is
     signaled, the mutex is locked and `#t' is returned.  `#t' may also
     be returned spuriously, so any relevant conditions should be
     re-checked.

signal-condition-variable

- Scheme Procedure: signal-condition-variable cv
     Wake up one thread that is waiting for CV

broadcast-condition-variable

- Scheme Procedure: broadcast-condition-variable cv
     Wake up all threads that are waiting for CV.

condition-variable?

- Scheme Procedure: condition-variable? obj
     Return `#t' if OBJ is a condition variable.

current-thread

- Scheme Procedure: current-thread
     Return the thread that called this function.

all-threads

- Scheme Procedure: all-threads
     Return a list of all threads.

thread-exited?

- Scheme Procedure: thread-exited? thread
     Return `#t' iff THREAD has exited.

total-processor-count

- Scheme Procedure: total-processor-count
     Return the total number of processors of the machine, which is
     guaranteed to be at least 1.  A ``processor'' here is a thread
     execution unit, which can be either:

        * an execution core in a (possibly multi-core) chip, in a
          (possibly multi- chip) module, in a single computer, or

        * a thread execution unit inside a core in the case of
          "hyper-threaded" CPUs.

     Which of the two definitions is used, is unspecified.

current-processor-count

- Scheme Procedure: current-processor-count
     Like `total-processor-count', but return the number of processors
     available to the current process.  See `setaffinity' and
     `getaffinity' for more information.

char->formal-name

- Scheme Procedure: char->formal-name ch
     Return the formal all-upper-case unicode name of CH, as a string.
     If the character has no name, return `#f'.

formal-name->char

- Scheme Procedure: formal-name->char name
     Return the character whose formal all-upper-case unicode name is
     NAME, or `#f' if no such character is known.

values

- Scheme Procedure: values .  args
     Delivers all of its arguments to its continuation.  Except for
     continuations created by the `call-with-values' procedure, all
     continuations take exactly one value.  The effect of passing no
     value or more than one value to continuations that were not created
     by `call-with-values' is unspecified.

make-variable

- Scheme Procedure: make-variable init
     Return a variable initialized to value INIT.

make-undefined-variable

- Scheme Procedure: make-undefined-variable
     Return a variable that is initially unbound.

variable?

- Scheme Procedure: variable? obj
     Return `#t' iff OBJ is a variable object, else return `#f'.

variable-ref

- Scheme Procedure: variable-ref var
     Dereference VAR and return its value.  VAR must be a variable
     object; see `make-variable' and `make-undefined-variable'.

variable-set!

- Scheme Procedure: variable-set! var val
     Set the value of the variable VAR to VAL.  VAR must be a variable
     object, VAL can be any value.  Return an unspecified value.

variable-unset!

- Scheme Procedure: variable-unset! var
     Ensure that VAR is not bound to a value.  VAR must be a variable
     object.

variable-bound?

- Scheme Procedure: variable-bound? var
     Return `#t' iff VAR is bound to a value.  Throws an error if VAR is
     not a variable object.

vector?

- Scheme Procedure: vector? obj
     Return `#t' if OBJ is a vector, otherwise return `#f'.

vector-length

- Scheme Procedure: vector-length v
     Returns the number of elements in VECTOR as an exact integer.

list->vector

- Scheme Procedure: list->vector
     implemented by the C function "scm_vector"

vector

- Scheme Procedure: vector .  l


     Return a newly allocated vector composed of the given arguments.
     Analogous to `list'.

          (vector 'a 'b 'c) ==> #(a b c)

vector-ref

- Scheme Procedure: vector-ref vector k
     K must be a valid index of VECTOR.  `Vector-ref' returns the
     contents of element K of VECTOR.

          (vector-ref '#(1 1 2 3 5 8 13 21) 5) ==> 8
          (vector-ref '#(1 1 2 3 5 8 13 21)
              (let ((i (round (* 2 (acos -1)))))
                (if (inexact? i)
                  (inexact->exact i)
                     i))) ==> 13

vector-set!

- Scheme Procedure: vector-set! vector k obj
     K must be a valid index of VECTOR.  `Vector-set!' stores OBJ in
     element K of VECTOR.  The value returned by `vector-set!' is
     unspecified.

          (let ((vec (vector 0 '(2 2 2 2) "Anna")))
            (vector-set! vec 1 '("Sue" "Sue"))
            vec) ==>  #(0 ("Sue" "Sue") "Anna")
          (vector-set! '#(0 1 2) 1 "doe") ==> _error_ ; constant vector

make-vector

- Scheme Procedure: make-vector k [fill]
     Return a newly allocated vector of K elements.  If a second
     argument is given, then each position is initialized to FILL.
     Otherwise the initial contents of each position is unspecified.

vector-copy

- Scheme Procedure: vector-copy vec [start [end]]
     Returns a freshly allocated vector containing the elements of VEC
     between START and END.

     START defaults to 0 and END defaults to the length of VEC.

vector-copy!

- Scheme Procedure: vector-copy! dst at src [start [end]]
     Copy a block of elements from SRC to DST, both of which must be
     vectors, starting in DST at AT and starting in SRC at START and
     ending at END.

     It is an error for DST to have a length less than AT + (END -
     START).  AT and START default to 0 and END defaults to the length
     of SRC.

     If source and destination overlap, copying takes place as if the
     source is first copied into a temporary vector and then into the
     destination.

vector->list

- Scheme Procedure: vector->list vec
     Return a newly allocated list composed of the elements of VEC.

          (vector->list '#(dah dah didah)) ==>  (dah dah didah)
          (list->vector '(dididit dah)) ==>  #(dididit dah)

vector-fill!

- Scheme Procedure: vector-fill! vec fill [start [end]]
     Assign the value of every location in vector VEC in the range
     [START ... END) to FILL.  START defaults to 0 and END defaults to
     the length of VEC.  The value returned by `vector-fill!' is
     unspecified.

vector-move-left!

- Scheme Procedure: vector-move-left! vec1 start1 end1 vec2 start2
     Copy elements from VEC1, positions START1 to END1, to VEC2 starting
     at position START2.  START1 and START2 are inclusive indices; END1
     is exclusive.

     `vector-move-left!' copies elements in leftmost order.  Therefore,
     in the case where VEC1 and VEC2 refer to the same vector,
     `vector-move-left!' is usually appropriate when START1 is greater
     than START2.

vector-move-right!

- Scheme Procedure: vector-move-right! vec1 start1 end1 vec2 start2
     Copy elements from VEC1, positions START1 to END1, to VEC2 starting
     at position START2.  START1 and START2 are inclusive indices; END1
     is exclusive.

     `vector-move-right!' copies elements in rightmost order.  Therefore,
     in the case where VEC1 and VEC2 refer to the same vector,
     `vector-move-right!' is usually appropriate when START1 is less
     than START2.

major-version

- Scheme Procedure: major-version
     Return a string containing Guile's major version number.  E.g., the
     1 in "1.6.5".

minor-version

- Scheme Procedure: minor-version
     Return a string containing Guile's minor version number.  E.g., the
     6 in "1.6.5".

micro-version

- Scheme Procedure: micro-version
     Return a string containing Guile's micro version number.  E.g., the
     5 in "1.6.5".

version

- Scheme Procedure: version






     Return a string describing Guile's version number, or its major,
     minor or micro version number, respectively.

          (version) ==> "1.6.0"
          (major-version) ==> "1"
          (minor-version) ==> "6"
          (micro-version) ==> "0"

effective-version

- Scheme Procedure: effective-version
     Return a string describing Guile's effective version number.

          (version) ==> "1.6.0"
          (effective-version) ==> "1.6"
          (major-version) ==> "1"
          (minor-version) ==> "6"
          (micro-version) ==> "0"

make-weak-key-hash-table

- Scheme Procedure: make-weak-key-hash-table [n]




     Return a weak hash table with SIZE buckets.

     You can modify weak hash tables in exactly the same way you would
     modify regular hash tables.  (see Hash Tables)

make-weak-value-hash-table

- Scheme Procedure: make-weak-value-hash-table [n]
     Return a hash table with weak values with SIZE buckets.  (see Hash
     Tables)

make-doubly-weak-hash-table

- Scheme Procedure: make-doubly-weak-hash-table [n]
     Return a hash table with weak keys and values with SIZE buckets.
     (see Hash Tables)

weak-key-hash-table?

- Scheme Procedure: weak-key-hash-table? obj




     Return `#t' if OBJ is the specified weak hash table.  Note that a
     doubly weak hash table is neither a weak key nor a weak value hash
     table.

weak-value-hash-table?

- Scheme Procedure: weak-value-hash-table? obj
     Return `#t' if OBJ is a weak value hash table.

doubly-weak-hash-table?

- Scheme Procedure: doubly-weak-hash-table? obj
     Return `#t' if OBJ is a doubly weak hash table.

make-weak-vector

- Scheme Procedure: make-weak-vector size [fill]
     Return a weak vector with SIZE elements.  If the optional argument
     FILL is given, all entries in the vector will be set to FILL.  The
     default value for FILL is the empty list.

list->weak-vector

- Scheme Procedure: list->weak-vector
     implemented by the C function "scm_weak_vector"

weak-vector

- Scheme Procedure: weak-vector .  lst


     Construct a weak vector from a list: `weak-vector' uses the list of
     its arguments while `list->weak-vector' uses its only argument L (a
     list) to construct a weak vector the same way `list->vector' would.

weak-vector?

- Scheme Procedure: weak-vector? obj
     Return `#t' if OBJ is a weak vector.  Note that all weak hashes are
     also weak vectors.

weak-vector-length

- Scheme Procedure: weak-vector-length wvect
     Like `vector-length', but for weak vectors.

weak-vector-ref

- Scheme Procedure: weak-vector-ref wvect k
     Like `vector-ref', but for weak vectors.

weak-vector-set!

- Scheme Procedure: weak-vector-set! wvect k obj
     Like `vector-set!', but for weak vectors.

dlopen

- Scheme Procedure: dlopen name flags
dlclose

- Scheme Procedure: dlclose obj
dlsym

- Scheme Procedure: dlsym obj name
pipe

- Scheme Procedure: pipe [flags]
     Return a newly created pipe: a pair of ports which are linked
     together on the local machine.  The _car_ is the input port and the
     _cdr_ is the output port.  Data written (and flushed) to the output
     port can be read from the input port.  Pipes are commonly used for
     communication with a newly forked child process.  The need to flush
     the output port can be avoided by making it unbuffered using
     `setvbuf'.

     Optionally, on systems that support it such as GNU/Linux and
     GNU/Hurd, FLAGS can specify a bitwise-or of the following
     constants:

     O_CLOEXEC
          Mark the returned file descriptors as close-on-exec;

     O_DIRECT
          Create a pipe that performs input/output in "packet"
          mode---see `man 2 pipe' for details;

     O_NONBLOCK
          Set the `O_NONBLOCK' status flag (non-blocking input and
          output) on the file descriptors.

     On systems that do _not_ support it, passing a non-zero FLAGS value
     triggers a `system-error' exception.

     Writes occur atomically provided the size of the data in bytes is
     not greater than the value of `PIPE_BUF'.  Note that the output
     port is likely to block if too much data (typically equal to
     `PIPE_BUF') has been written but not yet read from the input port.

getgroups

- Scheme Procedure: getgroups
     Return a vector of integers representing the current supplementary
     group IDs.

setgroups

- Scheme Procedure: setgroups group_vec
     Set the current set of supplementary group IDs to the integers in
     the given vector GROUP_VEC.  The return value is unspecified.

     Generally only the superuser can set the process group IDs.

getpw

- Scheme Procedure: getpw [user]
     Look up an entry in the user database.  USER can be an integer, a
     string, or omitted, giving the behavior of `getpwuid', `getpwnam'
     or `getpwent' respectively.

setpw

- Scheme Procedure: setpw [arg]
     If called with a true argument, initialize or reset the password
     data stream.  Otherwise, close the stream.  The `setpwent' and
     `endpwent' procedures are implemented on top of this.

getgr

- Scheme Procedure: getgr [name]
     Look up an entry in the group database.  NAME can be an integer, a
     string, or omitted, giving the behavior of `getgrgid', `getgrnam'
     or `getgrent' respectively.

setgr

- Scheme Procedure: setgr [arg]
     If called with a true argument, initialize or reset the group data
     stream.  Otherwise, close the stream.  The `setgrent' and
     `endgrent' procedures are implemented on top of this.

getrlimit

- Scheme Procedure: getrlimit resource
     Get a resource limit for this process.  RESOURCE identifies the
     resource, either as an integer or as a symbol.  For example,
     `(getrlimit 'stack)' gets the limits associated with
     `RLIMIT_STACK'.

     `getrlimit' returns two values, the soft and the hard limit.  If no
     limit is set for the resource in question, the returned limit will
     be `#f'.

setrlimit

- Scheme Procedure: setrlimit resource soft hard
     Set a resource limit for this process.  RESOURCE identifies the
     resource, either as an integer or as a symbol.  SOFT and HARD
     should be integers, or `#f' to indicate no limit (i.e.,
     `RLIM_INFINITY').

     For example, `(setrlimit 'stack 150000 300000)' sets the
     `RLIMIT_STACK' limit to 150 kilobytes, with a hard limit of 300 kB.

kill

- Scheme Procedure: kill pid sig
     Sends a signal to the specified process or group of processes.

     PID specifies the processes to which the signal is sent:

     PID greater than 0
          The process whose identifier is PID.

     PID equal to 0
          All processes in the current process group.

     PID less than -1
          The process group whose identifier is -PID

     PID equal to -1
          If the process is privileged, all processes except for some
          special system processes.  Otherwise, all processes with the
          current effective user ID.

     SIG should be specified using a variable corresponding to the Unix
     symbolic name, e.g.,

     - Variable: SIGHUP
          Hang-up signal.

     - Variable: SIGINT
          Interrupt signal.

waitpid

- Scheme Procedure: waitpid pid [options]
     This procedure collects status information from a child process
     which has terminated or (optionally) stopped.  Normally it will
     suspend the calling process until this can be done.  If more than
     one child process is eligible then one will be chosen by the
     operating system.

     The value of PID determines the behavior:

     PID greater than 0
          Request status information from the specified child process.

     PID equal to -1 or WAIT_ANY
          Request status information for any child process.

     PID equal to 0 or WAIT_MYPGRP
          Request status information for any child process in the
          current process group.

     PID less than -1
          Request status information for any child process whose process
          group ID is -PID.

     The OPTIONS argument, if supplied, should be the bitwise OR of the
     values of zero or more of the following variables:

     - Variable: WNOHANG
          Return immediately even if there are no child processes to be
          collected.

     - Variable: WUNTRACED
          Report status information for stopped processes as well as
          terminated processes.

     The return value is a pair containing:

       1. The process ID of the child process, or 0 if `WNOHANG' was
          specified and no process was collected.

       2. The integer status value.

status:exit-val

- Scheme Procedure: status:exit-val status
     Return the exit status value, as would be set if a process ended
     normally through a call to `exit' or `_exit', if any, otherwise
     `#f'.

status:term-sig

- Scheme Procedure: status:term-sig status
     Return the signal number which terminated the process, if any,
     otherwise `#f'.

status:stop-sig

- Scheme Procedure: status:stop-sig status
     Return the signal number which stopped the process, if any,
     otherwise `#f'.

getppid

- Scheme Procedure: getppid
     Return an integer representing the process ID of the parent
     process.

getuid

- Scheme Procedure: getuid
     Return an integer representing the current real user ID.

getgid

- Scheme Procedure: getgid
     Return an integer representing the current real group ID.

geteuid

- Scheme Procedure: geteuid
     Return an integer representing the current effective user ID.  If
     the system does not support effective IDs, then the real ID is
     returned.  `(provided? 'EIDs)' reports whether the system supports
     effective IDs.

getegid

- Scheme Procedure: getegid
     Return an integer representing the current effective group ID.  If
     the system does not support effective IDs, then the real ID is
     returned.  `(provided? 'EIDs)' reports whether the system supports
     effective IDs.

setuid

- Scheme Procedure: setuid id
     Sets both the real and effective user IDs to the integer ID,
     provided the process has appropriate privileges.  The return value
     is unspecified.

setgid

- Scheme Procedure: setgid id
     Sets both the real and effective group IDs to the integer ID,
     provided the process has appropriate privileges.  The return value
     is unspecified.

seteuid

- Scheme Procedure: seteuid id
     Sets the effective user ID to the integer ID, provided the process
     has appropriate privileges.  If effective IDs are not supported,
     the real ID is set instead -- `(provided? 'EIDs)' reports whether
     the system supports effective IDs.  The return value is
     unspecified.

setegid

- Scheme Procedure: setegid id
     Sets the effective group ID to the integer ID, provided the process
     has appropriate privileges.  If effective IDs are not supported,
     the real ID is set instead -- `(provided? 'EIDs)' reports whether
     the system supports effective IDs.  The return value is
     unspecified.

getpgrp

- Scheme Procedure: getpgrp
     Return an integer representing the current process group ID.  This
     is the POSIX definition, not BSD.

setpgid

- Scheme Procedure: setpgid pid pgid
     Move the process PID into the process group PGID.  PID or PGID must
     be integers: they can be zero to indicate the ID of the current
     process.  Fails on systems that do not support job control.  The
     return value is unspecified.

setsid

- Scheme Procedure: setsid
     Creates a new session.  The current process becomes the session
     leader and is put in a new process group.  The process will be
     detached from its controlling terminal if it has one.  The return
     value is an integer representing the new process group ID.

getsid

- Scheme Procedure: getsid pid
     Returns the session ID of process PID.  (The session ID of a
     process is the process group ID of its session leader.)

ttyname

- Scheme Procedure: ttyname port
     Return a string with the name of the serial terminal device
     underlying PORT.

ctermid

- Scheme Procedure: ctermid
     Return a string containing the file name of the controlling
     terminal for the current process.

tcgetpgrp

- Scheme Procedure: tcgetpgrp port
     Return the process group ID of the foreground process group
     associated with the terminal open on the file descriptor underlying
     PORT.

     If there is no foreground process group, the return value is a
     number greater than 1 that does not match the process group ID of
     any existing process group.  This can happen if all of the
     processes in the job that was formerly the foreground job have
     terminated, and no other job has yet been moved into the
     foreground.

tcsetpgrp

- Scheme Procedure: tcsetpgrp port pgid
     Set the foreground process group ID for the terminal used by the
     file descriptor underlying PORT to the integer PGID.  The calling
     process must be a member of the same session as PGID and must have
     the same controlling terminal.  The return value is unspecified.

execl

- Scheme Procedure: execl filename .  args
     Executes the file named by FILENAME as a new process image.  The
     remaining arguments are supplied to the process; from a C program
     they are accessible as the `argv' argument to `main'.
     Conventionally the first ARG is the same as FILENAME.  All
     arguments must be strings.

     If ARG is missing, PATH is executed with a null argument list,
     which may have system-dependent side-effects.

     This procedure is currently implemented using the `execv' system
     call, but we call it `execl' because of its Scheme calling
     interface.

execlp

- Scheme Procedure: execlp filename .  args
     Similar to `execl', however if FILENAME does not contain a slash
     then the file to execute will be located by searching the
     directories listed in the `PATH' environment variable.

     This procedure is currently implemented using the `execvp' system
     call, but we call it `execlp' because of its Scheme calling
     interface.

execle

- Scheme Procedure: execle filename env .  args
     Similar to `execl', but the environment of the new process is
     specified by ENV, which must be a list of strings as returned by
     the `environ' procedure.

     This procedure is currently implemented using the `execve' system
     call, but we call it `execle' because of its Scheme calling
     interface.

primitive-fork

- Scheme Procedure: primitive-fork
     Creates a new "child" process by duplicating the current "parent"
     process.  In the child the return value is 0.  In the parent the
     return value is the integer process ID of the child.

     This procedure has been renamed from `fork' to avoid a naming
     conflict with the scsh fork.

spawn

- Scheme Procedure: spawn program arguments .  keyword_args
     Spawn a new child process executing PROGRAM with the given
     ARGUMENTS, a list of one or more strings (by convention, the first
     argument is typically PROGRAM), and return its PID.  Raise a
     `system-error' exception if PROGRAM could not be found or could not
     be executed.

     If the keyword argument `#:search-path?' is true, it selects
     whether the `PATH' environment variable should be inspected to find
     PROGRAM.  It is true by default.

     The `#:environment' keyword parameter specifies the list of
     environment variables of the child process.  It defaults to
     `(environ)'.

     The keyword arguments `#:input', `#:output', and `#:error' specify
     the port or file descriptor for the child process to use as
     standard input, standard output, and standard error.  No other file
     descriptors are inherited from the parent process.

system*

- Scheme Procedure: system* .  args
     Execute the command indicated by ARGS.  The first element must be a
     string indicating the command to be executed, and the remaining
     items must be strings representing each of the arguments to that
     command.

     This function returns the exit status of the command as provided by
     `waitpid'.  This value can be handled with `status:exit-val' and
     the related functions.

     `system*' is similar to `system', but accepts only one string
     per-argument, and performs no shell interpretation.  The command is
     executed using fork and execlp.  Accordingly this function may be
     safer than `system' in situations where shell interpretation is not
     required.

     Example: (system* "echo" "foo" "bar")

uname

- Scheme Procedure: uname
     Return an object with some information about the computer system
     the program is running on.

environ

- Scheme Procedure: environ [env]
     If ENV is omitted, return the current environment (in the Unix
     sense) as a list of strings.  Otherwise set the current
     environment, which is also the default environment for child
     processes, to the supplied list of strings.  Each member of ENV
     should be of the form `NAME=VALUE' and values of `NAME' should not
     be duplicated.  If ENV is supplied then the return value is
     unspecified.

tmpnam

- Scheme Procedure: tmpnam
     Return a name in the file system that does not match any existing
     file.  However there is no guarantee that another process will not
     create the file after `tmpnam' is called.  Care should be taken if
     opening the file, e.g., use the `O_EXCL' open flag or use `mkstemp'
     instead.

tmpfile

- Scheme Procedure: tmpfile
     Return an input/output port to a unique temporary file named using
     the path prefix `P_tmpdir' defined in `stdio.h'.  The file is
     automatically deleted when the port is closed or the program
     terminates.

utime

- Scheme Procedure: utime object [actime [modtime [actimens [modtimens
[flags]]]]]
     `utime' sets the access and modification times for the file named
     by OBJECT.  If ACTIME or MODTIME is not supplied, then the current
     time is used.  ACTIME and MODTIME must be integer time values as
     returned by the `current-time' procedure.

     OBJECT must be a file name or a port (if supported by the system).

     The optional ACTIMENS and MODTIMENS are nanoseconds to add ACTIME
     and MODTIME.  Nanosecond precision is only supported on some
     combinations of file systems and operating systems.

          (utime "foo" (- (current-time) 3600))

     will set the access time to one hour in the past and the
     modification time to the current time.

     Last, FLAGS may be either `0' or the `AT_SYMLINK_NOFOLLOW'
     constant, to set the time of PATHNAME even if it is a symbolic
     link.

     On GNU/Linux systems, at least when using the Linux kernel 5.10.46,
     if OBJECT is a port, it may not be a symbolic link, even if
     `AT_SYMLINK_NOFOLLOW' is set.  This is either a bug in Linux or
     Guile's wrappers.  The exact cause is unclear.

getpid

- Scheme Procedure: getpid
     Return an integer representing the current process ID.

putenv

- Scheme Procedure: putenv str
     Modifies the environment of the current process, which is also the
     default environment inherited by child processes.  If STR is of the
     form `NAME=VALUE' then it will be written directly into the
     environment, replacing any existing environment string with name
     matching `NAME'.  If STR does not contain an equal sign, then any
     existing string with name matching STR will be removed.

     The return value is unspecified.

setlocale

- Scheme Procedure: setlocale category [locale]
     If LOCALE is omitted, return the current value of the specified
     locale category as a system-dependent string.  CATEGORY should be
     specified using the values `LC_COLLATE', `LC_ALL' etc.

     Otherwise the specified locale category is set to the string LOCALE
     and the new value is returned as a system-dependent string.  If
     LOCALE is an empty string, the locale will be set using environment
     variables.

     When the locale is changed, the character encoding of the new
     locale (UTF-8, ISO-8859-1, etc.) is used for the current input,
     output, and error ports

mknod

- Scheme Procedure: mknod path type perms dev
     Creates a new special file, such as a file corresponding to a
     device.  PATH specifies the name of the file.  TYPE should be one
     of the following symbols: regular, directory, symlink,
     block-special, char-special, fifo, or socket.  PERMS (an integer)
     specifies the file permissions.  DEV (an integer) specifies which
     device the special file refers to.  Its exact interpretation
     depends on the kind of special file being created.

     E.g.,

          (mknod "/dev/fd0" 'block-special #o660 (+ (* 2 256) 2))

     The return value is unspecified.

nice

- Scheme Procedure: nice incr
     Increment the priority of the current process by INCR.  A higher
     priority value means that the process runs less often.  The return
     value is unspecified.

sync

- Scheme Procedure: sync
     Flush the operating system disk buffers.  The return value is
     unspecified.

crypt

- Scheme Procedure: crypt key salt
     Encrypt KEY using SALT as the salt value to the crypt(3) library
     call.

chroot

- Scheme Procedure: chroot path
     Change the root directory to that specified in PATH.  This
     directory will be used for path names beginning with `/'.  The root
     directory is inherited by all children of the current process.  Only
     the superuser may change the root directory.

getlogin

- Scheme Procedure: getlogin
     Return a string containing the name of the user logged in on the
     controlling terminal of the process, or `#f' if this information
     cannot be obtained.

getpriority

- Scheme Procedure: getpriority which who
     Return the scheduling priority of the process, process group or
     user, as indicated by WHICH and WHO.  WHICH is one of the variables
     `PRIO_PROCESS', `PRIO_PGRP' or `PRIO_USER', and WHO is interpreted
     relative to WHICH (a process identifier for `PRIO_PROCESS', process
     group identifier for `PRIO_PGRP', and a user identifier for
     `PRIO_USER'.  A zero value of WHO denotes the current process,
     process group, or user.  Return the highest priority (lowest
     numerical value) of any of the specified processes.

setpriority

- Scheme Procedure: setpriority which who prio
     Set the scheduling priority of the process, process group or user,
     as indicated by WHICH and WHO.  WHICH is one of the variables
     `PRIO_PROCESS', `PRIO_PGRP' or `PRIO_USER', and WHO is interpreted
     relative to WHICH (a process identifier for `PRIO_PROCESS', process
     group identifier for `PRIO_PGRP', and a user identifier for
     `PRIO_USER'.  A zero value of WHO denotes the current process,
     process group, or user.  PRIO is a value in the range -20 and 20,
     the default priority is 0; lower priorities cause more favorable
     scheduling.  Sets the priority of all of the specified processes.
     Only the super-user may lower priorities.  The return value is not
     specified.

getaffinity

- Scheme Procedure: getaffinity pid
     Return a bitvector representing the CPU affinity mask for process
     PID.  Each CPU the process has affinity with has its corresponding
     bit set in the returned bitvector.  The number of bits set is a
     good estimate of how many CPUs Guile can use without stepping on
     other processes' toes.

setaffinity

- Scheme Procedure: setaffinity pid mask
     Install the CPU affinity mask MASK, a bitvector, for the process or
     thread with ID PID.  The return value is unspecified.

getpass

- Scheme Procedure: getpass prompt
     Display PROMPT to the standard error output and read a password
     from `/dev/tty'.  If this file is not accessible, it reads from
     standard input.  The password may be up to 127 characters in
     length.  Additional characters and the terminating newline
     character are discarded.  While reading the password, echoing and
     the generation of signals by special characters is disabled.

flock

- Scheme Procedure: flock file operation
     Apply or remove an advisory lock on an open file.  OPERATION
     specifies the action to be done:

     - Variable: LOCK_SH
          Shared lock.  More than one process may hold a shared lock for
          a given file at a given time.

     - Variable: LOCK_EX
          Exclusive lock.  Only one process may hold an exclusive lock
          for a given file at a given time.

     - Variable: LOCK_UN
          Unlock the file.

     - Variable: LOCK_NB
          Don't block when locking.  This is combined with one of the
          other operations using `logior'.  If `flock' would block an
          `EWOULDBLOCK' error is thrown.

     The return value is not specified.  FILE may be an open file
     descriptor or an open file descriptor port.

     Note that `flock' does not lock files across NFS.

sethostname

- Scheme Procedure: sethostname name
     Set the host name of the current processor to NAME.  May only be
     used by the superuser.  The return value is not specified.

gethostname

- Scheme Procedure: gethostname
     Return the host name of the current processor.

gethost

- Scheme Procedure: gethost [host]




     Look up a host by name or address, returning a host object.  The
     `gethost' procedure will accept either a string name or an integer
     address; if given no arguments, it behaves like `gethostent' (see
     below).  If a name or address is supplied but the address can not
     be found, an error will be thrown to one of the keys:
     `host-not-found', `try-again', `no-recovery' or `no-data',
     corresponding to the equivalent `h_error' values.  Unusual
     conditions may result in errors thrown to the `system-error' or
     `misc_error' keys.

getproto

- Scheme Procedure: getproto [protocol]




     Look up a network protocol by name or by number.  `getprotobyname'
     takes a string argument, and `getprotobynumber' takes an integer
     argument.  `getproto' will accept either type, behaving like
     `getprotoent' (see below) if no arguments are supplied.

getserv

- Scheme Procedure: getserv [name [protocol]]




     Look up a network service by name or by service number, and return
     a network service object.  The PROTOCOL argument specifies the name
     of the desired protocol; if the protocol found in the network
     service database does not match this name, a system error is
     signaled.

     The `getserv' procedure will take either a service name or number
     as its first argument; if given no arguments, it behaves like
     `getservent' (see below).

sethost

- Scheme Procedure: sethost [stayopen]
     If STAYOPEN is omitted, this is equivalent to `endhostent'.
     Otherwise it is equivalent to `sethostent stayopen'.

setproto

- Scheme Procedure: setproto [stayopen]
     If STAYOPEN is omitted, this is equivalent to `endprotoent'.
     Otherwise it is equivalent to `setprotoent stayopen'.

setserv

- Scheme Procedure: setserv [stayopen]
     If STAYOPEN is omitted, this is equivalent to `endservent'.
     Otherwise it is equivalent to `setservent stayopen'.

getaddrinfo

- Scheme Procedure: getaddrinfo name [service [hint_flags [hint_family
[hint_socktype [hint_protocol]]]]]
     Return a list of `addrinfo' structures containing a socket address
     and associated information for host NAME and/or SERVICE to be used
     in creating a socket with which to address the specified service.

          (let* ((ai (car (getaddrinfo "www.gnu.org" "http")))
                 (s  (socket (addrinfo:fam ai) (addrinfo:socktype ai)
                             (addrinfo:protocol ai))))
            (connect s (addrinfo:addr ai))
            s)

     When SERVICE is omitted or is `#f', return network-level addresses
     for NAME.  When NAME is `#f' SERVICE must be provided and service
     locations local to the caller are returned.

     Additional hints can be provided.  When specified, HINT_FLAGS
     should be a bitwise-or of zero or more constants among the
     following:

     AI_PASSIVE
          Socket address is intended for `bind'.

     AI_CANONNAME
          Request for canonical host name, available via
          `addrinfo:canonname'.  This makes sense mainly when DNS
          lookups are involved.

     AI_NUMERICHOST
          Specifies that NAME is a numeric host address string (e.g.,
          `"127.0.0.1"'), meaning that name resolution will not be used.

     AI_NUMERICSERV
          Likewise, specifies that SERVICE is a numeric port string
          (e.g., `"80"').

     AI_ADDRCONFIG
          Return only addresses configured on the local system.  It is
          highly recommended to provide this flag when the returned
          socket addresses are to be used to make connections;
          otherwise, some of the returned addresses could be unreachable
          or use a protocol that is not supported.

     AI_V4MAPPED
          When looking up IPv6 addresses, return mapped IPv4 addresses
          if there is no IPv6 address available at all.

     AI_ALL
          If this flag is set along with `AI_V4MAPPED' when looking up
          IPv6 addresses, return all IPv6 addresses as well as all IPv4
          addresses, the latter mapped to IPv6 format.

     When given, HINT_FAMILY should specify the requested address
     family, e.g., `AF_INET6'.  Similarly, HINT_SOCKTYPE should specify
     the requested socket type (e.g., `SOCK_DGRAM'), and HINT_PROTOCOL
     should specify the requested protocol (its value is interpretered
     as in calls to `socket').

     On error, an exception with key `getaddrinfo-error' is thrown, with
     an error code (an integer) as its argument:

          (catch 'getaddrinfo-error
            (lambda ()
              (getaddrinfo "www.gnu.org" "gopher"))
            (lambda (key errcode)
              (cond ((= errcode EAI_SERVICE)
                     (display "doesn't know about Gopher!\n"))
                    ((= errcode EAI_NONAME)
                     (display "www.gnu.org not found\n"))
                    (else
                     (format #t "something wrong: ~a\n"
                             (gai-strerror errcode))))))

     Error codes are:

     EAI_AGAIN
          The name or service could not be resolved at this time.  Future
          attempts may succeed.

     EAI_BADFLAGS
          HINT_FLAGS contains an invalid value.

     EAI_FAIL
          A non-recoverable error occurred when attempting to resolve
          the name.

     EAI_FAMILY
          HINT_FAMILY was not recognized.

     EAI_NONAME
          Either NAME does not resolve for the supplied parameters, or
          neither NAME nor SERVICE were supplied.

     EAI_NODATA
          This non-POSIX error code can be returned on some systems (GNU
          and Darwin, at least), for example when NAME is known but
          requests that were made turned out no data.  Error handling
          code should be prepared to handle it when it is defined.

     EAI_SERVICE
          SERVICE was not recognized for the specified socket type.

     EAI_SOCKTYPE
          HINT_SOCKTYPE was not recognized.

     EAI_SYSTEM
          A system error occurred.  In C, the error code can be found in
          `errno'; this value is not accessible from Scheme, but in
          practice it provides little information about the actual error
          cause.

     Users are encouraged to read the POSIX specification
     (http://www.opengroup.org/onlinepubs/9699919799/functions/getaddrin
     fo.html) for more details.

gai-strerror

- Scheme Procedure: gai-strerror error
     Return a string describing ERROR, an integer error code returned by
     `getaddrinfo'.

inet-netof

- Scheme Procedure: inet-netof address
     Return the network number part of the given IPv4 Internet address.
     E.g.,

          (inet-netof 2130706433) ==> 127

inet-makeaddr

- Scheme Procedure: inet-makeaddr net lna
     Make an IPv4 Internet address by combining the network number NET
     with the local-address-within-network number LNA.  E.g.,

          (inet-makeaddr 127 1) ==> 2130706433

inet-ntop

- Scheme Procedure: inet-ntop family address
     Convert a network address into a printable string.  Note that
     unlike the C version of this function, the input is an integer with
     normal host byte ordering.  FAMILY can be `AF_INET' or `AF_INET6'.
     E.g.,

          (inet-ntop AF_INET 2130706433) ==> "127.0.0.1"
          (inet-ntop AF_INET6 (- (expt 2 128) 1))
            ==> "ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff"

inet-pton

- Scheme Procedure: inet-pton family address
     Convert a string containing a printable network address to an
     integer address.  Note that unlike the C version of this function,
     the result is an integer with normal host byte ordering.  FAMILY
     can be `AF_INET' or `AF_INET6'.  E.g.,

          (inet-pton AF_INET "127.0.0.1") ==> 2130706433
          (inet-pton AF_INET6 "::1") ==> 1

socket

- Scheme Procedure: socket family style proto
     Return a new socket port of the type specified by FAMILY, STYLE and
     PROTO.  All three parameters are integers.  Supported values for
     FAMILY are `AF_UNIX', `AF_INET' and `AF_INET6'.  Typical values for
     STYLE are `SOCK_STREAM', `SOCK_DGRAM' and `SOCK_RAW'.

     PROTO can be obtained from a protocol name using `getprotobyname'.
     A value of zero specifies the default protocol, which is usually
     right.

     A single socket port cannot be used for communication until it has
     been connected to another socket.

socketpair

- Scheme Procedure: socketpair family style proto
     Return a pair of connected (but unnamed) socket ports of the type
     specified by FAMILY, STYLE and PROTO.  Many systems support only
     socket pairs of the `AF_UNIX' family.  Zero is likely to be the
     only meaningful value for PROTO.

getsockopt

- Scheme Procedure: getsockopt sock level optname
     Return an option value from socket port SOCK.

     LEVEL is an integer specifying a protocol layer, either
     `SOL_SOCKET' for socket level options, or a protocol number from
     the `IPPROTO' constants or `getprotoent' (see Network Databases).

     - Variable: SOL_SOCKET






     OPTNAME is an integer specifying an option within the protocol
     layer.

     For `SOL_SOCKET' level the following OPTNAMEs are defined (when
     provided by the system).  For their meaning see Socket-Level
     Options in manual The GNU C Library Reference Manual, or `man 7
     socket'.

     - Variable: SO_DEBUG


























          The value returned is an integer.

     - Variable: SO_LINGER
          The value returned is a pair of integers `(ENABLE .  TIMEOUT)'.
          On old systems without timeout support (ie.: without `struct
          linger'), only ENABLE has an effect but the value in Guile is
          always a pair.

     - Variable: SO_RCVTIMEO


          VALUE is a pair of integers `(SECONDS .  MICROSECONDS)'.

setsockopt

- Scheme Procedure: setsockopt sock level optname value
     Set an option on socket port SOCK.  The return value is
     unspecified.

     LEVEL is an integer specifying a protocol layer, either
     `SOL_SOCKET' for socket level options, or a protocol number from
     the `IPPROTO' constants or `getprotoent' (see Network Databases).

     - Variable: SOL_SOCKET






     OPTNAME is an integer specifying an option within the protocol
     layer.

     For `SOL_SOCKET' level the following OPTNAMEs are defined (when
     provided by the system).  For their meaning see Socket-Level
     Options in manual The GNU C Library Reference Manual, or `man 7
     socket'.

     - Variable: SO_DEBUG


























          VALUE is an integer.

     - Variable: SO_LINGER
          VALUE is a pair of integers `(ENABLE .  TIMEOUT)'.  On old
          systems without timeout support (ie.: without `struct
          linger'), only ENABLE has an effect but the value in Guile is
          always a pair.

     - Variable: SO_RCVTIMEO


          VALUE is a pair of integers `(SECONDS .  MICROSECONDS)'.

     For IP level (`IPPROTO_IP') the following OPTNAMEs are defined
     (when provided by the system).  See `man ip' for what they mean.

     - Variable: IP_MULTICAST_IF
          This sets the source interface used by multicast traffic.

     - Variable: IP_MULTICAST_TTL
          This sets the default TTL for multicast traffic.  This
          defaults to 1 and should be increased to allow traffic to pass
          beyond the local network.

     - Variable: IP_ADD_MEMBERSHIP


          These can be used only with `setsockopt', not `getsockopt'.
          VALUE is a pair `(MULTIADDR .  INTERFACEADDR)' of IPv4
          addresses (see Network Address Conversion).  MULTIADDR is a
          multicast address to be added to or dropped from the interface
          INTERFACEADDR.  INTERFACEADDR can be `INADDR_ANY' to have the
          system select the interface.  INTERFACEADDR can also be an
          interface index number, on systems supporting that.

shutdown

- Scheme Procedure: shutdown sock how
     Sockets can be closed simply by using `close-port'.  The `shutdown'
     procedure allows reception or transmission on a connection to be
     shut down individually, according to the parameter HOW:

     0
          Stop receiving data for this socket.  If further data arrives,
          reject it.

     1
          Stop trying to transmit data from this socket.  Discard any
          data waiting to be sent.  Stop looking for acknowledgement of
          data already sent; don't retransmit it if it is lost.

     2
          Stop both reception and transmission.

     The return value is unspecified.

connect

- Scheme Procedure: connect sock fam_or_sockaddr [address .  args]
     Initiate a connection from a socket using a specified address
     family to the address specified by ADDRESS and possibly ARGS.  The
     format required for ADDRESS and ARGS depends on the family of the
     socket.

     For a socket of family `AF_UNIX', only ADDRESS is specified and
     must be a string with the filename where the socket is to be
     created.

     For a socket of family `AF_INET', ADDRESS must be an integer IPv4
     host address and ARGS must be a single integer port number.

     For a socket of family `AF_INET6', ADDRESS must be an integer IPv6
     host address and ARGS may be up to three integers: port [flowinfo]
     [scope_id], where flowinfo and scope_id default to zero.

     Alternatively, the second argument can be a socket address object
     as returned by `make-socket-address', in which case the no
     additional arguments should be passed.

     Return true, unless the socket was configured to be non-blocking
     and the operation has not finished yet.

bind

- Scheme Procedure: bind sock fam_or_sockaddr [address .  args]
     Assign an address to the socket port SOCK.  Generally this only
     needs to be done for server sockets, so they know where to look for
     incoming connections.  A socket without an address will be assigned
     one automatically when it starts communicating.

     The format of ADDRESS and ARGS depends on the family of the socket.

     For a socket of family `AF_UNIX', only ADDRESS is specified and
     must be a string with the filename where the socket is to be
     created.

     For a socket of family `AF_INET', ADDRESS must be an integer IPv4
     address and ARGS must be a single integer port number.

     The values of the following variables can also be used for ADDRESS:

     - Variable: INADDR_ANY
          Allow connections from any address.

     - Variable: INADDR_LOOPBACK
          The address of the local host using the loopback device.

     - Variable: INADDR_BROADCAST
          The broadcast address on the local network.

     - Variable: INADDR_NONE
          No address.

     For a socket of family `AF_INET6', ADDRESS must be an integer IPv6
     address and ARGS may be up to three integers: port [flowinfo]
     [scope_id], where flowinfo and scope_id default to zero.

     Alternatively, the second argument can be a socket address object
     as returned by `make-socket-address', in which case the no
     additional arguments should be passed.

     The return value is unspecified.

listen

- Scheme Procedure: listen sock backlog
     Enable SOCK to accept connection requests.  BACKLOG is an integer
     specifying the maximum length of the queue for pending connections.
     If the queue fills, new clients will fail to connect until the
     server calls `accept' to accept a connection from the queue.

     The return value is unspecified.

make-socket-address

- Scheme Procedure: make-socket-address family address .  args
     Return a Scheme address object that reflects ADDRESS, being an
     address of family FAMILY, with the family-specific parameters ARGS
     (see the description of `connect' for details).

accept

- Scheme Procedure: accept sock [flags]
     Accept a connection on a bound, listening socket.  If there are no
     pending connections in the queue, there are two possibilities: if
     the socket has been configured as non-blocking, return `#f'
     directly.  Otherwise wait until a connection is available.  When a
     connection comes, the return value is a pair in which the _car_ is
     a new socket port for the connection and the _cdr_ is an object
     with address information about the client which initiated the
     connection.

     SOCK does not become part of the connection and will continue to
     accept new requests.

getsockname

- Scheme Procedure: getsockname sock
     Return the address of SOCK, in the same form as the object returned
     by `accept'.  On many systems the address of a socket in the
     `AF_FILE' namespace cannot be read.

getpeername

- Scheme Procedure: getpeername sock
     Return the address that SOCK is connected to, in the same form as
     the object returned by `accept'.  On many systems the address of a
     socket in the `AF_FILE' namespace cannot be read.

recv!

- Scheme Procedure: recv! sock buf [flags]
     Receive data from a socket port.  SOCK must already be bound to the
     address from which data is to be received.  BUF is a bytevector
     into which the data will be written.  The size of BUF limits the
     amount of data which can be received: in the case of packet
     protocols, if a packet larger than this limit is encountered then
     some data will be irrevocably lost.

     The optional FLAGS argument is a value or bitwise OR of MSG_OOB,
     MSG_PEEK, MSG_DONTROUTE etc.

     The value returned is the number of bytes read from the socket.

     Note that the data is read directly from the socket file
     descriptor: any unread buffered port data is ignored.

send

- Scheme Procedure: send sock message [flags]
     Transmit bytevector MESSAGE on socket port SOCK.  SOCK must already
     be bound to a destination address.  The value returned is the
     number of bytes transmitted -- it's possible for this to be less
     than the length of MESSAGE if the socket is set to be non-blocking.
     The optional FLAGS argument is a value or bitwise OR of MSG_OOB,
     MSG_PEEK, MSG_DONTROUTE etc.

     Note that the data is written directly to the socket file
     descriptor: any unflushed buffered port data is ignored.

     This operation is defined only for strings containing codepoints
     zero to 255.

recvfrom!

- Scheme Procedure: recvfrom! sock buf [flags [start [end]]]
     Receive data from socket port SOCK (which must be already bound),
     returning the originating address as well as the data.  This is
     usually for use on datagram sockets, but can be used on
     stream-oriented sockets too.

     The data received is stored in bytevector BUF, using either the
     whole bytevector or just the region between the optional START and
     END positions.  The size of BUF limits the amount of data that can
     be received.  For datagram protocols, if a packet larger than this
     is received then excess bytes are irrevocably lost.

     The return value is a pair.  The `car' is the number of bytes read.
     The `cdr' is a socket address object which is where the data came
     from, or `#f' if the origin is unknown.

     The optional FLAGS argument is a or bitwise OR (`logior') of
     `MSG_OOB', `MSG_PEEK', `MSG_DONTROUTE' etc.

     Data is read directly from the socket file descriptor, any buffered
     port data is ignored.

     On a GNU/Linux system `recvfrom!' is not multi-threading, all
     threads stop while a `recvfrom!' call is in progress.  An
     application may need to use `select', `O_NONBLOCK' or
     `MSG_DONTWAIT' to avoid this.

sendto

- Scheme Procedure: sendto sock message fam_or_sockaddr [address .
args_and_flags]
     Transmit bytevector MESSAGE on socket port SOCK.  The destination
     address is specified using the FAM_OR_SOCKADDR, ADDRESS and
     ARGS_AND_FLAGS arguments, or just a socket address object returned
     by `make-socket-address', in a similar way to the `connect'
     procedure.  ARGS_AND_FLAGS contains the usual connection arguments
     optionally followed by a flags argument, which is a value or
     bitwise OR of MSG_OOB, MSG_PEEK, MSG_DONTROUTE etc.

     The value returned is the number of bytes transmitted -- it's
     possible for this to be less than the length of MESSAGE if the
     socket is set to be non-blocking.  Note that the data is written
     directly to the socket file descriptor: any unflushed buffered port
     data is ignored.  This operation is defined only for strings
     containing codepoints zero to 255.

regexp?

- Scheme Procedure: regexp? obj
     Return `#t' if OBJ is a compiled regular expression, or `#f'
     otherwise.

make-regexp

- Scheme Procedure: make-regexp pat .  flags
     Compile the regular expression described by PAT, and return the
     compiled regexp structure.  If PAT does not describe a legal
     regular expression, `make-regexp' throws a
     `regular-expression-syntax' error.

     The FLAGS arguments change the behavior of the compiled regular
     expression.  The following flags may be supplied:

     regexp/icase
          Consider uppercase and lowercase letters to be the same when
          matching.

     regexp/newline
          If a newline appears in the target string, then permit the `^'
          and `$' operators to match immediately after or immediately
          before the newline, respectively.  Also, the `.' and `[^...]'
          operators will never match a newline character.  The intent of
          this flag is to treat the target string as a buffer containing
          many lines of text, and the regular expression as a pattern
          that may match a single one of those lines.

     regexp/basic
          Compile a basic (``obsolete'') regexp instead of the extended
          (``modern'') regexps that are the default.  Basic regexps do
          not consider `|', `+' or `?' to be special characters, and
          require the `{...}' and `(...)' metacharacters to be
          backslash-escaped (see Backslash Escapes).  There are several
          other differences between basic and extended regular
          expressions, but these are the most significant.

     regexp/extended
          Compile an extended regular expression rather than a basic
          regexp.  This is the default behavior; this flag will not
          usually be needed.  If a call to `make-regexp' includes both
          `regexp/basic' and `regexp/extended' flags, the one which
          comes last will override the earlier one.

regexp-exec

- Scheme Procedure: regexp-exec rx str [start [flags]]
     Match the compiled regular expression RX against `str'.  If the
     optional integer START argument is provided, begin matching from
     that position in the string.  Return a match structure describing
     the results of the match, or `#f' if no match could be found.

     The FLAGS arguments change the matching behavior.  The following
     flags may be supplied:

     regexp/notbol
          Operator `^' always fails (unless `regexp/newline' is used).
          Use this when the beginning of the string should not be
          considered the beginning of a line.

     regexp/noteol
          Operator `$' always fails (unless `regexp/newline' is used).
          Use this when the end of the string should not be considered
          the end of a line.


<!DOCTYPE html>
<html><head>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<link href="sqlite.css" rel="stylesheet">
<title>Long Term Support</title>
<!-- path= -->
</head>
<body>
<div class=nosearch>
<a href="index.html">
<img class="logo" src="images/sqlite370_banner.gif" alt="SQLite" border="0">
</a>
<div><!-- IE hack to prevent disappearing logo --></div>
<div class="tagline desktoponly">
Small. Fast. Reliable.<br>Choose any three.
</div>
<div class="menu mainmenu">
<ul>
<li><a href="index.html">Home</a>
<li class='mobileonly'><a href="javascript:void(0)" onclick='toggle_div("submenu")'>Menu</a>
<li class='wideonly'><a href='about.html'>About</a>
<li class='desktoponly'><a href="docs.html">Documentation</a>
<li class='desktoponly'><a href="download.html">Download</a>
<li class='wideonly'><a href='copyright.html'>License</a>
<li class='desktoponly'><a href="support.html">Support</a>
<li class='desktoponly'><a href="prosupport.html">Purchase</a>
<li class='search' id='search_menubutton'>
<a href="javascript:void(0)" onclick='toggle_search()'>Search</a>
</ul>
</div>
<div class="menu submenu" id="submenu">
<ul>
<li><a href='about.html'>About</a>
<li><a href='docs.html'>Documentation</a>
<li><a href='download.html'>Download</a>
<li><a href='support.html'>Support</a>
<li><a href='prosupport.html'>Purchase</a>
</ul>
</div>
<div class="searchmenu" id="searchmenu">
<form method="GET" action="search">
<select name="s" id="searchtype">
<option value="d">Search Documentation</option>
<option value="c">Search Changelog</option>
</select>
<input type="text" name="q" id="searchbox" value="">
<input type="submit" value="Go">
</form>
</div>
</div>
<script>
function toggle_div(nm) {
var w = document.getElementById(nm);
if( w.style.display=="block" ){
w.style.display = "none";
}else{
w.style.display = "block";
}
}
function toggle_search() {
var w = document.getElementById("searchmenu");
if( w.style.display=="block" ){
w.style.display = "none";
} else {
w.style.display = "block";
setTimeout(function(){
document.getElementById("searchbox").focus()
}, 30);
}
}
function div_off(nm){document.getElementById(nm).style.display="none";}
window.onbeforeunload = function(e){div_off("submenu");}
/* Disable the Search feature if we are not operating from CGI, since */
/* Search is accomplished using CGI and will not work without it. */
if( !location.origin || !location.origin.match || !location.origin.match(/http/) ){
document.getElementById("search_menubutton").style.display = "none";
}
/* Used by the Hide/Show button beside syntax diagrams, to toggle the */
function hideorshow(btn,obj){
var x = document.getElementById(obj);
var b = document.getElementById(btn);
if( x.style.display!='none' ){
x.style.display = 'none';
b.innerHTML='show';
}else{
x.style.display = '';
b.innerHTML='hide';
}
return false;
}
</script>
</div>
<div class=fancy>
<div class=nosearch>
<div class="fancy_title">
Long Term Support
</div>
</div>





<p>
The intent of the developers is to support SQLite through
the year 2050.

</p><p>
At this writing, 2050 is still 34 years in the future.
Nobody knows what will happen in that time, and we cannot
absolutely promise that SQLite will be viable or useful that
far out.
But we can promise this: we plan as if we will be
supporting SQLite until 2050.
That long-term outlook affects our
decisions in important ways.

</p><ul>
<li><p>
<b>Cross-platform Code</b> &rarr;
SQLite runs on any platform with an 8-bit byte,
two's complement 32-bit and 64-bit integers, 
and a C compiler.  It is actively
tested on all currently popular CPUs and operating
systems.
The extreme portability of the SQLite code and file
format will help it remain viable on future platforms.

</p></li><li><p>
<b>Stable, Cross-platform Database Files</b> &rarr;
SQLite <a href="fileformat2.html">database files</a> are bit-for-bit identical on
32-bit, 64-bit, big-endian, and little-endian platforms.  You
can copy an SQLite database file from one system to another
without having to translate or convert the database.
Furthermore, the file format is well documented and stable.
Database files created today will be readable and writable by
future versions of SQLite decades in the future.

</p></li><li><p>
<b><a href="testing.html">Aviation-grade testing</a></b> &rarr;
Every machine-code branch instruction is tested in both
directions.  Multiple times.  On multiple platforms and with
multiple compilers.  This helps make the code robust for
future migrations.  The intense testing also means that new
developers can make experimental enhancements to SQLite and,
assuming legacy tests all pass, be reasonably sure that the
enhancement does not break legacy.

</p></li><li><p>
<b>Extensive, detailed documentation</b> &rarr;
SQLite has candid, developer-friendly,
and open-source documentation.  Docs are written by and
for programmers.
(A few examples:
<a href="./arch.html">[1]</a>
<a href="./fileformat.html">[2]</a>
<a href="./queryplanner.html">[3]</a>
<a href="./opcode.html">[4]</a>
<a href="./compile.html">[5]</a>
<a href="./malloc.html">[6]</a>
<a href="./debugging.html">[7]</a>
<a href="./howtocorrupt.html">[8]</a>)
The extensive documentation helps new developers
come up to speed on SQLite very quickly.

</p></li><li><p>
<b>Heavily commented source code</b> &rarr;
The SQLite source code is over 35% comment.  Not boiler-plate
comments, but useful comments that explain the meaning of variables
and objects and the intent of methods and procedures.  
The code is designed
to be accessible to new programmers and maintainable over a span
of decades.

</p></li><li><p>
<b>Disaster planning</b> &rarr;
Every byte of source-code history for SQLite is cryptographically
protected and is automatically replicated to multiple
geographically separated servers, in datacenters 
owned by different companies.
Thousands of additional clones exist on private servers around the
world.
The primary developers of SQLite live in different regions of the world.
SQLite can survive a continental catastrophe.

</p></li><li><p>
<b>Old school</b> &rarr;
Nobody is completely immune to trends and fads, but the SQLite
developers work hard to avoid being sucked into the latest programming
fashion.  Our aim is to produce timeless code that will be
readable, understandable, and maintainable by programmers 
who have not yet been born.
</p></li></ul>

<p>
In addition to "supporting" SQLite through the year 2050, the developers
also promise to keep the SQLite 
<a href="cintro.html">C-language API</a> and <a href="fileformat2.html">on-disk format</a> 
fully backwards compatible.
This means that application written to use SQLite today should be able to
link against and use future versions of SQLite released decades in the
future.

</p><p>
Our goal is to make the content you store in SQLite today as 
easily accessible to your grandchildren as it is to you.

</p><p>
<b>Update on 2018-05-31:</b>
Our goal of supporting SQLite long-term have apparently come to the
notice of the preservationist at the 
<a href="https://www.loc.gov">US Library Of Congress</a> who have identified
SQLite as a <a href="locrsf.html">recommended storage format</a> for the preservation of
digital content.
</p>
